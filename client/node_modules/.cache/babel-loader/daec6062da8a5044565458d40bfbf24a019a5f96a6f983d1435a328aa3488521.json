{"ast":null,"code":"'use strict';\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Nexmo Client SDK\n *  Utility functions\n *\n * Copyright (c) Nexmo Inc.\n */\nconst uuid_1 = __importDefault(require(\"uuid\"));\nconst socket_io_client_1 = __importDefault(require(\"socket.io-client\"));\nconst application_1 = __importDefault(require(\"./application\"));\nconst MEDIA_CONNECTIVITY_TIMEOUT = 40000; // 40s is the default timeout for ice candidates gathering\nconst WS_CONNECTIVITY_TIMEOUT = 20000; // 20s is the default timeout for ws connection\n/**\n * Utilities class for the SDK.\n *\n * @class Utils\n * @private\n */\nclass Utils {\n  /**\n   * Get the Member from the username of a conversation\n   *\n   * @param {string} username the username of the member to get\n   * @param {Conversation} conversation the Conversation to search in\n   * @returns {Member} the requested Member\n   * @static\n   */\n  static getMemberFromNameOrNull(conversation, username) {\n    if (!conversation || !username) return null;\n    for (let member of conversation.members.values()) {\n      if (member.user.name === username) {\n        return member;\n      }\n    }\n    return null;\n  }\n  /**\n   * Get the Member's number or uri from the event's channel field\n   *\n   * @param {object} channel the event's channel field\n   * @returns {string} the requested Member number or uri\n   * @static\n   */\n  static getMemberNumberFromEventOrNull(channel) {\n    const from = channel && channel.from;\n    if (from && (from.number || from.uri)) {\n      return from.number || from.uri;\n    }\n    return null;\n  }\n  /**\n   * Perform a network request to the given url\n   *\n   * @param {object} reqObject the object that has all the information for the request\n   * @param {string} url the request url\n   * @param {string} type=GET|POST|PUT|DELETE the types of the network request\n   * @param {object} [data] the data that are going to be sent\n   * @param {string} [responseType] the response type of the request\n   * @param {string} token the jwt token for the network request\n   * @returns {Promise<NetworkRequestResponse>} the NetworkRequestResponse\n   * @static\n   */\n  static networkRequest(reqObject) {\n    return new Promise((resolve, reject) => {\n      if (!reqObject.token && !reqObject.url.includes('logging') && !reqObject.url.includes('ping')) {\n        // eslint-disable-next-line prefer-promise-reject-errors\n        reject({\n          response: {\n            type: 'error:user:token',\n            description: 'network error on request. Please create a new session.'\n          }\n        });\n      }\n      const xhr = new XMLHttpRequest();\n      let data;\n      xhr.open(reqObject.type, reqObject.url, true);\n      if (reqObject.token) {\n        xhr.setRequestHeader('Authorization', 'Bearer ' + reqObject.token);\n      }\n      if (reqObject && reqObject.url.includes('image')) {\n        xhr.responseType = '';\n        data = reqObject.data;\n        xhr.onloadstart = () => {\n          resolve(xhr);\n        };\n      } else {\n        xhr.responseType = reqObject.responseType || 'json';\n        data = JSON.stringify(reqObject.data) || null;\n        xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');\n      }\n      xhr.onload = () => {\n        if (xhr.status === 200 || xhr.status === 201 || xhr.status === 204) {\n          resolve(xhr);\n        } else {\n          reject(xhr);\n        }\n      };\n      xhr.onerror = error => {\n        reject(error);\n      };\n      xhr.send(data);\n    });\n  }\n  /**\n   * Perform a GET network request for fetching paginated conversations and events\n   *\n   * @param {string} url the request url\n   * @param {object} [params] network request params\n   * @param {string} [params.cursor] cursor parameter to access the next or previous page of a data set\n   * @param {number} [params.page_size] the number of resources returned in a single request list\n   * @param {string} [params.order] 'asc' or 'desc' ordering of resources (usually based on creation time)\n   * @param {string} [params.event_type] the type of event used to filter event requests ('member:joined', 'audio:dtmf', etc)\n   * @param {string} token the jwt token for the network request\n   * @param {string} [version=Application.CONVERSATION_API_VERSION.v1] version of conversation service that is used for the request (one of v1 and v3)\n   *\n   * @returns {Promise<XMLHttpRequest.response>} the XMLHttpRequest\n   * @static\n   * @example <caption>Sending a nexmo GET request</caption>\n   *    paginationRequest(url, params).then((response) => {\n   *      response.items: {},\n   *      response.cursor: {\n   *          prev: '',\n   *          next: '',\n   *          self: ''\n   *      },\n   *      response.page_size: 10,\n   *      response.order: 'asc',\n   *   });\n   */\n  static async paginationRequest(url, params, token, version = application_1.default.CONVERSATION_API_VERSION.v1) {\n    try {\n      const xhr = await Utils.networkRequest({\n        type: 'GET',\n        url: Utils.addUrlSearchParams(url, params),\n        token\n      });\n      const {\n        page_size,\n        _embedded,\n        _links\n      } = xhr.response;\n      const resource = url.split('/').pop().trim();\n      return {\n        items: version === application_1.default.CONVERSATION_API_VERSION.v1 ? _embedded.data[resource] : _embedded[resource],\n        cursor: {\n          prev: _links.prev ? new URLSearchParams(_links.prev.href).get('cursor') : '',\n          next: _links.next ? new URLSearchParams(_links.next.href).get('cursor') : '',\n          self: _links.self ? new URLSearchParams(_links.self.href).get('cursor') : ''\n        },\n        page_size: page_size,\n        order: params.order || 'asc',\n        event_type: params.event_type || null\n      };\n    } catch ({\n      response\n    }) {\n      const parsed_error = response ? response : {\n        type: 'error:network:get-request',\n        description: 'network error on nexmo get request'\n      };\n      if (parsed_error.validation) {\n        parsed_error.description = parsed_error.validation[Object.keys(parsed_error.validation)[0]];\n      }\n      throw parsed_error;\n    }\n  }\n  /**\n   * Update the Search Params of a url\n   * @returns {string} the appended url\n   * @static\n   */\n  static addUrlSearchParams(url, params = {}) {\n    let appended_url = new URL(url);\n    Object.keys(params).forEach(key => {\n      if (params[key] && !(typeof params[key] === 'string' && params[key].length < 1) && params[key] !== null) {\n        appended_url.searchParams.set(key, params[key]);\n      }\n    });\n    return appended_url.href;\n  }\n  /**\n   * Deep merges two objects\n   * @returns {Object} the new merged object\n   * @static\n   */\n  static deepMergeObj(obj1, obj2) {\n    const mergedObj = JSON.parse(JSON.stringify(obj1));\n    // Merge the object into the new mergedObject\n    for (let prop in obj2) {\n      // If the property is an object then merge properties\n      if (Object.prototype.toString.call(obj2[prop]) === '[object Object]') {\n        mergedObj[prop] = Utils.deepMergeObj(mergedObj[prop], obj2[prop]);\n      } else {\n        mergedObj[prop] = obj2[prop];\n      }\n    }\n    return mergedObj;\n  }\n  /**\n   * Inject a script into the document\n   *\n   * @param {string} s script being executed\n   * @param {requestCallback} c the callback fired after script executed\n   * @static\n   */\n  static injectScript(u, c) {\n    if (typeof document !== 'undefined') {\n      let h = document.getElementsByTagName('head')[0];\n      let s = document.createElement('script');\n      s.async = true;\n      s.src = u;\n      s.onload = s.onreadystatechange = () => {\n        if (!s.readyState || /loaded|complete/.test(s.readyState)) {\n          s.onload = s.onreadystatechange = null;\n          s = null;\n          if (c) {\n            c();\n          }\n        }\n      };\n      h.insertBefore(s, h.firstChild);\n    }\n  }\n  static allocateUUID() {\n    return uuid_1.default.v4();\n  }\n  /**\n   * Validate dtmf digit\n   * @static\n   */\n  static validateDTMF(digit) {\n    return typeof digit === 'string' ? /^[\\da-dA-D#*pP]{1,45}$$/.test(digit) : false;\n  }\n  /**\n   * Get the nexmo bugsnag api key\n   * @private\n   */\n  static _getBugsnagKey() {\n    return '76498fc1ca8d9b0a173a44e2b873d7ed';\n  }\n  /**\n   * Update the member legs array with the new one received in the event\n   *\n   * @param {Array} legs the member legs array\n   * @param {NXMEvent} event the member event holding the new legs array\n   * @static\n   */\n  static updateMemberLegs(legs, event) {\n    if (legs) {\n      // find the leg in the legs array if exists\n      const leg = legs.find(leg => leg.leg_id === event.body.leg_id);\n      if (!leg) {\n        legs.push({\n          leg_id: event.body.leg_id,\n          status: event.body.status\n        });\n      } else if (leg.status !== event.body.status) {\n        // if the status of the leg is different from the event status\n        // update the leg object with the new leg status\n        let index = legs.indexOf(leg);\n        legs.fill(leg.status = event.body.status, index, index++);\n      }\n    } else {\n      legs = [{\n        leg_id: event.body.leg_id,\n        status: event.body.status\n      }];\n    }\n    return legs;\n  }\n  /**\n   * Check if the event is referenced to a call or simple conversation\n   * @private\n   */\n  static _isCallEvent(event) {\n    const {\n      channel,\n      media\n    } = event.body;\n    // in case we have a transfer we should fetch the conversation\n    // including the new membership\n    if (event.type === \"rtc:transfer\") return true;\n    // this check differentiates the call flow with the non call\n    // IP-PSTN (member:joined) should have an knocking_id inside the channel\n    // PSTN-IP and IP-IP (member:invited) should have audio_settings.enabled = true\n    if (channel && (media && media.audio_settings && media.audio_settings.enabled || media && media.audio && media.audio.enabled || channel.knocking_id)) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Fetch an image from Media Service\n   * @private\n   */\n  static async _fetchImage(url, token) {\n    const {\n      response\n    } = await Utils.networkRequest({\n      type: 'GET',\n      url,\n      responseType: 'arraybuffer',\n      token\n    });\n    const responseArray = new Uint8Array(response);\n    // Convert the int array to a binary String\n    // We have to use apply() as we are converting an *array*\n    // and String.fromCharCode() takes one or more single values, not\n    // an array.\n    // support large image files (Chunking)\n    let res = '';\n    const chunk = 8 * 1024;\n    let i;\n    for (i = 0; i < responseArray.length / chunk; i++) {\n      res += String.fromCharCode.apply(null, responseArray.subarray(i * chunk, (i + 1) * chunk));\n    }\n    res += String.fromCharCode.apply(null, responseArray.subarray(i * chunk));\n    return 'data:image/jpeg;base64,' + btoa(res);\n  }\n  /**\n   * Check if HTTP URL is reachable\n   * @private\n   */\n  static async _checkHttpConnectivity(url) {\n    const timeBeforeConnecting = Date.now();\n    try {\n      await Utils.networkRequest({\n        type: 'GET',\n        url\n      });\n      const connectionTime = Date.now() - timeBeforeConnecting;\n      return {\n        url,\n        canConnect: true,\n        connectionTime\n      };\n    } catch (error) {\n      return {\n        url,\n        canConnect: false,\n        error\n      };\n    }\n  }\n  /**\n   * Check if websocket URL is reachable\n   * @private\n   */\n  static _checkWsConnectivity(ws_url, path, config) {\n    return new Promise((resolve, reject) => {\n      const socket_io_config = Object.assign({\n        path\n      }, config);\n      const timeBeforeConnecting = Date.now();\n      const connection = socket_io_client_1.default.connect(ws_url, socket_io_config);\n      const timeout = setTimeout(() => resolve({\n        url: ws_url,\n        canConnect: false\n      }), WS_CONNECTIVITY_TIMEOUT);\n      connection.on('connect', () => {\n        const connectionTime = Date.now() - timeBeforeConnecting;\n        connection.disconnect();\n        clearTimeout(timeout);\n        resolve({\n          url: ws_url,\n          canConnect: true,\n          connectionTime\n        });\n      });\n      connection.on('error', error => {\n        connection.disconnect();\n        clearTimeout(timeout);\n        resolve({\n          url: ws_url,\n          canConnect: false,\n          error\n        });\n      });\n    });\n  }\n  /**\n   * Return a list with the connection health of the Media Servers\n   * @private\n   */\n  static async _checkMediaServers(token, nexmo_api_url, datacenter) {\n    try {\n      const {\n        response\n      } = await Utils.networkRequest({\n        type: 'GET',\n        url: `${nexmo_api_url}/v0.3/discovery/media/${datacenter}`,\n        token\n      });\n      const reqList = response.map(host => Utils._checkMediaConnectivity(host.ip, host.port));\n      return await Promise.all(reqList);\n    } catch (error) {\n      return [];\n    }\n  }\n  /**\n   * Check if we can establish a peer connection with a specific Media Server\n   * @private\n   */\n  static async _checkMediaConnectivity(ip, port) {\n    return new Promise(async (resolve, reject) => {\n      const configuration = {\n        iceServers: [{\n          urls: `stun:${ip}:${port}`\n        }]\n      };\n      const pc = new RTCPeerConnection(configuration);\n      const timeBeforeConnecting = Date.now();\n      const offer = await pc.createOffer({\n        offerToReceiveAudio: true\n      });\n      pc.setLocalDescription(offer);\n      const timeout = setTimeout(() => {\n        pc.close();\n        resolve({\n          ip,\n          canConnect: false\n        });\n      }, MEDIA_CONNECTIVITY_TIMEOUT);\n      pc.onicecandidate = ({\n        candidate\n      }) => {\n        var _a;\n        if (((_a = candidate) === null || _a === void 0 ? void 0 : _a.type) === \"srflx\") {\n          const connectionTime = Date.now() - timeBeforeConnecting;\n          // Connection established successfully\n          clearTimeout(timeout);\n          pc.close();\n          resolve({\n            ip,\n            canConnect: true,\n            connectionTime\n          });\n        }\n      };\n      pc.onicecandidateerror = event => {\n        if (event.errorCode) {\n          pc.close();\n          clearTimeout(timeout);\n          resolve({\n            ip,\n            canConnect: false,\n            error: event\n          });\n        }\n      };\n    });\n  }\n  /**\n   * Check if the user is re invited to an existing conversation\n   * @private\n   */\n  static _checkIfUserIsReInvited(conversations, event) {\n    var _a;\n    if (!conversations.has(event.cid)) return false;\n    if (!(event.type === 'member:invited' || event.type === 'member:joined')) return false;\n    const me = (_a = conversations.get(event.cid)) === null || _a === void 0 ? void 0 : _a.me;\n    if (!me) return false;\n    if (me.user.name === event.body.user.name && me.state === 'LEFT') return true;\n    return false;\n  }\n}\nexports.default = Utils;\nmodule.exports = Utils;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","uuid_1","require","socket_io_client_1","application_1","MEDIA_CONNECTIVITY_TIMEOUT","WS_CONNECTIVITY_TIMEOUT","Utils","getMemberFromNameOrNull","conversation","username","member","members","values","user","name","getMemberNumberFromEventOrNull","channel","from","number","uri","networkRequest","reqObject","Promise","resolve","reject","token","url","includes","response","type","description","xhr","XMLHttpRequest","data","open","setRequestHeader","responseType","onloadstart","JSON","stringify","onload","status","onerror","error","send","paginationRequest","params","version","default","CONVERSATION_API_VERSION","v1","addUrlSearchParams","page_size","_embedded","_links","resource","split","pop","trim","items","cursor","prev","URLSearchParams","href","get","next","self","order","event_type","parsed_error","validation","keys","appended_url","URL","forEach","key","length","searchParams","set","deepMergeObj","obj1","obj2","mergedObj","parse","prop","prototype","toString","call","injectScript","u","c","document","h","getElementsByTagName","s","createElement","async","src","onreadystatechange","readyState","test","insertBefore","firstChild","allocateUUID","v4","validateDTMF","digit","_getBugsnagKey","updateMemberLegs","legs","event","leg","find","leg_id","body","push","index","indexOf","fill","_isCallEvent","media","audio_settings","enabled","audio","knocking_id","_fetchImage","responseArray","Uint8Array","res","chunk","i","String","fromCharCode","apply","subarray","btoa","_checkHttpConnectivity","timeBeforeConnecting","Date","now","connectionTime","canConnect","_checkWsConnectivity","ws_url","path","config","socket_io_config","assign","connection","connect","timeout","setTimeout","on","disconnect","clearTimeout","_checkMediaServers","nexmo_api_url","datacenter","reqList","map","host","_checkMediaConnectivity","ip","port","all","configuration","iceServers","urls","pc","RTCPeerConnection","offer","createOffer","offerToReceiveAudio","setLocalDescription","close","onicecandidate","candidate","_a","onicecandidateerror","errorCode","_checkIfUserIsReInvited","conversations","has","cid","me","state","module"],"sources":["/Users/vineetkhodre/react-workspace/thoughtctlchatapp/client/node_modules/nexmo-client/dist/utils.js"],"sourcesContent":["'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  Utility functions\n *\n * Copyright (c) Nexmo Inc.\n */\nconst uuid_1 = __importDefault(require(\"uuid\"));\nconst socket_io_client_1 = __importDefault(require(\"socket.io-client\"));\nconst application_1 = __importDefault(require(\"./application\"));\nconst MEDIA_CONNECTIVITY_TIMEOUT = 40000; // 40s is the default timeout for ice candidates gathering\nconst WS_CONNECTIVITY_TIMEOUT = 20000; // 20s is the default timeout for ws connection\n/**\n * Utilities class for the SDK.\n *\n * @class Utils\n * @private\n */\nclass Utils {\n    /**\n     * Get the Member from the username of a conversation\n     *\n     * @param {string} username the username of the member to get\n     * @param {Conversation} conversation the Conversation to search in\n     * @returns {Member} the requested Member\n     * @static\n     */\n    static getMemberFromNameOrNull(conversation, username) {\n        if (!conversation || !username)\n            return null;\n        for (let member of conversation.members.values()) {\n            if (member.user.name === username) {\n                return member;\n            }\n        }\n        return null;\n    }\n    /**\n     * Get the Member's number or uri from the event's channel field\n     *\n     * @param {object} channel the event's channel field\n     * @returns {string} the requested Member number or uri\n     * @static\n     */\n    static getMemberNumberFromEventOrNull(channel) {\n        const from = channel && channel.from;\n        if (from && (from.number || from.uri)) {\n            return from.number || from.uri;\n        }\n        return null;\n    }\n    /**\n     * Perform a network request to the given url\n     *\n     * @param {object} reqObject the object that has all the information for the request\n     * @param {string} url the request url\n     * @param {string} type=GET|POST|PUT|DELETE the types of the network request\n     * @param {object} [data] the data that are going to be sent\n     * @param {string} [responseType] the response type of the request\n     * @param {string} token the jwt token for the network request\n     * @returns {Promise<NetworkRequestResponse>} the NetworkRequestResponse\n     * @static\n     */\n    static networkRequest(reqObject) {\n        return new Promise((resolve, reject) => {\n            if (!reqObject.token &&\n                !reqObject.url.includes('logging') &&\n                !reqObject.url.includes('ping')) {\n                // eslint-disable-next-line prefer-promise-reject-errors\n                reject({\n                    response: {\n                        type: 'error:user:token',\n                        description: 'network error on request. Please create a new session.'\n                    }\n                });\n            }\n            const xhr = new XMLHttpRequest();\n            let data;\n            xhr.open(reqObject.type, reqObject.url, true);\n            if (reqObject.token) {\n                xhr.setRequestHeader('Authorization', 'Bearer ' + reqObject.token);\n            }\n            if (reqObject && reqObject.url.includes('image')) {\n                xhr.responseType = '';\n                data = reqObject.data;\n                xhr.onloadstart = () => {\n                    resolve(xhr);\n                };\n            }\n            else {\n                xhr.responseType = reqObject.responseType || 'json';\n                data = JSON.stringify(reqObject.data) || null;\n                xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');\n            }\n            xhr.onload = () => {\n                if (xhr.status === 200 || xhr.status === 201 || xhr.status === 204) {\n                    resolve(xhr);\n                }\n                else {\n                    reject(xhr);\n                }\n            };\n            xhr.onerror = (error) => {\n                reject(error);\n            };\n            xhr.send(data);\n        });\n    }\n    /**\n     * Perform a GET network request for fetching paginated conversations and events\n     *\n     * @param {string} url the request url\n     * @param {object} [params] network request params\n     * @param {string} [params.cursor] cursor parameter to access the next or previous page of a data set\n     * @param {number} [params.page_size] the number of resources returned in a single request list\n     * @param {string} [params.order] 'asc' or 'desc' ordering of resources (usually based on creation time)\n     * @param {string} [params.event_type] the type of event used to filter event requests ('member:joined', 'audio:dtmf', etc)\n     * @param {string} token the jwt token for the network request\n     * @param {string} [version=Application.CONVERSATION_API_VERSION.v1] version of conversation service that is used for the request (one of v1 and v3)\n     *\n     * @returns {Promise<XMLHttpRequest.response>} the XMLHttpRequest\n     * @static\n     * @example <caption>Sending a nexmo GET request</caption>\n     *    paginationRequest(url, params).then((response) => {\n     *      response.items: {},\n     *      response.cursor: {\n     *          prev: '',\n     *          next: '',\n     *          self: ''\n     *      },\n     *      response.page_size: 10,\n     *      response.order: 'asc',\n     *   });\n     */\n    static async paginationRequest(url, params, token, version = application_1.default.CONVERSATION_API_VERSION.v1) {\n        try {\n            const xhr = await Utils.networkRequest({\n                type: 'GET',\n                url: Utils.addUrlSearchParams(url, params),\n                token\n            });\n            const { page_size, _embedded, _links } = xhr.response;\n            const resource = url.split('/').pop().trim();\n            return {\n                items: (version === application_1.default.CONVERSATION_API_VERSION.v1) ? _embedded.data[resource] : _embedded[resource],\n                cursor: {\n                    prev: _links.prev ? new URLSearchParams(_links.prev.href).get('cursor') : '',\n                    next: _links.next ? new URLSearchParams(_links.next.href).get('cursor') : '',\n                    self: _links.self ? new URLSearchParams(_links.self.href).get('cursor') : ''\n                },\n                page_size: page_size,\n                order: params.order || 'asc',\n                event_type: params.event_type || null\n            };\n        }\n        catch ({ response }) {\n            const parsed_error = response ?\n                response : { type: 'error:network:get-request', description: 'network error on nexmo get request' };\n            if (parsed_error.validation) {\n                parsed_error.description = parsed_error.validation[Object.keys(parsed_error.validation)[0]];\n            }\n            throw parsed_error;\n        }\n    }\n    /**\n     * Update the Search Params of a url\n     * @returns {string} the appended url\n     * @static\n     */\n    static addUrlSearchParams(url, params = {}) {\n        let appended_url = new URL(url);\n        Object.keys(params).forEach((key) => {\n            if (params[key] && !(typeof params[key] === 'string' && params[key].length < 1) && params[key] !== null) {\n                appended_url.searchParams.set(key, params[key]);\n            }\n        });\n        return appended_url.href;\n    }\n    /**\n     * Deep merges two objects\n     * @returns {Object} the new merged object\n     * @static\n     */\n    static deepMergeObj(obj1, obj2) {\n        const mergedObj = JSON.parse(JSON.stringify(obj1));\n        // Merge the object into the new mergedObject\n        for (let prop in obj2) {\n            // If the property is an object then merge properties\n            if (Object.prototype.toString.call(obj2[prop]) === '[object Object]') {\n                mergedObj[prop] = Utils.deepMergeObj(mergedObj[prop], obj2[prop]);\n            }\n            else {\n                mergedObj[prop] = obj2[prop];\n            }\n        }\n        return mergedObj;\n    }\n    /**\n     * Inject a script into the document\n     *\n     * @param {string} s script being executed\n     * @param {requestCallback} c the callback fired after script executed\n     * @static\n     */\n    static injectScript(u, c) {\n        if (typeof document !== 'undefined') {\n            let h = document.getElementsByTagName('head')[0];\n            let s = document.createElement('script');\n            s.async = true;\n            s.src = u;\n            s.onload = s.onreadystatechange = () => {\n                if (!s.readyState || /loaded|complete/.test(s.readyState)) {\n                    s.onload = s.onreadystatechange = null;\n                    s = null;\n                    if (c) {\n                        c();\n                    }\n                }\n            };\n            h.insertBefore(s, h.firstChild);\n        }\n    }\n    static allocateUUID() {\n        return uuid_1.default.v4();\n    }\n    /**\n     * Validate dtmf digit\n     * @static\n     */\n    static validateDTMF(digit) {\n        return typeof digit === 'string' ? /^[\\da-dA-D#*pP]{1,45}$$/.test(digit) : false;\n    }\n    /**\n     * Get the nexmo bugsnag api key\n     * @private\n     */\n    static _getBugsnagKey() {\n        return '76498fc1ca8d9b0a173a44e2b873d7ed';\n    }\n    /**\n     * Update the member legs array with the new one received in the event\n     *\n     * @param {Array} legs the member legs array\n     * @param {NXMEvent} event the member event holding the new legs array\n     * @static\n     */\n    static updateMemberLegs(legs, event) {\n        if (legs) {\n            // find the leg in the legs array if exists\n            const leg = legs.find((leg) => leg.leg_id === event.body.leg_id);\n            if (!leg) {\n                legs.push({\n                    leg_id: event.body.leg_id,\n                    status: event.body.status\n                });\n            }\n            else if (leg.status !== event.body.status) {\n                // if the status of the leg is different from the event status\n                // update the leg object with the new leg status\n                let index = legs.indexOf(leg);\n                legs.fill(leg.status = event.body.status, index, index++);\n            }\n        }\n        else {\n            legs = [{\n                    leg_id: event.body.leg_id,\n                    status: event.body.status\n                }];\n        }\n        return legs;\n    }\n    /**\n     * Check if the event is referenced to a call or simple conversation\n     * @private\n     */\n    static _isCallEvent(event) {\n        const { channel, media } = event.body;\n        // in case we have a transfer we should fetch the conversation\n        // including the new membership\n        if (event.type === \"rtc:transfer\")\n            return true;\n        // this check differentiates the call flow with the non call\n        // IP-PSTN (member:joined) should have an knocking_id inside the channel\n        // PSTN-IP and IP-IP (member:invited) should have audio_settings.enabled = true\n        if (channel && ((media && media.audio_settings && media.audio_settings.enabled) ||\n            (media && media.audio && media.audio.enabled) || channel.knocking_id)) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Fetch an image from Media Service\n     * @private\n     */\n    static async _fetchImage(url, token) {\n        const { response } = await Utils.networkRequest({\n            type: 'GET',\n            url,\n            responseType: 'arraybuffer',\n            token\n        });\n        const responseArray = new Uint8Array(response);\n        // Convert the int array to a binary String\n        // We have to use apply() as we are converting an *array*\n        // and String.fromCharCode() takes one or more single values, not\n        // an array.\n        // support large image files (Chunking)\n        let res = '';\n        const chunk = 8 * 1024;\n        let i;\n        for (i = 0; i < responseArray.length / chunk; i++) {\n            res += String.fromCharCode.apply(null, responseArray.subarray(i * chunk, (i + 1) * chunk));\n        }\n        res += String.fromCharCode.apply(null, responseArray.subarray(i * chunk));\n        return 'data:image/jpeg;base64,' + btoa(res);\n    }\n    /**\n     * Check if HTTP URL is reachable\n     * @private\n     */\n    static async _checkHttpConnectivity(url) {\n        const timeBeforeConnecting = Date.now();\n        try {\n            await Utils.networkRequest({\n                type: 'GET',\n                url\n            });\n            const connectionTime = Date.now() - timeBeforeConnecting;\n            return { url, canConnect: true, connectionTime };\n        }\n        catch (error) {\n            return { url, canConnect: false, error };\n        }\n    }\n    /**\n     * Check if websocket URL is reachable\n     * @private\n     */\n    static _checkWsConnectivity(ws_url, path, config) {\n        return new Promise((resolve, reject) => {\n            const socket_io_config = Object.assign({ path }, config);\n            const timeBeforeConnecting = Date.now();\n            const connection = socket_io_client_1.default.connect(ws_url, socket_io_config);\n            const timeout = setTimeout(() => resolve({ url: ws_url, canConnect: false }), WS_CONNECTIVITY_TIMEOUT);\n            connection.on('connect', () => {\n                const connectionTime = Date.now() - timeBeforeConnecting;\n                connection.disconnect();\n                clearTimeout(timeout);\n                resolve({ url: ws_url, canConnect: true, connectionTime });\n            });\n            connection.on('error', (error) => {\n                connection.disconnect();\n                clearTimeout(timeout);\n                resolve({ url: ws_url, canConnect: false, error });\n            });\n        });\n    }\n    /**\n     * Return a list with the connection health of the Media Servers\n     * @private\n     */\n    static async _checkMediaServers(token, nexmo_api_url, datacenter) {\n        try {\n            const { response } = await Utils.networkRequest({\n                type: 'GET',\n                url: `${nexmo_api_url}/v0.3/discovery/media/${datacenter}`,\n                token\n            });\n            const reqList = response.map((host) => Utils._checkMediaConnectivity(host.ip, host.port));\n            return await Promise.all(reqList);\n        }\n        catch (error) {\n            return [];\n        }\n    }\n    /**\n     * Check if we can establish a peer connection with a specific Media Server\n     * @private\n     */\n    static async _checkMediaConnectivity(ip, port) {\n        return new Promise(async (resolve, reject) => {\n            const configuration = { iceServers: [{ urls: `stun:${ip}:${port}` }] };\n            const pc = new RTCPeerConnection(configuration);\n            const timeBeforeConnecting = Date.now();\n            const offer = await pc.createOffer({ offerToReceiveAudio: true });\n            pc.setLocalDescription(offer);\n            const timeout = setTimeout(() => {\n                pc.close();\n                resolve({ ip, canConnect: false });\n            }, MEDIA_CONNECTIVITY_TIMEOUT);\n            pc.onicecandidate = ({ candidate }) => {\n                var _a;\n                if (((_a = candidate) === null || _a === void 0 ? void 0 : _a.type) === \"srflx\") {\n                    const connectionTime = Date.now() - timeBeforeConnecting;\n                    // Connection established successfully\n                    clearTimeout(timeout);\n                    pc.close();\n                    resolve({ ip, canConnect: true, connectionTime });\n                }\n            };\n            pc.onicecandidateerror = (event) => {\n                if (event.errorCode) {\n                    pc.close();\n                    clearTimeout(timeout);\n                    resolve({ ip, canConnect: false, error: event });\n                }\n            };\n        });\n    }\n    /**\n     * Check if the user is re invited to an existing conversation\n     * @private\n     */\n    static _checkIfUserIsReInvited(conversations, event) {\n        var _a;\n        if (!conversations.has(event.cid))\n            return false;\n        if (!(event.type === 'member:invited' || event.type === 'member:joined'))\n            return false;\n        const me = (_a = conversations.get(event.cid)) === null || _a === void 0 ? void 0 : _a.me;\n        if (!me)\n            return false;\n        if (me.user.name === event.body.user.name && me.state === 'LEFT')\n            return true;\n        return false;\n    }\n}\nexports.default = Utils;\nmodule.exports = Utils;\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUC,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDE,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,MAAM,GAAGP,eAAe,CAACQ,OAAO,CAAC,MAAM,CAAC,CAAC;AAC/C,MAAMC,kBAAkB,GAAGT,eAAe,CAACQ,OAAO,CAAC,kBAAkB,CAAC,CAAC;AACvE,MAAME,aAAa,GAAGV,eAAe,CAACQ,OAAO,CAAC,eAAe,CAAC,CAAC;AAC/D,MAAMG,0BAA0B,GAAG,KAAK,CAAC,CAAC;AAC1C,MAAMC,uBAAuB,GAAG,KAAK,CAAC,CAAC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,KAAK,CAAC;EACR;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOC,uBAAuBA,CAACC,YAAY,EAAEC,QAAQ,EAAE;IACnD,IAAI,CAACD,YAAY,IAAI,CAACC,QAAQ,EAC1B,OAAO,IAAI;IACf,KAAK,IAAIC,MAAM,IAAIF,YAAY,CAACG,OAAO,CAACC,MAAM,CAAC,CAAC,EAAE;MAC9C,IAAIF,MAAM,CAACG,IAAI,CAACC,IAAI,KAAKL,QAAQ,EAAE;QAC/B,OAAOC,MAAM;MACjB;IACJ;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,OAAOK,8BAA8BA,CAACC,OAAO,EAAE;IAC3C,MAAMC,IAAI,GAAGD,OAAO,IAAIA,OAAO,CAACC,IAAI;IACpC,IAAIA,IAAI,KAAKA,IAAI,CAACC,MAAM,IAAID,IAAI,CAACE,GAAG,CAAC,EAAE;MACnC,OAAOF,IAAI,CAACC,MAAM,IAAID,IAAI,CAACE,GAAG;IAClC;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOC,cAAcA,CAACC,SAAS,EAAE;IAC7B,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACpC,IAAI,CAACH,SAAS,CAACI,KAAK,IAChB,CAACJ,SAAS,CAACK,GAAG,CAACC,QAAQ,CAAC,SAAS,CAAC,IAClC,CAACN,SAAS,CAACK,GAAG,CAACC,QAAQ,CAAC,MAAM,CAAC,EAAE;QACjC;QACAH,MAAM,CAAC;UACHI,QAAQ,EAAE;YACNC,IAAI,EAAE,kBAAkB;YACxBC,WAAW,EAAE;UACjB;QACJ,CAAC,CAAC;MACN;MACA,MAAMC,GAAG,GAAG,IAAIC,cAAc,CAAC,CAAC;MAChC,IAAIC,IAAI;MACRF,GAAG,CAACG,IAAI,CAACb,SAAS,CAACQ,IAAI,EAAER,SAAS,CAACK,GAAG,EAAE,IAAI,CAAC;MAC7C,IAAIL,SAAS,CAACI,KAAK,EAAE;QACjBM,GAAG,CAACI,gBAAgB,CAAC,eAAe,EAAE,SAAS,GAAGd,SAAS,CAACI,KAAK,CAAC;MACtE;MACA,IAAIJ,SAAS,IAAIA,SAAS,CAACK,GAAG,CAACC,QAAQ,CAAC,OAAO,CAAC,EAAE;QAC9CI,GAAG,CAACK,YAAY,GAAG,EAAE;QACrBH,IAAI,GAAGZ,SAAS,CAACY,IAAI;QACrBF,GAAG,CAACM,WAAW,GAAG,MAAM;UACpBd,OAAO,CAACQ,GAAG,CAAC;QAChB,CAAC;MACL,CAAC,MACI;QACDA,GAAG,CAACK,YAAY,GAAGf,SAAS,CAACe,YAAY,IAAI,MAAM;QACnDH,IAAI,GAAGK,IAAI,CAACC,SAAS,CAAClB,SAAS,CAACY,IAAI,CAAC,IAAI,IAAI;QAC7CF,GAAG,CAACI,gBAAgB,CAAC,cAAc,EAAE,iCAAiC,CAAC;MAC3E;MACAJ,GAAG,CAACS,MAAM,GAAG,MAAM;QACf,IAAIT,GAAG,CAACU,MAAM,KAAK,GAAG,IAAIV,GAAG,CAACU,MAAM,KAAK,GAAG,IAAIV,GAAG,CAACU,MAAM,KAAK,GAAG,EAAE;UAChElB,OAAO,CAACQ,GAAG,CAAC;QAChB,CAAC,MACI;UACDP,MAAM,CAACO,GAAG,CAAC;QACf;MACJ,CAAC;MACDA,GAAG,CAACW,OAAO,GAAIC,KAAK,IAAK;QACrBnB,MAAM,CAACmB,KAAK,CAAC;MACjB,CAAC;MACDZ,GAAG,CAACa,IAAI,CAACX,IAAI,CAAC;IAClB,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,aAAaY,iBAAiBA,CAACnB,GAAG,EAAEoB,MAAM,EAAErB,KAAK,EAAEsB,OAAO,GAAG5C,aAAa,CAAC6C,OAAO,CAACC,wBAAwB,CAACC,EAAE,EAAE;IAC5G,IAAI;MACA,MAAMnB,GAAG,GAAG,MAAMzB,KAAK,CAACc,cAAc,CAAC;QACnCS,IAAI,EAAE,KAAK;QACXH,GAAG,EAAEpB,KAAK,CAAC6C,kBAAkB,CAACzB,GAAG,EAAEoB,MAAM,CAAC;QAC1CrB;MACJ,CAAC,CAAC;MACF,MAAM;QAAE2B,SAAS;QAAEC,SAAS;QAAEC;MAAO,CAAC,GAAGvB,GAAG,CAACH,QAAQ;MACrD,MAAM2B,QAAQ,GAAG7B,GAAG,CAAC8B,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC;MAC5C,OAAO;QACHC,KAAK,EAAGZ,OAAO,KAAK5C,aAAa,CAAC6C,OAAO,CAACC,wBAAwB,CAACC,EAAE,GAAIG,SAAS,CAACpB,IAAI,CAACsB,QAAQ,CAAC,GAAGF,SAAS,CAACE,QAAQ,CAAC;QACvHK,MAAM,EAAE;UACJC,IAAI,EAAEP,MAAM,CAACO,IAAI,GAAG,IAAIC,eAAe,CAACR,MAAM,CAACO,IAAI,CAACE,IAAI,CAAC,CAACC,GAAG,CAAC,QAAQ,CAAC,GAAG,EAAE;UAC5EC,IAAI,EAAEX,MAAM,CAACW,IAAI,GAAG,IAAIH,eAAe,CAACR,MAAM,CAACW,IAAI,CAACF,IAAI,CAAC,CAACC,GAAG,CAAC,QAAQ,CAAC,GAAG,EAAE;UAC5EE,IAAI,EAAEZ,MAAM,CAACY,IAAI,GAAG,IAAIJ,eAAe,CAACR,MAAM,CAACY,IAAI,CAACH,IAAI,CAAC,CAACC,GAAG,CAAC,QAAQ,CAAC,GAAG;QAC9E,CAAC;QACDZ,SAAS,EAAEA,SAAS;QACpBe,KAAK,EAAErB,MAAM,CAACqB,KAAK,IAAI,KAAK;QAC5BC,UAAU,EAAEtB,MAAM,CAACsB,UAAU,IAAI;MACrC,CAAC;IACL,CAAC,CACD,OAAO;MAAExC;IAAS,CAAC,EAAE;MACjB,MAAMyC,YAAY,GAAGzC,QAAQ,GACzBA,QAAQ,GAAG;QAAEC,IAAI,EAAE,2BAA2B;QAAEC,WAAW,EAAE;MAAqC,CAAC;MACvG,IAAIuC,YAAY,CAACC,UAAU,EAAE;QACzBD,YAAY,CAACvC,WAAW,GAAGuC,YAAY,CAACC,UAAU,CAAC1E,MAAM,CAAC2E,IAAI,CAACF,YAAY,CAACC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;MAC/F;MACA,MAAMD,YAAY;IACtB;EACJ;EACA;AACJ;AACA;AACA;AACA;EACI,OAAOlB,kBAAkBA,CAACzB,GAAG,EAAEoB,MAAM,GAAG,CAAC,CAAC,EAAE;IACxC,IAAI0B,YAAY,GAAG,IAAIC,GAAG,CAAC/C,GAAG,CAAC;IAC/B9B,MAAM,CAAC2E,IAAI,CAACzB,MAAM,CAAC,CAAC4B,OAAO,CAAEC,GAAG,IAAK;MACjC,IAAI7B,MAAM,CAAC6B,GAAG,CAAC,IAAI,EAAE,OAAO7B,MAAM,CAAC6B,GAAG,CAAC,KAAK,QAAQ,IAAI7B,MAAM,CAAC6B,GAAG,CAAC,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI9B,MAAM,CAAC6B,GAAG,CAAC,KAAK,IAAI,EAAE;QACrGH,YAAY,CAACK,YAAY,CAACC,GAAG,CAACH,GAAG,EAAE7B,MAAM,CAAC6B,GAAG,CAAC,CAAC;MACnD;IACJ,CAAC,CAAC;IACF,OAAOH,YAAY,CAACT,IAAI;EAC5B;EACA;AACJ;AACA;AACA;AACA;EACI,OAAOgB,YAAYA,CAACC,IAAI,EAAEC,IAAI,EAAE;IAC5B,MAAMC,SAAS,GAAG5C,IAAI,CAAC6C,KAAK,CAAC7C,IAAI,CAACC,SAAS,CAACyC,IAAI,CAAC,CAAC;IAClD;IACA,KAAK,IAAII,IAAI,IAAIH,IAAI,EAAE;MACnB;MACA,IAAIrF,MAAM,CAACyF,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACN,IAAI,CAACG,IAAI,CAAC,CAAC,KAAK,iBAAiB,EAAE;QAClEF,SAAS,CAACE,IAAI,CAAC,GAAG9E,KAAK,CAACyE,YAAY,CAACG,SAAS,CAACE,IAAI,CAAC,EAAEH,IAAI,CAACG,IAAI,CAAC,CAAC;MACrE,CAAC,MACI;QACDF,SAAS,CAACE,IAAI,CAAC,GAAGH,IAAI,CAACG,IAAI,CAAC;MAChC;IACJ;IACA,OAAOF,SAAS;EACpB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,OAAOM,YAAYA,CAACC,CAAC,EAAEC,CAAC,EAAE;IACtB,IAAI,OAAOC,QAAQ,KAAK,WAAW,EAAE;MACjC,IAAIC,CAAC,GAAGD,QAAQ,CAACE,oBAAoB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;MAChD,IAAIC,CAAC,GAAGH,QAAQ,CAACI,aAAa,CAAC,QAAQ,CAAC;MACxCD,CAAC,CAACE,KAAK,GAAG,IAAI;MACdF,CAAC,CAACG,GAAG,GAAGR,CAAC;MACTK,CAAC,CAACtD,MAAM,GAAGsD,CAAC,CAACI,kBAAkB,GAAG,MAAM;QACpC,IAAI,CAACJ,CAAC,CAACK,UAAU,IAAI,iBAAiB,CAACC,IAAI,CAACN,CAAC,CAACK,UAAU,CAAC,EAAE;UACvDL,CAAC,CAACtD,MAAM,GAAGsD,CAAC,CAACI,kBAAkB,GAAG,IAAI;UACtCJ,CAAC,GAAG,IAAI;UACR,IAAIJ,CAAC,EAAE;YACHA,CAAC,CAAC,CAAC;UACP;QACJ;MACJ,CAAC;MACDE,CAAC,CAACS,YAAY,CAACP,CAAC,EAAEF,CAAC,CAACU,UAAU,CAAC;IACnC;EACJ;EACA,OAAOC,YAAYA,CAAA,EAAG;IAClB,OAAOvG,MAAM,CAACgD,OAAO,CAACwD,EAAE,CAAC,CAAC;EAC9B;EACA;AACJ;AACA;AACA;EACI,OAAOC,YAAYA,CAACC,KAAK,EAAE;IACvB,OAAO,OAAOA,KAAK,KAAK,QAAQ,GAAG,yBAAyB,CAACN,IAAI,CAACM,KAAK,CAAC,GAAG,KAAK;EACpF;EACA;AACJ;AACA;AACA;EACI,OAAOC,cAAcA,CAAA,EAAG;IACpB,OAAO,kCAAkC;EAC7C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,OAAOC,gBAAgBA,CAACC,IAAI,EAAEC,KAAK,EAAE;IACjC,IAAID,IAAI,EAAE;MACN;MACA,MAAME,GAAG,GAAGF,IAAI,CAACG,IAAI,CAAED,GAAG,IAAKA,GAAG,CAACE,MAAM,KAAKH,KAAK,CAACI,IAAI,CAACD,MAAM,CAAC;MAChE,IAAI,CAACF,GAAG,EAAE;QACNF,IAAI,CAACM,IAAI,CAAC;UACNF,MAAM,EAAEH,KAAK,CAACI,IAAI,CAACD,MAAM;UACzBxE,MAAM,EAAEqE,KAAK,CAACI,IAAI,CAACzE;QACvB,CAAC,CAAC;MACN,CAAC,MACI,IAAIsE,GAAG,CAACtE,MAAM,KAAKqE,KAAK,CAACI,IAAI,CAACzE,MAAM,EAAE;QACvC;QACA;QACA,IAAI2E,KAAK,GAAGP,IAAI,CAACQ,OAAO,CAACN,GAAG,CAAC;QAC7BF,IAAI,CAACS,IAAI,CAACP,GAAG,CAACtE,MAAM,GAAGqE,KAAK,CAACI,IAAI,CAACzE,MAAM,EAAE2E,KAAK,EAAEA,KAAK,EAAE,CAAC;MAC7D;IACJ,CAAC,MACI;MACDP,IAAI,GAAG,CAAC;QACAI,MAAM,EAAEH,KAAK,CAACI,IAAI,CAACD,MAAM;QACzBxE,MAAM,EAAEqE,KAAK,CAACI,IAAI,CAACzE;MACvB,CAAC,CAAC;IACV;IACA,OAAOoE,IAAI;EACf;EACA;AACJ;AACA;AACA;EACI,OAAOU,YAAYA,CAACT,KAAK,EAAE;IACvB,MAAM;MAAE9F,OAAO;MAAEwG;IAAM,CAAC,GAAGV,KAAK,CAACI,IAAI;IACrC;IACA;IACA,IAAIJ,KAAK,CAACjF,IAAI,KAAK,cAAc,EAC7B,OAAO,IAAI;IACf;IACA;IACA;IACA,IAAIb,OAAO,KAAMwG,KAAK,IAAIA,KAAK,CAACC,cAAc,IAAID,KAAK,CAACC,cAAc,CAACC,OAAO,IACzEF,KAAK,IAAIA,KAAK,CAACG,KAAK,IAAIH,KAAK,CAACG,KAAK,CAACD,OAAQ,IAAI1G,OAAO,CAAC4G,WAAW,CAAC,EAAE;MACvE,OAAO,IAAI;IACf;IACA,OAAO,KAAK;EAChB;EACA;AACJ;AACA;AACA;EACI,aAAaC,WAAWA,CAACnG,GAAG,EAAED,KAAK,EAAE;IACjC,MAAM;MAAEG;IAAS,CAAC,GAAG,MAAMtB,KAAK,CAACc,cAAc,CAAC;MAC5CS,IAAI,EAAE,KAAK;MACXH,GAAG;MACHU,YAAY,EAAE,aAAa;MAC3BX;IACJ,CAAC,CAAC;IACF,MAAMqG,aAAa,GAAG,IAAIC,UAAU,CAACnG,QAAQ,CAAC;IAC9C;IACA;IACA;IACA;IACA;IACA,IAAIoG,GAAG,GAAG,EAAE;IACZ,MAAMC,KAAK,GAAG,CAAC,GAAG,IAAI;IACtB,IAAIC,CAAC;IACL,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,aAAa,CAAClD,MAAM,GAAGqD,KAAK,EAAEC,CAAC,EAAE,EAAE;MAC/CF,GAAG,IAAIG,MAAM,CAACC,YAAY,CAACC,KAAK,CAAC,IAAI,EAAEP,aAAa,CAACQ,QAAQ,CAACJ,CAAC,GAAGD,KAAK,EAAE,CAACC,CAAC,GAAG,CAAC,IAAID,KAAK,CAAC,CAAC;IAC9F;IACAD,GAAG,IAAIG,MAAM,CAACC,YAAY,CAACC,KAAK,CAAC,IAAI,EAAEP,aAAa,CAACQ,QAAQ,CAACJ,CAAC,GAAGD,KAAK,CAAC,CAAC;IACzE,OAAO,yBAAyB,GAAGM,IAAI,CAACP,GAAG,CAAC;EAChD;EACA;AACJ;AACA;AACA;EACI,aAAaQ,sBAAsBA,CAAC9G,GAAG,EAAE;IACrC,MAAM+G,oBAAoB,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;IACvC,IAAI;MACA,MAAMrI,KAAK,CAACc,cAAc,CAAC;QACvBS,IAAI,EAAE,KAAK;QACXH;MACJ,CAAC,CAAC;MACF,MAAMkH,cAAc,GAAGF,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGF,oBAAoB;MACxD,OAAO;QAAE/G,GAAG;QAAEmH,UAAU,EAAE,IAAI;QAAED;MAAe,CAAC;IACpD,CAAC,CACD,OAAOjG,KAAK,EAAE;MACV,OAAO;QAAEjB,GAAG;QAAEmH,UAAU,EAAE,KAAK;QAAElG;MAAM,CAAC;IAC5C;EACJ;EACA;AACJ;AACA;AACA;EACI,OAAOmG,oBAAoBA,CAACC,MAAM,EAAEC,IAAI,EAAEC,MAAM,EAAE;IAC9C,OAAO,IAAI3H,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACpC,MAAM0H,gBAAgB,GAAGtJ,MAAM,CAACuJ,MAAM,CAAC;QAAEH;MAAK,CAAC,EAAEC,MAAM,CAAC;MACxD,MAAMR,oBAAoB,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;MACvC,MAAMS,UAAU,GAAGlJ,kBAAkB,CAAC8C,OAAO,CAACqG,OAAO,CAACN,MAAM,EAAEG,gBAAgB,CAAC;MAC/E,MAAMI,OAAO,GAAGC,UAAU,CAAC,MAAMhI,OAAO,CAAC;QAAEG,GAAG,EAAEqH,MAAM;QAAEF,UAAU,EAAE;MAAM,CAAC,CAAC,EAAExI,uBAAuB,CAAC;MACtG+I,UAAU,CAACI,EAAE,CAAC,SAAS,EAAE,MAAM;QAC3B,MAAMZ,cAAc,GAAGF,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGF,oBAAoB;QACxDW,UAAU,CAACK,UAAU,CAAC,CAAC;QACvBC,YAAY,CAACJ,OAAO,CAAC;QACrB/H,OAAO,CAAC;UAAEG,GAAG,EAAEqH,MAAM;UAAEF,UAAU,EAAE,IAAI;UAAED;QAAe,CAAC,CAAC;MAC9D,CAAC,CAAC;MACFQ,UAAU,CAACI,EAAE,CAAC,OAAO,EAAG7G,KAAK,IAAK;QAC9ByG,UAAU,CAACK,UAAU,CAAC,CAAC;QACvBC,YAAY,CAACJ,OAAO,CAAC;QACrB/H,OAAO,CAAC;UAAEG,GAAG,EAAEqH,MAAM;UAAEF,UAAU,EAAE,KAAK;UAAElG;QAAM,CAAC,CAAC;MACtD,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;EACI,aAAagH,kBAAkBA,CAAClI,KAAK,EAAEmI,aAAa,EAAEC,UAAU,EAAE;IAC9D,IAAI;MACA,MAAM;QAAEjI;MAAS,CAAC,GAAG,MAAMtB,KAAK,CAACc,cAAc,CAAC;QAC5CS,IAAI,EAAE,KAAK;QACXH,GAAG,EAAG,GAAEkI,aAAc,yBAAwBC,UAAW,EAAC;QAC1DpI;MACJ,CAAC,CAAC;MACF,MAAMqI,OAAO,GAAGlI,QAAQ,CAACmI,GAAG,CAAEC,IAAI,IAAK1J,KAAK,CAAC2J,uBAAuB,CAACD,IAAI,CAACE,EAAE,EAAEF,IAAI,CAACG,IAAI,CAAC,CAAC;MACzF,OAAO,MAAM7I,OAAO,CAAC8I,GAAG,CAACN,OAAO,CAAC;IACrC,CAAC,CACD,OAAOnH,KAAK,EAAE;MACV,OAAO,EAAE;IACb;EACJ;EACA;AACJ;AACA;AACA;EACI,aAAasH,uBAAuBA,CAACC,EAAE,EAAEC,IAAI,EAAE;IAC3C,OAAO,IAAI7I,OAAO,CAAC,OAAOC,OAAO,EAAEC,MAAM,KAAK;MAC1C,MAAM6I,aAAa,GAAG;QAAEC,UAAU,EAAE,CAAC;UAAEC,IAAI,EAAG,QAAOL,EAAG,IAAGC,IAAK;QAAE,CAAC;MAAE,CAAC;MACtE,MAAMK,EAAE,GAAG,IAAIC,iBAAiB,CAACJ,aAAa,CAAC;MAC/C,MAAM5B,oBAAoB,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;MACvC,MAAM+B,KAAK,GAAG,MAAMF,EAAE,CAACG,WAAW,CAAC;QAAEC,mBAAmB,EAAE;MAAK,CAAC,CAAC;MACjEJ,EAAE,CAACK,mBAAmB,CAACH,KAAK,CAAC;MAC7B,MAAMpB,OAAO,GAAGC,UAAU,CAAC,MAAM;QAC7BiB,EAAE,CAACM,KAAK,CAAC,CAAC;QACVvJ,OAAO,CAAC;UAAE2I,EAAE;UAAErB,UAAU,EAAE;QAAM,CAAC,CAAC;MACtC,CAAC,EAAEzI,0BAA0B,CAAC;MAC9BoK,EAAE,CAACO,cAAc,GAAG,CAAC;QAAEC;MAAU,CAAC,KAAK;QACnC,IAAIC,EAAE;QACN,IAAI,CAAC,CAACA,EAAE,GAAGD,SAAS,MAAM,IAAI,IAAIC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACpJ,IAAI,MAAM,OAAO,EAAE;UAC7E,MAAM+G,cAAc,GAAGF,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGF,oBAAoB;UACxD;UACAiB,YAAY,CAACJ,OAAO,CAAC;UACrBkB,EAAE,CAACM,KAAK,CAAC,CAAC;UACVvJ,OAAO,CAAC;YAAE2I,EAAE;YAAErB,UAAU,EAAE,IAAI;YAAED;UAAe,CAAC,CAAC;QACrD;MACJ,CAAC;MACD4B,EAAE,CAACU,mBAAmB,GAAIpE,KAAK,IAAK;QAChC,IAAIA,KAAK,CAACqE,SAAS,EAAE;UACjBX,EAAE,CAACM,KAAK,CAAC,CAAC;UACVpB,YAAY,CAACJ,OAAO,CAAC;UACrB/H,OAAO,CAAC;YAAE2I,EAAE;YAAErB,UAAU,EAAE,KAAK;YAAElG,KAAK,EAAEmE;UAAM,CAAC,CAAC;QACpD;MACJ,CAAC;IACL,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;EACI,OAAOsE,uBAAuBA,CAACC,aAAa,EAAEvE,KAAK,EAAE;IACjD,IAAImE,EAAE;IACN,IAAI,CAACI,aAAa,CAACC,GAAG,CAACxE,KAAK,CAACyE,GAAG,CAAC,EAC7B,OAAO,KAAK;IAChB,IAAI,EAAEzE,KAAK,CAACjF,IAAI,KAAK,gBAAgB,IAAIiF,KAAK,CAACjF,IAAI,KAAK,eAAe,CAAC,EACpE,OAAO,KAAK;IAChB,MAAM2J,EAAE,GAAG,CAACP,EAAE,GAAGI,aAAa,CAACrH,GAAG,CAAC8C,KAAK,CAACyE,GAAG,CAAC,MAAM,IAAI,IAAIN,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACO,EAAE;IACzF,IAAI,CAACA,EAAE,EACH,OAAO,KAAK;IAChB,IAAIA,EAAE,CAAC3K,IAAI,CAACC,IAAI,KAAKgG,KAAK,CAACI,IAAI,CAACrG,IAAI,CAACC,IAAI,IAAI0K,EAAE,CAACC,KAAK,KAAK,MAAM,EAC5D,OAAO,IAAI;IACf,OAAO,KAAK;EAChB;AACJ;AACA3L,OAAO,CAACkD,OAAO,GAAG1C,KAAK;AACvBoL,MAAM,CAAC5L,OAAO,GAAGQ,KAAK"},"metadata":{},"sourceType":"script","externalDependencies":[]}