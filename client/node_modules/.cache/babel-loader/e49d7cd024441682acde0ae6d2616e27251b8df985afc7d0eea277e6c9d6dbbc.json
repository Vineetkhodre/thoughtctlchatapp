{"ast":null,"code":"'use strict';\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Nexmo Client SDK\n *  Conversation Object Model\n *\n * Copyright (c) Nexmo Inc.\n */\nconst WildEmitter = require('wildemitter');\nconst loglevel_1 = require(\"loglevel\");\nconst nexmoClientError_1 = require(\"./nexmoClientError\");\nconst member_1 = __importDefault(require(\"./member\"));\nconst nxmEvent_1 = __importDefault(require(\"./events/nxmEvent\"));\nconst text_event_1 = __importDefault(require(\"./events/text_event\"));\nconst message_event_1 = __importDefault(require(\"./events/message_event\"));\nconst media_1 = __importDefault(require(\"./modules/media\"));\nconst conversation_events_1 = __importDefault(require(\"./handlers/conversation_events\"));\nconst utils_1 = __importDefault(require(\"./utils\"));\nconst page_config_1 = __importDefault(require(\"./pages/page_config\"));\nconst events_page_1 = __importDefault(require(\"./pages/events_page\"));\nconst members_page_1 = __importDefault(require(\"./pages/members_page\"));\nconst application_1 = __importDefault(require(\"./application\"));\n/**\n * A single conversation Object.\n * @class Conversation\n * @property {Member} me - my Member object that belongs to this conversation\n * @property {Application} application - the parent Application\n * @property {string} name - the name of the Conversation (unique)\n * @property {string} [display_name] - the display_name of the Conversation\n * @property {Map<string, Member>} [members] - the members of the Conversation keyed by a member's id\n * @property {Map<string, NXMEvent>} [events] - the events of the Conversation keyed by an event's id\n * @property {number} [sequence_number] - the last event id\n*/\nclass Conversation {\n  constructor(application, params) {\n    this.log = loglevel_1.getLogger(this.constructor.name);\n    this.application = application;\n    this.id = null;\n    this.name = null;\n    this.display_name = null;\n    this.timestamp = null;\n    this.members = new Map();\n    this.events = new Map();\n    this.sequence_number = 0;\n    this.pageConfig = new page_config_1.default(((this.application.session || {}).config || {}).events_page_config);\n    this.events_page_last = null;\n    this.members_page_last = null;\n    this.conversationEventHandler = new conversation_events_1.default(application, this);\n    this.media = new media_1.default(this);\n    /**\n     * A Member Object representing the current user.\n     * Only set if the user is or has been a member of the Conversation,\n     * otherwise the value will be `null`.\n     * @type Member\n    */\n    this.me = null; // We are not in the conversation ourselves by default\n    // Map the params (which includes the id)\n    this._updateObjectInstance(params);\n    WildEmitter.mixin(Conversation);\n  }\n  /** Update Conversation object params\n   * @property {object} params the params to update\n   * @private\n  */\n  _updateObjectInstance(params) {\n    for (let key in params) {\n      switch (key) {\n        case 'id':\n          this.id = params.id;\n          break;\n        case 'name':\n          this.name = params.name;\n          break;\n        case 'display_name':\n          this.display_name = params.display_name;\n          break;\n        case 'members':\n          // update the conversation javascript object\n          params.members.forEach(m => {\n            if (this.members.has(m.member_id)) {\n              this.members.get(m.member_id)._normalise(m);\n              if (m.user_id === this.application.me.id && m.state !== 'LEFT') {\n                this.me = this.members.get(m.member_id);\n                this.members.set(this.me.id, this.me);\n              }\n            } else {\n              const member = new member_1.default(this, m);\n              if (m.user_id === this.application.me.id && m.state !== 'LEFT') {\n                this.me = member;\n              }\n              this.members.set(member.id, member);\n            }\n          });\n          break;\n        case 'timestamp':\n          this.timestamp = params.timestamp;\n          break;\n        case 'sequence_number':\n          this.sequence_number = params.sequence_number;\n          break;\n        case 'member_id':\n          // filter needed params to create the object\n          // the conversation list gives us the member_id to prepare the member/this object\n          const object_params = {\n            id: params.member_id,\n            state: params.state,\n            user: this.application.me\n          };\n          // update the member object or create a new instance\n          if (this.members.has(params.member_id)) {\n            const member_object = this.members.get(params.member_id);\n            Object.assign(member_object, object_params);\n          } else {\n            const member = new member_1.default(this, object_params);\n            this.me = member;\n            this.members.set(member.id, member);\n          }\n          break;\n      }\n    }\n  }\n  /**\n   * Join the given User to this Conversation. Will typically be used this to join\n   * ourselves to a Conversation we create.\n   * Accept an invitation if our Member has state INVITED and no user_id / user_name is given\n   *\n   * @param {object} [params = this.application.me.id] The User to join (defaults to this)\n   * @param {string} params.user_name the user_name of the User to join\n   * @param {string} params.user_id the user_id of the User to join\n   * @returns {Promise<Member>}\n   *\n   * @example <caption>join a user to the Conversation</caption>\n   *\n   * conversation.join().then((member) => {\n   *  console.log(\"joined as member: \", member)\n   * }).catch((error) => {\n   *  console.error(\"error joining conversation \", error);\n   * });\n  */\n  async join(params) {\n    var _a, _b, _c, _d;\n    try {\n      let data = {\n        state: 'joined',\n        channel: {\n          type: 'app'\n        },\n        user: {\n          ...(!params && {\n            name: this.application.me.name,\n            id: this.application.me.id\n          }),\n          ...(params && params.user_name && {\n            name: params.user_name\n          }),\n          ...(params && params.user_id && {\n            id: params.user_id\n          })\n        }\n      };\n      if (((_b = (_a = this) === null || _a === void 0 ? void 0 : _a.me) === null || _b === void 0 ? void 0 : _b.id) && ((_d = (_c = this) === null || _c === void 0 ? void 0 : _c.me) === null || _d === void 0 ? void 0 : _d.state) !== 'LEFT') {\n        data[\"from\"] = this.me.id;\n      }\n      const response = await this.application.session.sendNetworkRequest({\n        type: 'POST',\n        path: `conversations/${this.id}/members`,\n        version: 'v0.3',\n        data\n      });\n      const member = new member_1.default(this, response);\n      if (response._embedded.user.id === this.application.me.id) {\n        this.me = member;\n        this.members.set(member.id, member);\n      }\n      // use case where between the time we got the conversation and the time we finished joining\n      // the conversation object changed.\n      this.application.getConversation(this.id, application_1.default.CONVERSATION_API_VERSION.v3);\n      return member;\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n   * Delete a conversation\n   * @returns {Promise}\n   * @example <caption>delete the Conversation</caption>\n   *\n   * conversation.del().then(() => {\n   *    console.log(\"conversation deleted\");\n   * }).catch((error) => {\n   *  console.error(\"error deleting conversation \", error);\n   * });\n  */\n  async del() {\n    try {\n      const response = await this.application.session.sendNetworkRequest({\n        type: 'DELETE',\n        path: `conversations/${this.id}`\n      });\n      this.application.conversations.delete(this.id);\n      return response;\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n   * Delete an NXMEvent (e.g. Text)\n   * @param {NXMEvent} event\n   * @returns {Promise}\n   * @example <caption>delete an Event</caption>\n   *\n   * conversation.deleteEvent(eventToBeDeleted).then(() => {\n   *  console.log(\"event was deleted\");\n   * }).catch((error) => {\n   *  console.error(\"error deleting the event \", error);\n   * });\n   *\n  */\n  deleteEvent(event) {\n    return event.del();\n  }\n  /**\n    * Invite the given user (id or name) to this conversation\n    * @param {Member} params\n    * @param {string} [params.id or user_name] - the id or the username of the User to invite\n    *\n    * @returns {Promise<Member>}\n    *\n    * @example <caption>invite a user to a Conversation</caption>\n    * const user_id = 'id of User to invite';\n    * const user_name = 'username of User to invite';\n    *\n    * conversation.invite({\n    *  id: user_id,\n    *  user_name: user_name\n    * }).then((member) => {\n    *  displayMessage(member.state + \" user: \" + user_id + \" \" + user_name);\n    * }).catch((error) => {\n    *  console.error(\"error inviting user \", error);\n    * });\n    *\n  */\n  async invite(params) {\n    var _a, _b, _c, _d;\n    if (!params || !params.id && !params.user_name) {\n      throw new nexmoClientError_1.NexmoClientError('error:invite:missing:params');\n    }\n    const data = {\n      state: 'invited',\n      user: {\n        ...(params.id && {\n          id: params.id\n        }),\n        ...(params.user_name && {\n          name: params.user_name\n        })\n      },\n      media: params.media,\n      channel: {\n        from: {\n          type: 'app'\n        },\n        to: {\n          type: 'app'\n        },\n        type: 'app'\n      }\n    };\n    if (((_b = (_a = this) === null || _a === void 0 ? void 0 : _a.me) === null || _b === void 0 ? void 0 : _b.id) && ((_d = (_c = this) === null || _c === void 0 ? void 0 : _c.me) === null || _d === void 0 ? void 0 : _d.state) !== 'LEFT') {\n      data[\"from\"] = this.me.id;\n    }\n    try {\n      const response = await this.application.session.sendNetworkRequest({\n        type: 'POST',\n        path: `conversations/${this.id}/members`,\n        version: 'v0.3',\n        data\n      });\n      const member = new member_1.default(this, response);\n      return member;\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n    * Invite the given user (id or name) to this conversation with media audio\n    * @param {Member} params\n    * @param {string} [params.id or user_name] - the id or the username of the User to invite\n    *\n    * @returns {Promise<Member>}\n    *\n    * @example <caption>invite a user to a conversation</caption>\n    * const user_id = 'id of User to invite';\n    * const user_name = 'username of User to invite';\n    *\n    * conversation.inviteWithAudio({\n    *  id: user_id,\n    *  user_name: user_name\n    * }).then((member) => {\n    *  displayMessage(member.state + \" user: \" + user_id + \" \" + user_name);\n    * }).catch((error) => {\n    *  console.error(\"error inviting user \", error);\n    * });\n    *\n  */\n  inviteWithAudio(params) {\n    if (!params || !params.id && !params.user_name) {\n      return Promise.reject(new nexmoClientError_1.NexmoClientError('error:invite:missing:params'));\n    }\n    params.media = {\n      audio_settings: {\n        enabled: true,\n        muted: false,\n        earmuffed: false\n      }\n    };\n    return this.invite(params);\n  }\n  /**\n   * Leave from the Conversation\n   * @param {object} [reason] the reason for leaving the conversation\n   * @param {string} [reason.reason_code] the code of the reason\n   * @param {string} [reason.reason_text] the description of the reason\n   * @returns {Promise}\n   * @example <caption>leave the Conversation</caption>\n   *\n   * conversation.leave({reason_code: \"mycode\", reason_text: \"my reason for leaving\"}).then(() => {\n   *  console.log(\"successfully left conversation\");\n   * }).catch((error) => {\n   *  console.error(\"error leaving conversation \", error);\n   * });\n   *\n  */\n  leave(reason) {\n    return this.me.kick(reason);\n  }\n  /**\n    * Send a text message to the conversation, which will be relayed to every other member of the conversation\n    * @param {string} text - the text message to be sent\n    *\n    * @returns {Promise<TextEvent>} - the text message that was sent\n    *\n    * @example <caption> sending a text </caption>\n    * conversation.sendText(\"Hi Vonage\").then((event) => {\n    *  console.log(\"message was sent\", event);\n    * }).catch((error)=>{\n    *  console.error(\"error sending the message \", error);\n    * });\n    *\n    * @deprecated since version 8.3.0\n    *\n  */\n  async sendText(text) {\n    try {\n      if (this.me === null) {\n        throw new nexmoClientError_1.NexmoClientError('error:self');\n      }\n      const msg = {\n        type: 'text',\n        cid: this.id,\n        from: this.me.id,\n        body: {\n          text\n        }\n      };\n      const {\n        id,\n        timestamp\n      } = await this.application.session.sendNetworkRequest({\n        type: 'POST',\n        path: `conversations/${this.id}/events`,\n        data: msg\n      });\n      msg.id = id;\n      msg.body.timestamp = timestamp;\n      return new text_event_1.default(this, msg);\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n    * Send a custom event to the Conversation\n    * @param {object} params - params of the custom event\n    * @param {string} params.type the name of the custom event. Must not exceed 100 char length and contain only alpha numerics and '-' and '_' characters.\n    * @param {object} params.body customizable key value pairs\n    *\n    * @returns {Promise<NXMEvent>} - the custom event that was sent\n    *\n    * @example <caption> sending a custom event </caption>\n    * conversation.sendCustomEvent({ type: \"my-event\", body: { mykey: \"my value\" }}).then((event) => {\n    *  console.log(\"custom event was sent\", event);\n    * }).catch((error)=>{\n    *  console.error(\"error sending the custom event\", error);\n    * });\n    *\n  */\n  async sendCustomEvent({\n    type,\n    body\n  }) {\n    try {\n      if (this.me === null) {\n        throw new nexmoClientError_1.NexmoClientError('error:self');\n      } else if (!type || typeof type !== 'string' || type.length < 1) {\n        throw new nexmoClientError_1.NexmoClientError('error:custom-event:invalid');\n      }\n      const data = {\n        type: `custom:${type}`,\n        cid: this.id,\n        from: this.me.id,\n        body\n      };\n      const {\n        id,\n        timestamp\n      } = await this.application.session.sendNetworkRequest({\n        type: 'POST',\n        path: `conversations/${this.id}/events`,\n        data\n      });\n      data.id = id;\n      data.timestamp = timestamp;\n      return new nxmEvent_1.default(this, data);\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n   * Uploads an Image to Media Service.\n   * implements xhr (https://xhr.spec.whatwg.org/) - this.imageRequest\n   *\n   * @param {File} file single input file (jpeg/jpg)\n   * @param {object} params - params of image sent\n   * @param {string} [params.quality_ratio = 100] a value between 0 and 100. 0 indicates 'maximum compression' and the lowest quality, 100 will result in the highest quality image\n   * @param {string} [params.medium_size_ratio = 50] a value between 1 and 100. 1 indicates the new image is 1% of original, 100 - same size as original\n   * @param {string} [params.thumbnail_size_ratio = 30] a value between 1 and 100. 1 indicates the new image is 1% of original, 100 - same size as original\n   *\n   * @returns {Promise<XMLHttpRequest>}\n   *\n   * @example <caption>uploading an image</caption>\n   * const params = {\n   *  quality_ratio : \"90\",\n   *  medium_size_ratio: \"40\",\n   *  thumbnail_size_ratio: \"20\"\n   * }\n   * conversation.uploadImage(fileInput.files[0], params).then((uploadImageRequest) => {\n   *  uploadImageRequest.onprogress = (e) => {\n   *    console.log(\"Image request progress: \", e);\n   *    console.log(\"Image progress: \" + e.loaded + \"/\" + e.total);\n   *  };\n   *  uploadImageRequest.onabort = (e) => {\n   *    console.log(\"Image request aborted: \", e);\n   *    console.log(\"Image: \" + e.type);\n   *  };\n   *  uploadImageRequest.onloadend = (e) => {\n   *    console.log(\"Image request successful: \", e);\n   *    console.log(\"Image: \" + e.type);\n   *  };\n   *  uploadImageRequest.onreadystatechange = () => {\n   *    if (uploadImageRequest.readyState === 4 && uploadImageRequest.status === 200) {\n   *      const representations = JSON.parse(uploadImageRequest.responseText);\n   *      console.log(\"Original image url: \", representations.original.url);\n   *      console.log(\"Medium image url: \", representations.medium.url);\n   *      console.log(\"Thumbnail image url: \", representations.thumbnail.url);\n   *    }\n   *  };\n   * }).catch((error) => {\n   *    console.error(\"error uploading the image \", error);\n   * });\n  */\n  async uploadImage(fileInput, params = {\n    quality_ratio: '100',\n    medium_size_ratio: '50',\n    thumbnail_size_ratio: '30'\n  }) {\n    const formData = new FormData();\n    formData.append('file', fileInput);\n    formData.append('quality_ratio', params.quality_ratio);\n    formData.append('medium_size_ratio', params.medium_size_ratio);\n    formData.append('thumbnail_size_ratio', params.thumbnail_size_ratio);\n    const imageRequest = await utils_1.default.networkRequest({\n      type: 'POST',\n      url: this.application.session.config.ips_url,\n      data: formData,\n      token: this.application.session.config.token\n    });\n    imageRequest.upload.addEventListener('progress', evt => {\n      if (evt.lengthComputable) {\n        this.log.debug('uploading image ' + evt.loaded + '/' + evt.total);\n      }\n    }, false);\n    imageRequest.onreadystatechange = () => {\n      if (imageRequest.status !== 200) {\n        this.log.error(imageRequest);\n      }\n    };\n    return imageRequest;\n  }\n  /**\n   * Send an Image message to the conversation, which will be relayed to every other member of the conversation.\n   * implements xhr (https://xhr.spec.whatwg.org/) - this.imageRequest\n   *\n   * @param {File} file single input file (jpeg/jpg)\n   * @param {object} params - params of image sent\n   * @param {string} [params.quality_ratio = 100] a value between 0 and 100. 0 indicates 'maximum compression' and the lowest quality, 100 will result in the highest quality image\n   * @param {string} [params.medium_size_ratio = 50] a value between 1 and 100. 1 indicates the new image is 1% of original, 100 - same size as original\n   * @param {string} [params.thumbnail_size_ratio = 30] a value between 1 and 100. 1 indicates the new image is 1% of original, 100 - same size as original\n   *\n   * @returns {Promise<XMLHttpRequest>}\n   *\n   * @example <caption>sending an image</caption>\n   * const params = {\n   *  quality_ratio : \"90\",\n   *  medium_size_ratio: \"40\",\n   *  thumbnail_size_ratio: \"20\"\n   * }\n   * conversation.sendImage(fileInput.files[0], params).then((imageRequest) => {\n   *  imageRequest.onprogress = (e) => {\n   *    console.log(\"Image request progress: \", e);\n   *    console.log(\"Image progress: \" + e.loaded + \"/\" + e.total);\n   *  };\n   *  imageRequest.onabort = (e) => {\n   *    console.log(\"Image request aborted: \", e);\n   *    console.log(\"Image: \" + e.type);\n   *  };\n   *  imageRequest.onloadend = (e) => {\n   *    console.log(\"Image request successful: \", e);\n   *    console.log(\"Image: \" + e.type);\n   *  };\n   * }).catch((error) => {\n   *  console.error(\"error sending the image \", error);\n   * });\n   *\n   * @deprecated since version 8.3.0\n  */\n  async sendImage(fileInput, params = {\n    quality_ratio: '100',\n    medium_size_ratio: '50',\n    thumbnail_size_ratio: '30'\n  }) {\n    const imageRequest = await this.uploadImage(fileInput, params);\n    imageRequest.onreadystatechange = () => {\n      if (imageRequest.readyState === 4 && imageRequest.status === 200) {\n        try {\n          this.application.session.sendNetworkRequest({\n            type: 'POST',\n            path: `conversations/${this.id}/events`,\n            data: {\n              type: 'image',\n              from: this.me.id,\n              body: {\n                representations: JSON.parse(imageRequest.responseText)\n              }\n            }\n          });\n          this.log.info(imageRequest);\n        } catch (error) {\n          this.log.error(new nexmoClientError_1.NexmoApiError(error));\n        }\n      }\n    };\n    return imageRequest;\n  }\n  /**\n   * Cancel uploading or sending an Image message to the conversation.\n   *\n   * @param {XMLHttpRequest} imageRequest\n   *\n   * @returns void\n   *\n   * @example <caption>cancel sending an image</caption>\n   * conversation.sendImage(fileInput.files[0]).then((imageRequest) => {\n   *    conversation.abortSendImage(imageRequest);\n  * }).catch((error) => {\n  *    console.error(\"error sending the image \", error);\n   * });\n  *\n  * @example <caption>cancel uploading an image</caption>\n   * conversation.uploadImage(fileInput.files[0]).then((imageRequest) => {\n   *    conversation.abortSendImage(imageRequest);\n  * }).catch((error) => {\n  *    console.error(\"error uploading the image \", error);\n   * });\n  */\n  abortSendImage(imageRequest) {\n    if (imageRequest instanceof XMLHttpRequest) {\n      return imageRequest.abort();\n    } else {\n      return new nexmoClientError_1.NexmoClientError('error:invalid:param:type');\n    }\n  }\n  /**\n    * Send a message event to the conversation, which will be relayed to every other member of the conversation\n    *\n    * @param {object} params the content of the message you want sent\n    * @param {string} params.message_type the type of the message. It should be one of 'text', 'image', 'audio', 'video', 'file'\n    * @param {string} [params.text] the text content when message type is 'text\n    * @param {object} [params.image]\n    * @param {string} params.image.url the image url when message type is 'image'\n    * @param {object} [params.audio]\n    * @param {string} params.audio.url the audio url when message type is 'audio'\n    * @param {object} [params.video]\n    * @param {string} params.video.url the video url when message type is 'video'\n    * @param {object} [params.file]\n    * @param {string} params.file.url the file url when message type is 'file'\n    *\n    * @returns {Promise<MessageEvent>} - the message that was sent\n    *\n    * @example <caption> sending a message </caption>\n    * conversation.sendMessage({ \"message_type\": \"text\", \"text\": \"Hi Vonage!\" }).then((event) => {\n    *  console.log(\"message was sent\", event);\n    * }).catch((error)=>{\n    *  console.error(\"error sending the message \", error);\n    * });\n    *\n  */\n  async sendMessage(params) {\n    var _a;\n    if (this.me === null) {\n      throw new nexmoClientError_1.NexmoClientError('error:self');\n    } else if (!((_a = params) === null || _a === void 0 ? void 0 : _a.message_type)) {\n      throw new nexmoClientError_1.NexmoClientError('error:message-event:invalid');\n    }\n    try {\n      const msg = {\n        type: 'message',\n        cid: this.id,\n        from: this.me.id,\n        body: {\n          ...params\n        }\n      };\n      const {\n        id,\n        timestamp\n      } = await this.application.session.sendNetworkRequest({\n        type: 'POST',\n        path: `conversations/${this.id}/events`,\n        data: msg\n      });\n      msg.id = id;\n      msg.body.timestamp = timestamp;\n      return new message_event_1.default(this, msg);\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  async _typing(state) {\n    const params = {\n      activity: state === 'on' ? 1 : 0\n    };\n    const data = {\n      type: 'text:typing:' + state,\n      cid: this.id,\n      from: this.me.id,\n      body: params\n    };\n    try {\n      await this.application.session.sendNetworkRequest({\n        type: 'POST',\n        path: `conversations/${this.id}/events`,\n        data\n      });\n      return `text:typing:${state}:success`;\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n   * Send start typing indication\n   *\n   * @returns {Promise} - resolves the promise on successful sent\n   *\n   * @example <caption>send start typing event when key is pressed</caption>\n   * messageTextarea.addEventListener('keypress', (event) => {\n   *    conversation.startTyping();\n   * });\n  */\n  startTyping() {\n    return this._typing('on');\n  }\n  /**\n   * Send stop typing indication\n   *\n   * @returns {Promise} - resolves the promise on successful sent\n   *\n   * @example <caption>send stop typing event when a key has not been pressed for half a second</caption>\n   * let timeout = null;\n   * messageTextarea.addEventListener('keyup', (event) => {\n   *    clearTimeout(timeout);\n   *    timeout = setTimeout(() => {\n   *      conversation.stopTyping();\n   *    }, 500);\n   * });\n  */\n  stopTyping() {\n    return this._typing('off');\n  }\n  /**\n    * Query the service to get a list of events in this conversation.\n    *\n    * @param {object} params configure defaults for paginated events query\n    * @param {string} params.order 'asc' or 'desc' ordering of resources based on creation time\n    * @param {number} params.page_size the number of resources returned in a single request list\n    * @param {string} [params.cursor] string to access the starting point of a dataset\n    * @param {string} [params.event_type] the type of event used to filter event requests. Supports wildcard options with :* eg. 'members:*'\n    *\n    * @returns {Promise<EventsPage<Map<Events>>>} - Populate Conversations.events.\n    * @example <caption>Get Events</caption>\n    * conversation.getEvents({ event_type: 'member:*' }).then((events_page) => {\n    *   events_page.items.forEach(event => {\n    *     render(event)\n    *   })\n    * }).catch((error) => {\n    *  console.error(\"error getting the events \", error);\n    * });\n  */\n  async getEvents(params = {}) {\n    const url = `${this.application.session.config.nexmo_api_url}/beta2/conversations/${this.id}/events`;\n    // Create pageConfig if given params otherwise use default\n    let pageConfig = Object.keys(params).length === 0 ? this.pageConfig : new page_config_1.default(params);\n    try {\n      const response = await utils_1.default.paginationRequest(url, pageConfig, this.application.session.config.token);\n      response.application = this.application;\n      response.conversation = this;\n      const events_page = new events_page_1.default(response);\n      this.events_page_last = events_page;\n      return events_page;\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n    * Query the service to get a list of members in this conversation.\n    *\n    * @param {object} params configure defaults for paginated events query\n    * @param {string} params.order 'asc' or 'desc' ordering of resources based on creation time\n    * @param {number} params.page_size the number of resources returned in a single request list\n    * @param {string} [params.cursor] string to access the starting point of a dataset\n    *\n    * @returns {Promise<MembersPage<Map<Member>>>}\n    * @example <caption>Get Members</caption>\n    * const params = {\n    *   order: \"desc\",\n    *   page_size: 100\n    * }\n    * conversation.getMembers(params).then((members_page) => {\n    *   members_page.items.forEach(member => {\n    *     render(member)\n    *   })\n    * }).catch((error) => {\n    *  console.error(\"error getting the members \", error);\n    * });\n  */\n  async getMembers(params = {}) {\n    const url = `${this.application.session.config.nexmo_api_url}/beta2/conversations/${this.id}/members`;\n    // Create pageConfig if given params otherwise use default\n    let pageConfig = Object.keys(params).length === 0 ? this.pageConfig : new page_config_1.default(params);\n    try {\n      const response = await utils_1.default.paginationRequest(url, pageConfig, this.application.session.config.token);\n      response.application = this.application;\n      response.conversation = this;\n      const members_page = new members_page_1.default(response);\n      this.members_page_last = members_page;\n      return members_page;\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n    * Query the service to get my member in this conversation.\n    *\n    * @returns {Promise<Member>}\n    * @example <caption>Get My Member</caption>\n    * conversation.getMyMember().then((member) => {\n    *   render(member)\n    * }).catch((error) => {\n    *  console.error(\"error getting my member\", error);\n    * });\n  */\n  async getMyMember() {\n    try {\n      const response = await this.application.session.sendNetworkRequest({\n        type: 'GET',\n        path: `conversations/${this.id}/members/me`,\n        version: 'v0.3'\n      });\n      const member = new member_1.default(this, response);\n      return member;\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n    * Query the service to get a member in this conversation.\n    *\n    * @param {string} member_id the id of the member to return\n    *\n    * @returns {Promise<Member>}\n    * @example <caption>Get Member</caption>\n    * conversation.getMember(\"MEM-id\").then((member) => {\n    *   render(member)\n    * }).catch((error) => {\n    *  console.error(\"error getting member\", error);\n    * });\n  */\n  async getMember(member_id) {\n    try {\n      const response = await this.application.session.sendNetworkRequest({\n        type: 'GET',\n        path: `conversations/${this.id}/members/${member_id}`,\n        version: 'v0.3'\n      });\n      const member = new member_1.default(this, response);\n      return member;\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n   * Handle and event from the cloud.\n   * using conversationEventHandler\n   * @param {object} event\n   * @private\n  */\n  _handleEvent(event) {\n    var _a, _b, _c, _d;\n    if (event.type.startsWith('rtc')) {\n      // keep the rtc events going to the application layer, we use them in media module\n      this.emit(event.type, event);\n      return Promise.resolve(event);\n    }\n    this.sequence_number++;\n    // make sure the event_id is not a string\n    if (event.body && event.body.event_id && typeof event.body.event_id === 'string') {\n      event.body.event_id = parseInt(event.body.event_id);\n    }\n    let memberInfo = {\n      memberId: event.from\n    };\n    if ((_b = (_a = event) === null || _a === void 0 ? void 0 : _a.body) === null || _b === void 0 ? void 0 : _b.user) {\n      const {\n        id,\n        name,\n        display_name,\n        image_url,\n        custom_data\n      } = event.body.user;\n      memberInfo = {\n        ...memberInfo,\n        ...{\n          ...(id && {\n            userId: id\n          }),\n          ...(name && {\n            userName: name\n          }),\n          ...(display_name && {\n            displayName: display_name\n          }),\n          ...(image_url && {\n            imageUrl: image_url\n          }),\n          ...(custom_data && {\n            customData: custom_data\n          })\n        }\n      };\n    } else if ((_d = (_c = event) === null || _c === void 0 ? void 0 : _c._embedded) === null || _d === void 0 ? void 0 : _d.from_user) {\n      const {\n        id,\n        name,\n        display_name,\n        image_url,\n        custom_data\n      } = event._embedded.from_user;\n      memberInfo = {\n        ...memberInfo,\n        ...{\n          ...(id && {\n            userId: id\n          }),\n          ...(name && {\n            userName: name\n          }),\n          ...(display_name && {\n            displayName: display_name\n          }),\n          ...(image_url && {\n            imageUrl: image_url\n          }),\n          ...(custom_data && {\n            customData: custom_data\n          })\n        }\n      };\n    }\n    let constructed_event = this.conversationEventHandler.handleEvent(event);\n    // Unless they are typing events, add the event to the conversation.events map\n    if (!['text:typing:on', 'text:typing:off'].includes(event.type)) {\n      this.events.set(constructed_event.id, constructed_event);\n    }\n    // For custom events remove the custom: prefix before emitting event\n    if (event.type.startsWith('custom:')) {\n      this.emit(constructed_event.type, memberInfo, constructed_event);\n      return Promise.resolve(event);\n    }\n    this.emit(event.type, memberInfo, constructed_event);\n    return Promise.resolve(event);\n  }\n}\nexports.default = Conversation;\nmodule.exports = Conversation;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","WildEmitter","require","loglevel_1","nexmoClientError_1","member_1","nxmEvent_1","text_event_1","message_event_1","media_1","conversation_events_1","utils_1","page_config_1","events_page_1","members_page_1","application_1","Conversation","constructor","application","params","log","getLogger","name","id","display_name","timestamp","members","Map","events","sequence_number","pageConfig","default","session","config","events_page_config","events_page_last","members_page_last","conversationEventHandler","media","me","_updateObjectInstance","mixin","key","forEach","m","has","member_id","get","_normalise","user_id","state","set","member","object_params","user","member_object","assign","join","_a","_b","_c","_d","data","channel","type","user_name","response","sendNetworkRequest","path","version","_embedded","getConversation","CONVERSATION_API_VERSION","v3","error","NexmoApiError","del","conversations","delete","deleteEvent","event","invite","NexmoClientError","from","to","inviteWithAudio","Promise","reject","audio_settings","enabled","muted","earmuffed","leave","reason","kick","sendText","text","msg","cid","body","sendCustomEvent","length","uploadImage","fileInput","quality_ratio","medium_size_ratio","thumbnail_size_ratio","formData","FormData","append","imageRequest","networkRequest","url","ips_url","token","upload","addEventListener","evt","lengthComputable","debug","loaded","total","onreadystatechange","status","sendImage","readyState","representations","JSON","parse","responseText","info","abortSendImage","XMLHttpRequest","abort","sendMessage","message_type","_typing","activity","startTyping","stopTyping","getEvents","nexmo_api_url","keys","paginationRequest","conversation","events_page","getMembers","members_page","getMyMember","getMember","_handleEvent","startsWith","emit","resolve","event_id","parseInt","memberInfo","memberId","image_url","custom_data","userId","userName","displayName","imageUrl","customData","from_user","constructed_event","handleEvent","includes","module"],"sources":["/Users/vineetkhodre/react-workspace/thoughtctlchatapp/client/node_modules/nexmo-client/dist/conversation.js"],"sourcesContent":["'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  Conversation Object Model\n *\n * Copyright (c) Nexmo Inc.\n */\nconst WildEmitter = require('wildemitter');\nconst loglevel_1 = require(\"loglevel\");\nconst nexmoClientError_1 = require(\"./nexmoClientError\");\nconst member_1 = __importDefault(require(\"./member\"));\nconst nxmEvent_1 = __importDefault(require(\"./events/nxmEvent\"));\nconst text_event_1 = __importDefault(require(\"./events/text_event\"));\nconst message_event_1 = __importDefault(require(\"./events/message_event\"));\nconst media_1 = __importDefault(require(\"./modules/media\"));\nconst conversation_events_1 = __importDefault(require(\"./handlers/conversation_events\"));\nconst utils_1 = __importDefault(require(\"./utils\"));\nconst page_config_1 = __importDefault(require(\"./pages/page_config\"));\nconst events_page_1 = __importDefault(require(\"./pages/events_page\"));\nconst members_page_1 = __importDefault(require(\"./pages/members_page\"));\nconst application_1 = __importDefault(require(\"./application\"));\n/**\n * A single conversation Object.\n * @class Conversation\n * @property {Member} me - my Member object that belongs to this conversation\n * @property {Application} application - the parent Application\n * @property {string} name - the name of the Conversation (unique)\n * @property {string} [display_name] - the display_name of the Conversation\n * @property {Map<string, Member>} [members] - the members of the Conversation keyed by a member's id\n * @property {Map<string, NXMEvent>} [events] - the events of the Conversation keyed by an event's id\n * @property {number} [sequence_number] - the last event id\n*/\nclass Conversation {\n    constructor(application, params) {\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        this.application = application;\n        this.id = null;\n        this.name = null;\n        this.display_name = null;\n        this.timestamp = null;\n        this.members = new Map();\n        this.events = new Map();\n        this.sequence_number = 0;\n        this.pageConfig = new page_config_1.default(((this.application.session || {}).config || {}).events_page_config);\n        this.events_page_last = null;\n        this.members_page_last = null;\n        this.conversationEventHandler = new conversation_events_1.default(application, this);\n        this.media = new media_1.default(this);\n        /**\n         * A Member Object representing the current user.\n         * Only set if the user is or has been a member of the Conversation,\n         * otherwise the value will be `null`.\n         * @type Member\n        */\n        this.me = null; // We are not in the conversation ourselves by default\n        // Map the params (which includes the id)\n        this._updateObjectInstance(params);\n        WildEmitter.mixin(Conversation);\n    }\n    /** Update Conversation object params\n     * @property {object} params the params to update\n     * @private\n    */\n    _updateObjectInstance(params) {\n        for (let key in params) {\n            switch (key) {\n                case 'id':\n                    this.id = params.id;\n                    break;\n                case 'name':\n                    this.name = params.name;\n                    break;\n                case 'display_name':\n                    this.display_name = params.display_name;\n                    break;\n                case 'members':\n                    // update the conversation javascript object\n                    params.members.forEach((m) => {\n                        if (this.members.has(m.member_id)) {\n                            this.members.get(m.member_id)._normalise(m);\n                            if (m.user_id === this.application.me.id && m.state !== 'LEFT') {\n                                this.me = this.members.get(m.member_id);\n                                this.members.set(this.me.id, this.me);\n                            }\n                        }\n                        else {\n                            const member = new member_1.default(this, m);\n                            if (m.user_id === this.application.me.id && m.state !== 'LEFT') {\n                                this.me = member;\n                            }\n                            this.members.set(member.id, member);\n                        }\n                    });\n                    break;\n                case 'timestamp':\n                    this.timestamp = params.timestamp;\n                    break;\n                case 'sequence_number':\n                    this.sequence_number = params.sequence_number;\n                    break;\n                case 'member_id':\n                    // filter needed params to create the object\n                    // the conversation list gives us the member_id to prepare the member/this object\n                    const object_params = {\n                        id: params.member_id,\n                        state: params.state,\n                        user: this.application.me\n                    };\n                    // update the member object or create a new instance\n                    if (this.members.has(params.member_id)) {\n                        const member_object = this.members.get(params.member_id);\n                        Object.assign(member_object, object_params);\n                    }\n                    else {\n                        const member = new member_1.default(this, object_params);\n                        this.me = member;\n                        this.members.set(member.id, member);\n                    }\n                    break;\n            }\n        }\n    }\n    /**\n     * Join the given User to this Conversation. Will typically be used this to join\n     * ourselves to a Conversation we create.\n     * Accept an invitation if our Member has state INVITED and no user_id / user_name is given\n     *\n     * @param {object} [params = this.application.me.id] The User to join (defaults to this)\n     * @param {string} params.user_name the user_name of the User to join\n     * @param {string} params.user_id the user_id of the User to join\n     * @returns {Promise<Member>}\n     *\n     * @example <caption>join a user to the Conversation</caption>\n     *\n     * conversation.join().then((member) => {\n     *  console.log(\"joined as member: \", member)\n     * }).catch((error) => {\n     *  console.error(\"error joining conversation \", error);\n     * });\n    */\n    async join(params) {\n        var _a, _b, _c, _d;\n        try {\n            let data = {\n                state: 'joined',\n                channel: {\n                    type: 'app'\n                },\n                user: {\n                    ...(!params && { name: this.application.me.name, id: this.application.me.id }),\n                    ...(params && params.user_name && { name: params.user_name }),\n                    ...(params && params.user_id && { id: params.user_id }),\n                },\n            };\n            if (((_b = (_a = this) === null || _a === void 0 ? void 0 : _a.me) === null || _b === void 0 ? void 0 : _b.id) && ((_d = (_c = this) === null || _c === void 0 ? void 0 : _c.me) === null || _d === void 0 ? void 0 : _d.state) !== 'LEFT') {\n                data[\"from\"] = this.me.id;\n            }\n            const response = await this.application.session.sendNetworkRequest({\n                type: 'POST',\n                path: `conversations/${this.id}/members`,\n                version: 'v0.3',\n                data\n            });\n            const member = new member_1.default(this, response);\n            if (response._embedded.user.id === this.application.me.id) {\n                this.me = member;\n                this.members.set(member.id, member);\n            }\n            // use case where between the time we got the conversation and the time we finished joining\n            // the conversation object changed.\n            this.application.getConversation(this.id, application_1.default.CONVERSATION_API_VERSION.v3);\n            return member;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Delete a conversation\n     * @returns {Promise}\n     * @example <caption>delete the Conversation</caption>\n     *\n     * conversation.del().then(() => {\n     *    console.log(\"conversation deleted\");\n     * }).catch((error) => {\n     *  console.error(\"error deleting conversation \", error);\n     * });\n    */\n    async del() {\n        try {\n            const response = await this.application.session.sendNetworkRequest({\n                type: 'DELETE',\n                path: `conversations/${this.id}`\n            });\n            this.application.conversations.delete(this.id);\n            return response;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Delete an NXMEvent (e.g. Text)\n     * @param {NXMEvent} event\n     * @returns {Promise}\n     * @example <caption>delete an Event</caption>\n     *\n     * conversation.deleteEvent(eventToBeDeleted).then(() => {\n     *  console.log(\"event was deleted\");\n     * }).catch((error) => {\n     *  console.error(\"error deleting the event \", error);\n     * });\n     *\n    */\n    deleteEvent(event) {\n        return event.del();\n    }\n    /**\n      * Invite the given user (id or name) to this conversation\n      * @param {Member} params\n      * @param {string} [params.id or user_name] - the id or the username of the User to invite\n      *\n      * @returns {Promise<Member>}\n      *\n      * @example <caption>invite a user to a Conversation</caption>\n      * const user_id = 'id of User to invite';\n      * const user_name = 'username of User to invite';\n      *\n      * conversation.invite({\n      *  id: user_id,\n      *  user_name: user_name\n      * }).then((member) => {\n      *  displayMessage(member.state + \" user: \" + user_id + \" \" + user_name);\n      * }).catch((error) => {\n      *  console.error(\"error inviting user \", error);\n      * });\n      *\n    */\n    async invite(params) {\n        var _a, _b, _c, _d;\n        if (!params || (!params.id && !params.user_name)) {\n            throw new nexmoClientError_1.NexmoClientError('error:invite:missing:params');\n        }\n        const data = {\n            state: 'invited',\n            user: {\n                ...(params.id && { id: params.id }),\n                ...(params.user_name && { name: params.user_name })\n            },\n            media: params.media,\n            channel: {\n                from: {\n                    type: 'app'\n                },\n                to: {\n                    type: 'app'\n                },\n                type: 'app'\n            }\n        };\n        if (((_b = (_a = this) === null || _a === void 0 ? void 0 : _a.me) === null || _b === void 0 ? void 0 : _b.id) && ((_d = (_c = this) === null || _c === void 0 ? void 0 : _c.me) === null || _d === void 0 ? void 0 : _d.state) !== 'LEFT') {\n            data[\"from\"] = this.me.id;\n        }\n        try {\n            const response = await this.application.session.sendNetworkRequest({\n                type: 'POST',\n                path: `conversations/${this.id}/members`,\n                version: 'v0.3',\n                data\n            });\n            const member = new member_1.default(this, response);\n            return member;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n      * Invite the given user (id or name) to this conversation with media audio\n      * @param {Member} params\n      * @param {string} [params.id or user_name] - the id or the username of the User to invite\n      *\n      * @returns {Promise<Member>}\n      *\n      * @example <caption>invite a user to a conversation</caption>\n      * const user_id = 'id of User to invite';\n      * const user_name = 'username of User to invite';\n      *\n      * conversation.inviteWithAudio({\n      *  id: user_id,\n      *  user_name: user_name\n      * }).then((member) => {\n      *  displayMessage(member.state + \" user: \" + user_id + \" \" + user_name);\n      * }).catch((error) => {\n      *  console.error(\"error inviting user \", error);\n      * });\n      *\n    */\n    inviteWithAudio(params) {\n        if (!params || (!params.id && !params.user_name)) {\n            return Promise.reject(new nexmoClientError_1.NexmoClientError('error:invite:missing:params'));\n        }\n        params.media = {\n            audio_settings: {\n                enabled: true,\n                muted: false,\n                earmuffed: false\n            }\n        };\n        return this.invite(params);\n    }\n    /**\n     * Leave from the Conversation\n     * @param {object} [reason] the reason for leaving the conversation\n     * @param {string} [reason.reason_code] the code of the reason\n     * @param {string} [reason.reason_text] the description of the reason\n     * @returns {Promise}\n     * @example <caption>leave the Conversation</caption>\n     *\n     * conversation.leave({reason_code: \"mycode\", reason_text: \"my reason for leaving\"}).then(() => {\n     *  console.log(\"successfully left conversation\");\n     * }).catch((error) => {\n     *  console.error(\"error leaving conversation \", error);\n     * });\n     *\n    */\n    leave(reason) {\n        return this.me.kick(reason);\n    }\n    /**\n      * Send a text message to the conversation, which will be relayed to every other member of the conversation\n      * @param {string} text - the text message to be sent\n      *\n      * @returns {Promise<TextEvent>} - the text message that was sent\n      *\n      * @example <caption> sending a text </caption>\n      * conversation.sendText(\"Hi Vonage\").then((event) => {\n      *  console.log(\"message was sent\", event);\n      * }).catch((error)=>{\n      *  console.error(\"error sending the message \", error);\n      * });\n      *\n      * @deprecated since version 8.3.0\n      *\n    */\n    async sendText(text) {\n        try {\n            if (this.me === null) {\n                throw new nexmoClientError_1.NexmoClientError('error:self');\n            }\n            const msg = {\n                type: 'text',\n                cid: this.id,\n                from: this.me.id,\n                body: {\n                    text\n                }\n            };\n            const { id, timestamp } = await this.application.session.sendNetworkRequest({\n                type: 'POST',\n                path: `conversations/${this.id}/events`,\n                data: msg\n            });\n            msg.id = id;\n            msg.body.timestamp = timestamp;\n            return new text_event_1.default(this, msg);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n      * Send a custom event to the Conversation\n      * @param {object} params - params of the custom event\n      * @param {string} params.type the name of the custom event. Must not exceed 100 char length and contain only alpha numerics and '-' and '_' characters.\n      * @param {object} params.body customizable key value pairs\n      *\n      * @returns {Promise<NXMEvent>} - the custom event that was sent\n      *\n      * @example <caption> sending a custom event </caption>\n      * conversation.sendCustomEvent({ type: \"my-event\", body: { mykey: \"my value\" }}).then((event) => {\n      *  console.log(\"custom event was sent\", event);\n      * }).catch((error)=>{\n      *  console.error(\"error sending the custom event\", error);\n      * });\n      *\n    */\n    async sendCustomEvent({ type, body }) {\n        try {\n            if (this.me === null) {\n                throw new nexmoClientError_1.NexmoClientError('error:self');\n            }\n            else if (!type || typeof type !== 'string' || type.length < 1) {\n                throw new nexmoClientError_1.NexmoClientError('error:custom-event:invalid');\n            }\n            const data = {\n                type: `custom:${type}`,\n                cid: this.id,\n                from: this.me.id,\n                body\n            };\n            const { id, timestamp } = await this.application.session.sendNetworkRequest({\n                type: 'POST',\n                path: `conversations/${this.id}/events`,\n                data\n            });\n            data.id = id;\n            data.timestamp = timestamp;\n            return new nxmEvent_1.default(this, data);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Uploads an Image to Media Service.\n     * implements xhr (https://xhr.spec.whatwg.org/) - this.imageRequest\n     *\n     * @param {File} file single input file (jpeg/jpg)\n     * @param {object} params - params of image sent\n     * @param {string} [params.quality_ratio = 100] a value between 0 and 100. 0 indicates 'maximum compression' and the lowest quality, 100 will result in the highest quality image\n     * @param {string} [params.medium_size_ratio = 50] a value between 1 and 100. 1 indicates the new image is 1% of original, 100 - same size as original\n     * @param {string} [params.thumbnail_size_ratio = 30] a value between 1 and 100. 1 indicates the new image is 1% of original, 100 - same size as original\n     *\n     * @returns {Promise<XMLHttpRequest>}\n     *\n     * @example <caption>uploading an image</caption>\n     * const params = {\n     *  quality_ratio : \"90\",\n     *  medium_size_ratio: \"40\",\n     *  thumbnail_size_ratio: \"20\"\n     * }\n     * conversation.uploadImage(fileInput.files[0], params).then((uploadImageRequest) => {\n     *  uploadImageRequest.onprogress = (e) => {\n     *    console.log(\"Image request progress: \", e);\n     *    console.log(\"Image progress: \" + e.loaded + \"/\" + e.total);\n     *  };\n     *  uploadImageRequest.onabort = (e) => {\n     *    console.log(\"Image request aborted: \", e);\n     *    console.log(\"Image: \" + e.type);\n     *  };\n     *  uploadImageRequest.onloadend = (e) => {\n     *    console.log(\"Image request successful: \", e);\n     *    console.log(\"Image: \" + e.type);\n     *  };\n     *  uploadImageRequest.onreadystatechange = () => {\n     *    if (uploadImageRequest.readyState === 4 && uploadImageRequest.status === 200) {\n     *      const representations = JSON.parse(uploadImageRequest.responseText);\n     *      console.log(\"Original image url: \", representations.original.url);\n     *      console.log(\"Medium image url: \", representations.medium.url);\n     *      console.log(\"Thumbnail image url: \", representations.thumbnail.url);\n     *    }\n     *  };\n     * }).catch((error) => {\n     *    console.error(\"error uploading the image \", error);\n     * });\n    */\n    async uploadImage(fileInput, params = {\n        quality_ratio: '100',\n        medium_size_ratio: '50',\n        thumbnail_size_ratio: '30'\n    }) {\n        const formData = new FormData();\n        formData.append('file', fileInput);\n        formData.append('quality_ratio', params.quality_ratio);\n        formData.append('medium_size_ratio', params.medium_size_ratio);\n        formData.append('thumbnail_size_ratio', params.thumbnail_size_ratio);\n        const imageRequest = await utils_1.default.networkRequest({\n            type: 'POST',\n            url: this.application.session.config.ips_url,\n            data: formData,\n            token: this.application.session.config.token\n        });\n        imageRequest.upload.addEventListener('progress', (evt) => {\n            if (evt.lengthComputable) {\n                this.log.debug('uploading image ' + evt.loaded + '/' + evt.total);\n            }\n        }, false);\n        imageRequest.onreadystatechange = () => {\n            if (imageRequest.status !== 200) {\n                this.log.error(imageRequest);\n            }\n        };\n        return imageRequest;\n    }\n    /**\n     * Send an Image message to the conversation, which will be relayed to every other member of the conversation.\n     * implements xhr (https://xhr.spec.whatwg.org/) - this.imageRequest\n     *\n     * @param {File} file single input file (jpeg/jpg)\n     * @param {object} params - params of image sent\n     * @param {string} [params.quality_ratio = 100] a value between 0 and 100. 0 indicates 'maximum compression' and the lowest quality, 100 will result in the highest quality image\n     * @param {string} [params.medium_size_ratio = 50] a value between 1 and 100. 1 indicates the new image is 1% of original, 100 - same size as original\n     * @param {string} [params.thumbnail_size_ratio = 30] a value between 1 and 100. 1 indicates the new image is 1% of original, 100 - same size as original\n     *\n     * @returns {Promise<XMLHttpRequest>}\n     *\n     * @example <caption>sending an image</caption>\n     * const params = {\n     *  quality_ratio : \"90\",\n     *  medium_size_ratio: \"40\",\n     *  thumbnail_size_ratio: \"20\"\n     * }\n     * conversation.sendImage(fileInput.files[0], params).then((imageRequest) => {\n     *  imageRequest.onprogress = (e) => {\n     *    console.log(\"Image request progress: \", e);\n     *    console.log(\"Image progress: \" + e.loaded + \"/\" + e.total);\n     *  };\n     *  imageRequest.onabort = (e) => {\n     *    console.log(\"Image request aborted: \", e);\n     *    console.log(\"Image: \" + e.type);\n     *  };\n     *  imageRequest.onloadend = (e) => {\n     *    console.log(\"Image request successful: \", e);\n     *    console.log(\"Image: \" + e.type);\n     *  };\n     * }).catch((error) => {\n     *  console.error(\"error sending the image \", error);\n     * });\n     *\n     * @deprecated since version 8.3.0\n    */\n    async sendImage(fileInput, params = {\n        quality_ratio: '100',\n        medium_size_ratio: '50',\n        thumbnail_size_ratio: '30'\n    }) {\n        const imageRequest = await this.uploadImage(fileInput, params);\n        imageRequest.onreadystatechange = () => {\n            if (imageRequest.readyState === 4 && imageRequest.status === 200) {\n                try {\n                    this.application.session.sendNetworkRequest({\n                        type: 'POST',\n                        path: `conversations/${this.id}/events`,\n                        data: {\n                            type: 'image',\n                            from: this.me.id,\n                            body: {\n                                representations: JSON.parse(imageRequest.responseText)\n                            }\n                        }\n                    });\n                    this.log.info(imageRequest);\n                }\n                catch (error) {\n                    this.log.error(new nexmoClientError_1.NexmoApiError(error));\n                }\n            }\n        };\n        return imageRequest;\n    }\n    /**\n     * Cancel uploading or sending an Image message to the conversation.\n     *\n     * @param {XMLHttpRequest} imageRequest\n     *\n     * @returns void\n     *\n     * @example <caption>cancel sending an image</caption>\n     * conversation.sendImage(fileInput.files[0]).then((imageRequest) => {\n     *    conversation.abortSendImage(imageRequest);\n   * }).catch((error) => {\n   *    console.error(\"error sending the image \", error);\n     * });\n   *\n   * @example <caption>cancel uploading an image</caption>\n     * conversation.uploadImage(fileInput.files[0]).then((imageRequest) => {\n     *    conversation.abortSendImage(imageRequest);\n   * }).catch((error) => {\n   *    console.error(\"error uploading the image \", error);\n     * });\n    */\n    abortSendImage(imageRequest) {\n        if (imageRequest instanceof XMLHttpRequest) {\n            return imageRequest.abort();\n        }\n        else {\n            return new nexmoClientError_1.NexmoClientError('error:invalid:param:type');\n        }\n    }\n    /**\n      * Send a message event to the conversation, which will be relayed to every other member of the conversation\n      *\n      * @param {object} params the content of the message you want sent\n      * @param {string} params.message_type the type of the message. It should be one of 'text', 'image', 'audio', 'video', 'file'\n      * @param {string} [params.text] the text content when message type is 'text\n      * @param {object} [params.image]\n      * @param {string} params.image.url the image url when message type is 'image'\n      * @param {object} [params.audio]\n      * @param {string} params.audio.url the audio url when message type is 'audio'\n      * @param {object} [params.video]\n      * @param {string} params.video.url the video url when message type is 'video'\n      * @param {object} [params.file]\n      * @param {string} params.file.url the file url when message type is 'file'\n      *\n      * @returns {Promise<MessageEvent>} - the message that was sent\n      *\n      * @example <caption> sending a message </caption>\n      * conversation.sendMessage({ \"message_type\": \"text\", \"text\": \"Hi Vonage!\" }).then((event) => {\n      *  console.log(\"message was sent\", event);\n      * }).catch((error)=>{\n      *  console.error(\"error sending the message \", error);\n      * });\n      *\n    */\n    async sendMessage(params) {\n        var _a;\n        if (this.me === null) {\n            throw new nexmoClientError_1.NexmoClientError('error:self');\n        }\n        else if (!((_a = params) === null || _a === void 0 ? void 0 : _a.message_type)) {\n            throw new nexmoClientError_1.NexmoClientError('error:message-event:invalid');\n        }\n        try {\n            const msg = {\n                type: 'message',\n                cid: this.id,\n                from: this.me.id,\n                body: {\n                    ...params\n                }\n            };\n            const { id, timestamp } = await this.application.session.sendNetworkRequest({\n                type: 'POST',\n                path: `conversations/${this.id}/events`,\n                data: msg\n            });\n            msg.id = id;\n            msg.body.timestamp = timestamp;\n            return new message_event_1.default(this, msg);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    async _typing(state) {\n        const params = {\n            activity: (state === 'on') ? 1 : 0\n        };\n        const data = {\n            type: 'text:typing:' + state,\n            cid: this.id,\n            from: this.me.id,\n            body: params\n        };\n        try {\n            await this.application.session.sendNetworkRequest({\n                type: 'POST',\n                path: `conversations/${this.id}/events`,\n                data\n            });\n            return `text:typing:${state}:success`;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Send start typing indication\n     *\n     * @returns {Promise} - resolves the promise on successful sent\n     *\n     * @example <caption>send start typing event when key is pressed</caption>\n     * messageTextarea.addEventListener('keypress', (event) => {\n     *    conversation.startTyping();\n     * });\n    */\n    startTyping() {\n        return this._typing('on');\n    }\n    /**\n     * Send stop typing indication\n     *\n     * @returns {Promise} - resolves the promise on successful sent\n     *\n     * @example <caption>send stop typing event when a key has not been pressed for half a second</caption>\n     * let timeout = null;\n     * messageTextarea.addEventListener('keyup', (event) => {\n     *    clearTimeout(timeout);\n     *    timeout = setTimeout(() => {\n     *      conversation.stopTyping();\n     *    }, 500);\n     * });\n    */\n    stopTyping() {\n        return this._typing('off');\n    }\n    /**\n      * Query the service to get a list of events in this conversation.\n      *\n      * @param {object} params configure defaults for paginated events query\n      * @param {string} params.order 'asc' or 'desc' ordering of resources based on creation time\n      * @param {number} params.page_size the number of resources returned in a single request list\n      * @param {string} [params.cursor] string to access the starting point of a dataset\n      * @param {string} [params.event_type] the type of event used to filter event requests. Supports wildcard options with :* eg. 'members:*'\n      *\n      * @returns {Promise<EventsPage<Map<Events>>>} - Populate Conversations.events.\n      * @example <caption>Get Events</caption>\n      * conversation.getEvents({ event_type: 'member:*' }).then((events_page) => {\n      *   events_page.items.forEach(event => {\n      *     render(event)\n      *   })\n      * }).catch((error) => {\n      *  console.error(\"error getting the events \", error);\n      * });\n    */\n    async getEvents(params = {}) {\n        const url = `${this.application.session.config.nexmo_api_url}/beta2/conversations/${this.id}/events`;\n        // Create pageConfig if given params otherwise use default\n        let pageConfig = Object.keys(params).length === 0 ? this.pageConfig : new page_config_1.default(params);\n        try {\n            const response = await utils_1.default.paginationRequest(url, pageConfig, this.application.session.config.token);\n            response.application = this.application;\n            response.conversation = this;\n            const events_page = new events_page_1.default(response);\n            this.events_page_last = events_page;\n            return events_page;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n      * Query the service to get a list of members in this conversation.\n      *\n      * @param {object} params configure defaults for paginated events query\n      * @param {string} params.order 'asc' or 'desc' ordering of resources based on creation time\n      * @param {number} params.page_size the number of resources returned in a single request list\n      * @param {string} [params.cursor] string to access the starting point of a dataset\n      *\n      * @returns {Promise<MembersPage<Map<Member>>>}\n      * @example <caption>Get Members</caption>\n      * const params = {\n      *   order: \"desc\",\n      *   page_size: 100\n      * }\n      * conversation.getMembers(params).then((members_page) => {\n      *   members_page.items.forEach(member => {\n      *     render(member)\n      *   })\n      * }).catch((error) => {\n      *  console.error(\"error getting the members \", error);\n      * });\n    */\n    async getMembers(params = {}) {\n        const url = `${this.application.session.config.nexmo_api_url}/beta2/conversations/${this.id}/members`;\n        // Create pageConfig if given params otherwise use default\n        let pageConfig = Object.keys(params).length === 0 ? this.pageConfig : new page_config_1.default(params);\n        try {\n            const response = await utils_1.default.paginationRequest(url, pageConfig, this.application.session.config.token);\n            response.application = this.application;\n            response.conversation = this;\n            const members_page = new members_page_1.default(response);\n            this.members_page_last = members_page;\n            return members_page;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n      * Query the service to get my member in this conversation.\n      *\n      * @returns {Promise<Member>}\n      * @example <caption>Get My Member</caption>\n      * conversation.getMyMember().then((member) => {\n      *   render(member)\n      * }).catch((error) => {\n      *  console.error(\"error getting my member\", error);\n      * });\n    */\n    async getMyMember() {\n        try {\n            const response = await this.application.session.sendNetworkRequest({\n                type: 'GET',\n                path: `conversations/${this.id}/members/me`,\n                version: 'v0.3'\n            });\n            const member = new member_1.default(this, response);\n            return member;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n      * Query the service to get a member in this conversation.\n      *\n      * @param {string} member_id the id of the member to return\n      *\n      * @returns {Promise<Member>}\n      * @example <caption>Get Member</caption>\n      * conversation.getMember(\"MEM-id\").then((member) => {\n      *   render(member)\n      * }).catch((error) => {\n      *  console.error(\"error getting member\", error);\n      * });\n    */\n    async getMember(member_id) {\n        try {\n            const response = await this.application.session.sendNetworkRequest({\n                type: 'GET',\n                path: `conversations/${this.id}/members/${member_id}`,\n                version: 'v0.3'\n            });\n            const member = new member_1.default(this, response);\n            return member;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Handle and event from the cloud.\n     * using conversationEventHandler\n     * @param {object} event\n     * @private\n    */\n    _handleEvent(event) {\n        var _a, _b, _c, _d;\n        if (event.type.startsWith('rtc')) {\n            // keep the rtc events going to the application layer, we use them in media module\n            this.emit(event.type, event);\n            return Promise.resolve(event);\n        }\n        this.sequence_number++;\n        // make sure the event_id is not a string\n        if (event.body && event.body.event_id && typeof event.body.event_id === 'string') {\n            event.body.event_id = parseInt(event.body.event_id);\n        }\n        let memberInfo = { memberId: event.from };\n        if ((_b = (_a = event) === null || _a === void 0 ? void 0 : _a.body) === null || _b === void 0 ? void 0 : _b.user) {\n            const { id, name, display_name, image_url, custom_data } = event.body.user;\n            memberInfo = { ...memberInfo, ...{\n                    ...(id && { userId: id }),\n                    ...(name && { userName: name }),\n                    ...(display_name && { displayName: display_name }),\n                    ...(image_url && { imageUrl: image_url }),\n                    ...(custom_data && { customData: custom_data })\n                } };\n        }\n        else if ((_d = (_c = event) === null || _c === void 0 ? void 0 : _c._embedded) === null || _d === void 0 ? void 0 : _d.from_user) {\n            const { id, name, display_name, image_url, custom_data } = event._embedded.from_user;\n            memberInfo = { ...memberInfo, ...{\n                    ...(id && { userId: id }),\n                    ...(name && { userName: name }),\n                    ...(display_name && { displayName: display_name }),\n                    ...(image_url && { imageUrl: image_url }),\n                    ...(custom_data && { customData: custom_data })\n                } };\n        }\n        let constructed_event = this.conversationEventHandler.handleEvent(event);\n        // Unless they are typing events, add the event to the conversation.events map\n        if (!['text:typing:on', 'text:typing:off'].includes(event.type)) {\n            this.events.set(constructed_event.id, constructed_event);\n        }\n        // For custom events remove the custom: prefix before emitting event\n        if (event.type.startsWith('custom:')) {\n            this.emit(constructed_event.type, memberInfo, constructed_event);\n            return Promise.resolve(event);\n        }\n        this.emit(event.type, memberInfo, constructed_event);\n        return Promise.resolve(event);\n    }\n}\nexports.default = Conversation;\nmodule.exports = Conversation;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}