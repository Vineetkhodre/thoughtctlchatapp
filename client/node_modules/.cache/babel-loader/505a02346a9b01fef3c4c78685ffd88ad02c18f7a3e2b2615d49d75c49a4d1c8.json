{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Nexmo Client SDK\n *  Errors Emitter\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst loglevel_1 = require(\"loglevel\");\nconst nexmoClientError_1 = require(\"../nexmoClientError\");\n/**\n * Class that can emit errors via any emitter passed to it.\n * @class ErrorsEmitter\n * @param {Emitter} emitter - Any event emitter that implements \"emit\" and \"releaseGroup\". Basically object that is mixed with Wildemitter.\n * @property {string} LISTENER_GROUP='NXM-errors' - the group this emitter will register\n * @emits Emitter#NXM-errors\n * @private\n*/\n/**\n * Application listening for client and expired-token errors events.\n *\n * @event Application#NXM-errors\n *\n * @property {NexmoClientError} error\n *\n * @example <caption>listen for client error events on Application level</caption>\n * application.on('*', 'NXM-errors', (error) => {\n *    console.log('Error thrown with type ' + error.type);\n *  });\n * @example <caption>listen for expired-token error events and then update the token on Application level</caption>\n * application.on('system:error:expired-token', 'NXM-errors', (error) => {\n * \tconsole.log('token expired');\n * \tapplication.updateToken(token);\n * });\n*/\nclass ErrorsEmitter {\n  constructor(emitter) {\n    this.log = loglevel_1.getLogger(this.constructor.name);\n    if (!emitter) {\n      throw new nexmoClientError_1.NexmoClientError('no emitter object passed for the Error Emitter');\n    }\n    this.emitter = emitter;\n    this.LISTENER_GROUP = 'NXM-errors';\n  }\n  /**\n   * Detect if the param.type includes error and emit that payload in the LISTENER_GROUP\n   * @param param - the payload to forward in the LISTENER_GROUP\n   * @param param.type - the type of the event to check if it's an error\n  */\n  emitResponseIfError(param) {\n    if (this._isTypeError(param.type)) {\n      return this.emitter.emit(param.type, this.LISTENER_GROUP, param);\n    }\n    return;\n  }\n  /**\n   * Release Group on the registered emitter (using the namespace LISTENER_GROUP that is set)\n  */\n  cleanup() {\n    return this.emitter.releaseGroup(this.LISTENER_GROUP);\n  }\n  /**\n   * Returns true if the param includes 'error'\n   * @param {string} type - the error type to check\n  */\n  _isTypeError(param) {\n    return param.indexOf('error') !== -1;\n  }\n}\nexports.default = ErrorsEmitter;\nmodule.exports = ErrorsEmitter;","map":{"version":3,"names":["Object","defineProperty","exports","value","loglevel_1","require","nexmoClientError_1","ErrorsEmitter","constructor","emitter","log","getLogger","name","NexmoClientError","LISTENER_GROUP","emitResponseIfError","param","_isTypeError","type","emit","cleanup","releaseGroup","indexOf","default","module"],"sources":["/Users/vineetkhodre/react-workspace/thoughtctlchatapp/client/node_modules/nexmo-client/dist/modules/errors_emitter.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  Errors Emitter\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst loglevel_1 = require(\"loglevel\");\nconst nexmoClientError_1 = require(\"../nexmoClientError\");\n/**\n * Class that can emit errors via any emitter passed to it.\n * @class ErrorsEmitter\n * @param {Emitter} emitter - Any event emitter that implements \"emit\" and \"releaseGroup\". Basically object that is mixed with Wildemitter.\n * @property {string} LISTENER_GROUP='NXM-errors' - the group this emitter will register\n * @emits Emitter#NXM-errors\n * @private\n*/\n/**\n * Application listening for client and expired-token errors events.\n *\n * @event Application#NXM-errors\n *\n * @property {NexmoClientError} error\n *\n * @example <caption>listen for client error events on Application level</caption>\n * application.on('*', 'NXM-errors', (error) => {\n *    console.log('Error thrown with type ' + error.type);\n *  });\n * @example <caption>listen for expired-token error events and then update the token on Application level</caption>\n * application.on('system:error:expired-token', 'NXM-errors', (error) => {\n * \tconsole.log('token expired');\n * \tapplication.updateToken(token);\n * });\n*/\nclass ErrorsEmitter {\n    constructor(emitter) {\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        if (!emitter) {\n            throw new nexmoClientError_1.NexmoClientError('no emitter object passed for the Error Emitter');\n        }\n        this.emitter = emitter;\n        this.LISTENER_GROUP = 'NXM-errors';\n    }\n    /**\n     * Detect if the param.type includes error and emit that payload in the LISTENER_GROUP\n     * @param param - the payload to forward in the LISTENER_GROUP\n     * @param param.type - the type of the event to check if it's an error\n    */\n    emitResponseIfError(param) {\n        if (this._isTypeError(param.type)) {\n            return this.emitter.emit(param.type, this.LISTENER_GROUP, param);\n        }\n        return;\n    }\n    /**\n     * Release Group on the registered emitter (using the namespace LISTENER_GROUP that is set)\n    */\n    cleanup() {\n        return this.emitter.releaseGroup(this.LISTENER_GROUP);\n    }\n    /**\n     * Returns true if the param includes 'error'\n     * @param {string} type - the error type to check\n    */\n    _isTypeError(param) {\n        return param.indexOf('error') !== -1;\n    }\n}\nexports.default = ErrorsEmitter;\nmodule.exports = ErrorsEmitter;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,UAAU,GAAGC,OAAO,CAAC,UAAU,CAAC;AACtC,MAAMC,kBAAkB,GAAGD,OAAO,CAAC,qBAAqB,CAAC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,aAAa,CAAC;EAChBC,WAAWA,CAACC,OAAO,EAAE;IACjB,IAAI,CAACC,GAAG,GAAGN,UAAU,CAACO,SAAS,CAAC,IAAI,CAACH,WAAW,CAACI,IAAI,CAAC;IACtD,IAAI,CAACH,OAAO,EAAE;MACV,MAAM,IAAIH,kBAAkB,CAACO,gBAAgB,CAAC,gDAAgD,CAAC;IACnG;IACA,IAAI,CAACJ,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACK,cAAc,GAAG,YAAY;EACtC;EACA;AACJ;AACA;AACA;AACA;EACIC,mBAAmBA,CAACC,KAAK,EAAE;IACvB,IAAI,IAAI,CAACC,YAAY,CAACD,KAAK,CAACE,IAAI,CAAC,EAAE;MAC/B,OAAO,IAAI,CAACT,OAAO,CAACU,IAAI,CAACH,KAAK,CAACE,IAAI,EAAE,IAAI,CAACJ,cAAc,EAAEE,KAAK,CAAC;IACpE;IACA;EACJ;EACA;AACJ;AACA;EACII,OAAOA,CAAA,EAAG;IACN,OAAO,IAAI,CAACX,OAAO,CAACY,YAAY,CAAC,IAAI,CAACP,cAAc,CAAC;EACzD;EACA;AACJ;AACA;AACA;EACIG,YAAYA,CAACD,KAAK,EAAE;IAChB,OAAOA,KAAK,CAACM,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;EACxC;AACJ;AACApB,OAAO,CAACqB,OAAO,GAAGhB,aAAa;AAC/BiB,MAAM,CAACtB,OAAO,GAAGK,aAAa"},"metadata":{},"sourceType":"script","externalDependencies":[]}