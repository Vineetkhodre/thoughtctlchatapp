{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _fs = require(\"fs\");\nvar _fs2 = _interopRequireDefault(_fs);\nvar _JwtGenerator = require(\"./JwtGenerator\");\nvar _JwtGenerator2 = _interopRequireDefault(_JwtGenerator);\nvar _HashGenerator = require(\"./HashGenerator\");\nvar _HashGenerator2 = _interopRequireDefault(_HashGenerator);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * Right now only key/secret credentials are supported.\n * However, in time JWT will also be supported.\n * The `Credentials` object provides an abstraction to this.\n *\n * @param {string} apiKey - A Nexmo API Key\n * @param {string} apiSecret - A Nexmo API Secret\n * @param {string} [applicationId] - A Nexmo Application ID\n * @param {string|Buffer} [privateKey] -  When a string value is passed it should\n *                        either represent the path to the private key, or the actual\n *                        private key in string format. If a Buffer is passed then\n *                        it should be the key read from the file system.\n * @param {string} [signatureSecret] - A Nexmo signature Secret\n * @param {string} [signatureMethod] - A Nexmo compatible request signing method\n */\nvar Credentials = function () {\n  function Credentials(apiKey, apiSecret, privateKey, applicationId, signatureSecret, signatureMethod) {\n    _classCallCheck(this, Credentials);\n    this.apiKey = apiKey;\n    this.apiSecret = apiSecret;\n    this.privateKey = null;\n    this.applicationId = applicationId;\n    this.signatureSecret = signatureSecret;\n    this.signatureMethod = signatureMethod;\n    if (privateKey instanceof Buffer) {\n      this.privateKey = privateKey;\n    } else if (typeof privateKey === \"string\" && privateKey.startsWith(\"-----BEGIN PRIVATE KEY-----\")) {\n      this.privateKey = new Buffer(privateKey);\n    } else if (privateKey !== undefined) {\n      if (!_fs2.default.existsSync(privateKey)) {\n        throw new Error(\"File \\\"\" + privateKey + \"\\\" not found.\");\n      }\n      this.privateKey = _fs2.default.readFileSync(privateKey);\n    }\n\n    /** @private */\n    this._jwtGenerator = new _JwtGenerator2.default();\n    this._hashGenerator = new _HashGenerator2.default();\n  }\n\n  /**\n   * Generate a Jwt using the Private Key in the Credentials.\n   * By default the credentials.applicationId will be used when creating the token.\n   * However, this can be overwritten.\n   *\n   * @param {string} [applicationId] an application ID to be used instead of the\n   *                default Credentials.applicationId value.\n   *\n   * @returns {string} The generated JWT\n   */\n\n  _createClass(Credentials, [{\n    key: \"generateJwt\",\n    value: function generateJwt() {\n      var applicationId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.applicationId;\n      var privateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.privateKey;\n      var claims = {\n        application_id: applicationId\n      };\n      var token = this._jwtGenerator.generate(privateKey, claims);\n      return token;\n    }\n  }, {\n    key: \"generateSignature\",\n    value: function generateSignature(params) {\n      var signatureSecret = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.signatureSecret;\n      var signatureMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.signatureMethod;\n      return this._hashGenerator.generate(signatureMethod, signatureSecret, params);\n    }\n\n    /**\n     * @private\n     * Used for testing purposes only.\n     */\n  }, {\n    key: \"_setJwtGenerator\",\n    value: function _setJwtGenerator(generator) {\n      this._jwtGenerator = generator;\n    }\n\n    /**\n     * @private\n     * Used for testing purposes only.\n     */\n  }, {\n    key: \"_setHashGenerator\",\n    value: function _setHashGenerator(generator) {\n      this._hashGenerator = generator;\n    }\n\n    /**\n     * Ensures a credentials instance is used.\n     *\n     * Key/Secret credentials are only supported at present.\n     */\n  }], [{\n    key: \"parse\",\n    value: function parse(obj) {\n      if (obj instanceof Credentials) {\n        return obj;\n      } else {\n        return new Credentials(obj.apiKey, obj.apiSecret, obj.privateKey, obj.applicationId, obj.signatureSecret, obj.signatureMethod);\n      }\n    }\n  }]);\n  return Credentials;\n}();\nexports.default = Credentials;\nmodule.exports = exports[\"default\"];","map":{"version":3,"names":["_fs","require","_JwtGenerator","_HashGenerator","Credentials","apiKey","apiSecret","privateKey","applicationId","signatureSecret","signatureMethod","_classCallCheck","Buffer","startsWith","undefined","_fs2","default","existsSync","Error","readFileSync","_jwtGenerator","_JwtGenerator2","_hashGenerator","_HashGenerator2","arguments","length","claims","application_id","token","generate","params","generator","obj"],"sources":["/Users/vineetkhodre/react-workspace/thoughtctlchatapp/node_modules/nexmo/src/Credentials.js"],"sourcesContent":["\"use strict\";\n\nimport fs from \"fs\";\nimport JwtGenerator from \"./JwtGenerator\";\nimport HashGenerator from \"./HashGenerator\";\n\n/**\n * Right now only key/secret credentials are supported.\n * However, in time JWT will also be supported.\n * The `Credentials` object provides an abstraction to this.\n *\n * @param {string} apiKey - A Nexmo API Key\n * @param {string} apiSecret - A Nexmo API Secret\n * @param {string} [applicationId] - A Nexmo Application ID\n * @param {string|Buffer} [privateKey] -  When a string value is passed it should\n *                        either represent the path to the private key, or the actual\n *                        private key in string format. If a Buffer is passed then\n *                        it should be the key read from the file system.\n * @param {string} [signatureSecret] - A Nexmo signature Secret\n * @param {string} [signatureMethod] - A Nexmo compatible request signing method\n */\nclass Credentials {\n  constructor(\n    apiKey,\n    apiSecret,\n    privateKey,\n    applicationId,\n    signatureSecret,\n    signatureMethod\n  ) {\n    this.apiKey = apiKey;\n    this.apiSecret = apiSecret;\n\n    this.privateKey = null;\n    this.applicationId = applicationId;\n\n    this.signatureSecret = signatureSecret;\n    this.signatureMethod = signatureMethod;\n\n    if (privateKey instanceof Buffer) {\n      this.privateKey = privateKey;\n    } else if (\n      typeof privateKey === \"string\" &&\n      privateKey.startsWith(\"-----BEGIN PRIVATE KEY-----\")\n    ) {\n      this.privateKey = new Buffer(privateKey);\n    } else if (privateKey !== undefined) {\n      if (!fs.existsSync(privateKey)) {\n        throw new Error(`File \"${privateKey}\" not found.`);\n      }\n      this.privateKey = fs.readFileSync(privateKey);\n    }\n\n    /** @private */\n    this._jwtGenerator = new JwtGenerator();\n    this._hashGenerator = new HashGenerator();\n  }\n\n  /**\n   * Generate a Jwt using the Private Key in the Credentials.\n   * By default the credentials.applicationId will be used when creating the token.\n   * However, this can be overwritten.\n   *\n   * @param {string} [applicationId] an application ID to be used instead of the\n   *                default Credentials.applicationId value.\n   *\n   * @returns {string} The generated JWT\n   */\n  generateJwt(\n    applicationId = this.applicationId,\n    privateKey = this.privateKey\n  ) {\n    var claims = {\n      application_id: applicationId\n    };\n    var token = this._jwtGenerator.generate(privateKey, claims);\n    return token;\n  }\n\n  generateSignature(\n    params,\n    signatureSecret = this.signatureSecret,\n    signatureMethod = this.signatureMethod\n  ) {\n    return this._hashGenerator.generate(\n      signatureMethod,\n      signatureSecret,\n      params\n    );\n  }\n\n  /**\n   * @private\n   * Used for testing purposes only.\n   */\n  _setJwtGenerator(generator) {\n    this._jwtGenerator = generator;\n  }\n\n  /**\n   * @private\n   * Used for testing purposes only.\n   */\n  _setHashGenerator(generator) {\n    this._hashGenerator = generator;\n  }\n\n  /**\n   * Ensures a credentials instance is used.\n   *\n   * Key/Secret credentials are only supported at present.\n   */\n  static parse(obj) {\n    if (obj instanceof Credentials) {\n      return obj;\n    } else {\n      return new Credentials(\n        obj.apiKey,\n        obj.apiSecret,\n        obj.privateKey,\n        obj.applicationId,\n        obj.signatureSecret,\n        obj.signatureMethod\n      );\n    }\n  }\n}\n\nexport default Credentials;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}