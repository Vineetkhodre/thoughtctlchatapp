{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _JwtGenerator = _interopRequireDefault(require(\"./JwtGenerator\"));\nvar _HashGenerator = _interopRequireDefault(require(\"./HashGenerator\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Right now only key/secret credentials are supported.\n * However, in time JWT will also be supported.\n * The `Credentials` object provides an abstraction to this.\n *\n * @param {string} apiKey - A Vonage API Key\n * @param {string} apiSecret - A Vonage API Secret\n * @param {string} [applicationId] - A VonageApplication ID\n * @param {string|Buffer} [privateKey] -  When a string value is passed it should\n *                        either represent the path to the private key, or the actual\n *                        private key in string format. If a Buffer is passed then\n *                        it should be the key read from the file system.\n * @param {string} [signatureSecret] - A Vonage signature Secret\n * @param {string} [signatureMethod] - A Vonage compatible request signing method\n */\nclass Credentials {\n  constructor(apiKey, apiSecret, privateKey, applicationId, signatureSecret, signatureMethod) {\n    this.apiKey = apiKey;\n    this.apiSecret = apiSecret;\n    this.privateKey = null;\n    this.applicationId = applicationId;\n    this.signatureSecret = signatureSecret;\n    this.signatureMethod = signatureMethod;\n    if (privateKey instanceof Buffer) {\n      // it is already a buffer, use it as-is\n      this.privateKey = privateKey;\n    } else if (typeof privateKey === \"string\" && privateKey.startsWith(\"-----BEGIN PRIVATE KEY-----\")) {\n      // It's a key string. Check for \\n, replace with newlines\n      privateKey = privateKey.replace(/\\\\n/g, \"\\n\");\n      this.privateKey = Buffer.from(privateKey, \"utf-8\");\n    } else if (privateKey !== undefined) {\n      if (!_fs.default.existsSync(privateKey)) {\n        throw new Error(\"File \\\"\".concat(privateKey, \"\\\" not found.\"));\n      }\n      this.privateKey = _fs.default.readFileSync(privateKey);\n    }\n    /** @private */\n\n    this._jwtGenerator = new _JwtGenerator.default();\n    this._hashGenerator = new _HashGenerator.default();\n  }\n  /**\n   * Generate a Jwt using the Private Key in the Credentials.\n   * By default the credentials.applicationId will be used when creating the token.\n   * However, this can be overwritten.\n   *\n   * @param {string} [applicationId] an application ID to be used instead of the\n   *                default Credentials.applicationId value.\n   *\n   * @returns {string} The generated JWT\n   */\n\n  generateJwt() {\n    var applicationId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.applicationId;\n    var privateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.privateKey;\n    var claims = {\n      application_id: applicationId\n    };\n    var token = this._jwtGenerator.generate(privateKey, claims);\n    return token;\n  }\n  generateSignature(params) {\n    var signatureSecret = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.signatureSecret;\n    var signatureMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.signatureMethod;\n    return this._hashGenerator.generate(signatureMethod, signatureSecret, params);\n  }\n  /**\n   * @private\n   * Used for testing purposes only.\n   */\n\n  _setJwtGenerator(generator) {\n    this._jwtGenerator = generator;\n  }\n  /**\n   * @private\n   * Used for testing purposes only.\n   */\n\n  _setHashGenerator(generator) {\n    this._hashGenerator = generator;\n  }\n  /**\n   * Ensures a credentials instance is used.\n   *\n   * Key/Secret credentials are only supported at present.\n   */\n\n  static parse(obj) {\n    if (obj instanceof Credentials) {\n      return obj;\n    } else {\n      return new Credentials(obj.apiKey, obj.apiSecret, obj.privateKey, obj.applicationId, obj.signatureSecret, obj.signatureMethod);\n    }\n  }\n}\nvar _default = Credentials;\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["_fs","_interopRequireDefault","require","_JwtGenerator","_HashGenerator","Credentials","constructor","apiKey","apiSecret","privateKey","applicationId","signatureSecret","signatureMethod","Buffer","startsWith","replace","from","undefined","default","existsSync","Error","concat","readFileSync","_jwtGenerator","_hashGenerator","generateJwt","arguments","length","claims","application_id","token","generate","generateSignature","params","_setJwtGenerator","generator","_setHashGenerator","parse","obj"],"sources":["/Users/vineetkhodre/react-workspace/thoughtctlchatapp/node_modules/@vonage/server-sdk/src/Credentials.js"],"sourcesContent":["\"use strict\";\n\nimport fs from \"fs\";\nimport JwtGenerator from \"./JwtGenerator\";\nimport HashGenerator from \"./HashGenerator\";\n\n/**\n * Right now only key/secret credentials are supported.\n * However, in time JWT will also be supported.\n * The `Credentials` object provides an abstraction to this.\n *\n * @param {string} apiKey - A Vonage API Key\n * @param {string} apiSecret - A Vonage API Secret\n * @param {string} [applicationId] - A VonageApplication ID\n * @param {string|Buffer} [privateKey] -  When a string value is passed it should\n *                        either represent the path to the private key, or the actual\n *                        private key in string format. If a Buffer is passed then\n *                        it should be the key read from the file system.\n * @param {string} [signatureSecret] - A Vonage signature Secret\n * @param {string} [signatureMethod] - A Vonage compatible request signing method\n */\nclass Credentials {\n  constructor(\n    apiKey,\n    apiSecret,\n    privateKey,\n    applicationId,\n    signatureSecret,\n    signatureMethod\n  ) {\n    this.apiKey = apiKey;\n    this.apiSecret = apiSecret;\n\n    this.privateKey = null;\n    this.applicationId = applicationId;\n\n    this.signatureSecret = signatureSecret;\n    this.signatureMethod = signatureMethod;\n\n    if (privateKey instanceof Buffer) {\n      // it is already a buffer, use it as-is\n      this.privateKey = privateKey;\n    } else if (\n      typeof privateKey === \"string\" &&\n      privateKey.startsWith(\"-----BEGIN PRIVATE KEY-----\")\n    ) {\n      // It's a key string. Check for \\n, replace with newlines\n      privateKey = privateKey.replace(/\\\\n/g, \"\\n\");\n      this.privateKey = Buffer.from(privateKey, \"utf-8\");\n    } else if (privateKey !== undefined) {\n      if (!fs.existsSync(privateKey)) {\n        throw new Error(`File \"${privateKey}\" not found.`);\n      }\n      this.privateKey = fs.readFileSync(privateKey);\n    }\n\n    /** @private */\n    this._jwtGenerator = new JwtGenerator();\n    this._hashGenerator = new HashGenerator();\n  }\n\n  /**\n   * Generate a Jwt using the Private Key in the Credentials.\n   * By default the credentials.applicationId will be used when creating the token.\n   * However, this can be overwritten.\n   *\n   * @param {string} [applicationId] an application ID to be used instead of the\n   *                default Credentials.applicationId value.\n   *\n   * @returns {string} The generated JWT\n   */\n  generateJwt(\n    applicationId = this.applicationId,\n    privateKey = this.privateKey\n  ) {\n    var claims = {\n      application_id: applicationId,\n    };\n    var token = this._jwtGenerator.generate(privateKey, claims);\n    return token;\n  }\n\n  generateSignature(\n    params,\n    signatureSecret = this.signatureSecret,\n    signatureMethod = this.signatureMethod\n  ) {\n    return this._hashGenerator.generate(\n      signatureMethod,\n      signatureSecret,\n      params\n    );\n  }\n\n  /**\n   * @private\n   * Used for testing purposes only.\n   */\n  _setJwtGenerator(generator) {\n    this._jwtGenerator = generator;\n  }\n\n  /**\n   * @private\n   * Used for testing purposes only.\n   */\n  _setHashGenerator(generator) {\n    this._hashGenerator = generator;\n  }\n\n  /**\n   * Ensures a credentials instance is used.\n   *\n   * Key/Secret credentials are only supported at present.\n   */\n  static parse(obj) {\n    if (obj instanceof Credentials) {\n      return obj;\n    } else {\n      return new Credentials(\n        obj.apiKey,\n        obj.apiSecret,\n        obj.privateKey,\n        obj.applicationId,\n        obj.signatureSecret,\n        obj.signatureMethod\n      );\n    }\n  }\n}\n\nexport default Credentials;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}