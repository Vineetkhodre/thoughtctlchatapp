{"ast":null,"code":"\"use strict\";\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar crypto = require(\"crypto\");\nvar HashGenerator = function () {\n  function HashGenerator() {\n    _classCallCheck(this, HashGenerator);\n  }\n  _createClass(HashGenerator, [{\n    key: \"generate\",\n    /**\n     * Generate a Signature Hash.\n     *\n     * @param {String} method - the method to be used when creating the hash\n     * @param {String} secret - the secret to be used when creating the hash\n     * @param {Object} params - params to generate hash from\n     *\n     * @returns {String} the generated token\n     */\n    value: function generate(method, secret, params) {\n      params = params || {};\n      var signedQuery = \"\";\n      params = JSON.parse(JSON.stringify(params));\n      if (params.sig) {\n        delete params.sig;\n      }\n      Object.keys(params).sort().forEach(function (key) {\n        // replace & and = with _\n        signedQuery += \"&\" + key + \"=\" + params[key].replace(/\\&|\\=/g, \"_\");\n      });\n      var hash = \"\";\n      switch (method) {\n        case \"md5hash\":\n          signedQuery += secret;\n          hash = crypto.createHash(\"md5\").update(signedQuery).digest(\"hex\");\n          break;\n        case \"md5\":\n        case \"sha1\":\n        case \"sha256\":\n        case \"sha512\":\n          hash = crypto.createHmac(method, secret).update(signedQuery).digest(\"hex\");\n          break;\n        default:\n          throw \"Unknown signature algorithm: \" + method + \". Expected: md5hash, md5, sha1, sha256, or sha512\";\n      }\n      return hash;\n    }\n  }]);\n  return HashGenerator;\n}();\nmodule.exports = HashGenerator;","map":{"version":3,"names":["crypto","require","HashGenerator","method","secret","params","signedQuery","JSON","parse","stringify","sig","Object","keys","sort","forEach","key","replace","hash","createHash","update","digest","createHmac","module","exports"],"sources":["/Users/vineetkhodre/react-workspace/thoughtctlchatapp/node_modules/nexmo/src/HashGenerator.js"],"sourcesContent":["const crypto = require(\"crypto\");\n\nclass HashGenerator {\n  /**\n   * Generate a Signature Hash.\n   *\n   * @param {String} method - the method to be used when creating the hash\n   * @param {String} secret - the secret to be used when creating the hash\n   * @param {Object} params - params to generate hash from\n   *\n   * @returns {String} the generated token\n   */\n  generate(method, secret, params) {\n    params = params || {};\n    var signedQuery = \"\";\n\n    params = JSON.parse(JSON.stringify(params));\n\n    if (params.sig) {\n      delete params.sig;\n    }\n\n    Object.keys(params)\n      .sort()\n      .forEach(key => {\n        // replace & and = with _\n        signedQuery += \"&\" + key + \"=\" + params[key].replace(/\\&|\\=/g, \"_\");\n      });\n\n    var hash = \"\";\n\n    switch (method) {\n      case \"md5hash\":\n        signedQuery += secret;\n        hash = crypto\n          .createHash(\"md5\")\n          .update(signedQuery)\n          .digest(\"hex\");\n        break;\n      case \"md5\":\n      case \"sha1\":\n      case \"sha256\":\n      case \"sha512\":\n        hash = crypto\n          .createHmac(method, secret)\n          .update(signedQuery)\n          .digest(\"hex\");\n        break;\n\n      default:\n        throw `Unknown signature algorithm: ${method}. Expected: md5hash, md5, sha1, sha256, or sha512`;\n    }\n\n    return hash;\n  }\n}\n\nmodule.exports = HashGenerator;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAMA,MAAA,GAASC,OAAA,CAAQ,QAAR,CAAf;IAEMC,a;;;;;;IACJ;;;;;;;;;6BASSC,M,EAAQC,M,EAAQC,M,EAAQ;MAC/BA,MAAA,GAASA,MAAA,IAAU,EAAnB;MACA,IAAIC,WAAA,GAAc,EAAlB;MAEAD,MAAA,GAASE,IAAA,CAAKC,KAAL,CAAWD,IAAA,CAAKE,SAAL,CAAeJ,MAAf,CAAX,CAAT;MAEA,IAAIA,MAAA,CAAOK,GAAX,EAAgB;QACd,OAAOL,MAAA,CAAOK,GAAd;MACD;MAEDC,MAAA,CAAOC,IAAP,CAAYP,MAAZ,EACGQ,IADH,GAEGC,OAFH,CAEW,UAAAC,GAAA,EAAO;QACd;QACAT,WAAA,IAAe,MAAMS,GAAN,GAAY,GAAZ,GAAkBV,MAAA,CAAOU,GAAP,EAAYC,OAAZ,CAAoB,QAApB,EAA8B,GAA9B,CAAjC;MACD,CALH;MAOA,IAAIC,IAAA,GAAO,EAAX;MAEA,QAAQd,MAAR;QACE,KAAK,SAAL;UACEG,WAAA,IAAeF,MAAf;UACAa,IAAA,GAAOjB,MAAA,CACJkB,UADI,CACO,KADP,EAEJC,MAFI,CAEGb,WAFH,EAGJc,MAHI,CAGG,KAHH,CAAP;UAIA;QACF,KAAK,KAAL;QACA,KAAK,MAAL;QACA,KAAK,QAAL;QACA,KAAK,QAAL;UACEH,IAAA,GAAOjB,MAAA,CACJqB,UADI,CACOlB,MADP,EACeC,MADf,EAEJe,MAFI,CAEGb,WAFH,EAGJc,MAHI,CAGG,KAHH,CAAP;UAIA;QAEF;UACE,wCAAsCjB,MAAtC;MAnBJ;MAsBA,OAAOc,IAAP;IACD;;;;AAGHK,MAAA,CAAOC,OAAP,GAAiBrB,aAAjB"},"metadata":{},"sourceType":"script","externalDependencies":[]}