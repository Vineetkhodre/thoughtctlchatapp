{"ast":null,"code":"'use strict';\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Nexmo Client SDK\n *  Main wrapper\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst WildEmitter = require('wildemitter');\nconst loglevel_plugin_prefix_1 = __importDefault(require(\"loglevel-plugin-prefix\"));\nconst loglevel_1 = __importDefault(require(\"loglevel\"));\nconst nexmoClientError_1 = require(\"./nexmoClientError\");\nconst socket_io_client_1 = __importDefault(require(\"socket.io-client\"));\nconst js_1 = __importDefault(require(\"@bugsnag/js\"));\nconst publicip_1 = __importDefault(require(\"./modules/publicip\"));\nconst utils_1 = __importDefault(require(\"./utils\"));\nconst application_1 = __importDefault(require(\"./application\"));\nconst errors_emitter_1 = __importDefault(require(\"./modules/errors_emitter\"));\nconst user_1 = __importDefault(require(\"./user\"));\nconst rtc_helper_1 = __importDefault(require(\"./modules/rtc_helper\"));\nloglevel_plugin_prefix_1.default.reg(loglevel_1.default);\nloglevel_plugin_prefix_1.default.apply(loglevel_1.default, {\n  template: '[%t] %l (NXM-%n):',\n  timestampFormatter: date => {\n    return date.toTimeString().replace(/.*(\\d{2}:\\d{2}:\\d{2}).*/, '$1');\n  },\n  levelFormatter: level => {\n    return level.toUpperCase();\n  },\n  nameFormatter: name => {\n    return name || 'SDK';\n  }\n});\n/**\n * The parent NexmoClient class.\n *\n * @class NexmoClient\n *\n * @param {object} params the settings to initialise the SDK\n * @param {string} params.debug='silent' set mode to 'debug', 'info', 'warn', or 'error' for customized logging levels in the console\n * @param {string} params.url='nexmo_ws_url' Nexmo Conversation Websocket url, default is wss://ws.nexmo.com (wss://ws-us-1.nexmo.com for WDC, wss://ws-us-2.nexmo.com for DAL, wss://ws-eu-1.nexmo.com for LON, wss://ws-sg-1.nexmo.com for SNG)\n * @param {string} params.nexmo_api_url=Nexmo Conversation Api url, default is https://api.nexmo.com (https://api-us-1.nexmo.com for WDC, https://api-us-2.nexmo.com for DAL, https://api-eu-1.nexmo.com for LON, https://api-sg-1.nexmo.com for SNG)\n * @param {string} params.ips_url='ips_url' Nexmo IPS url for image upload, default is https://api.nexmo.com/v1/image (https://api-us-1.nexmo.com/v1/image for WDC, https://api-us-2.nexmo.com/v1/image for DAL, https://api-eu-1.nexmo.com/v1/image for LON, https://api-sg-1.nexmo.com/v1/image for SNG)\n * @param {string} params.path='/v2/rtc' Nexmo Conversation Websocket url path suffix\n * @param {RTCStatsConfig} params.rtcstats set reporting for stream statistics (Internal event emit)\n * @param {Boolean} params.rtcstats.emit_events=false receive rtcstats:report event (deprecated)\n * @param {Boolean} params.rtcstats.emit_rtc_analytics=false receive rtcstats:analytics event\n * @param {number} params.rtcstats.emit_interval=1000 interval in ms for rtcstats:report and rtcstats:analytics\n * @param {Boolean} params.rtcstats.remote_collection=true collect client logs internally\n * @param {Boolean} params.rtcstats.remote_collection_url='gollum_url' url for collecting client logs internally\n * @param {number} params.rtcstats.remote_collection_interval=5000 interval in ms to collect client logs internally\n * @param {object} params.socket_io configure socket.io\n * @param {Boolean} params.socket_io.forceNew=true configure socket.io forceNew attribute\n * @param {Boolean} params.socket_io.autoConnect=true socket.io autoConnect attribute\n * @param {Boolean} params.socket_io.reconnection=true socket.io reconnection attribute\n * @param {number} params.socket_io.reconnectionAttempts=5 socket.io reconnectionAttempts attribute\n * @param {string[]} params.socket_io.transports='websocket' socket.io transports protocols\n * @param {string} params.sync='none' {'none' || 'lite' || 'full'} after a successful session creation, synchronise conversations, include events or nothing\n * @param {string} params.environment='production' development / production environment\n * @param {object[]} params.iceServers configure iceServers for RTCPeerConnection\n * @param {string} params.iceServers.urls='stun:stun.l.google.com:19302' urls for iceServers\n * @param {object} params.log_reporter configure log reports for bugsnag tool\n * @param {Boolean} params.log_reporter.enabled=true\n * @param {string} params.log_reporter.bugsnag_key your bugsnag api key / defaults to Nexmo api key\n * @param {object} params.conversations_page_config configure paginated requests for conversations\n * @param {number} params.conversations_page_config.page_size=10 the number of resources returned in a single request list\n * @param {string} params.conversations_page_config.order=asc 'asc' or 'desc' ordering of resources (usually based on creation time)\n * @param {string} params.conversations_page_config.cursor cursor parameter to access the next or previous page of a data set\n * @param {object} params.events_page_config configure paginated requests for events\n * @param {number} params.events_page_config.page_size=10 the number of resources returned in a single request list\n * @param {string} params.events_page_config.order=asc 'asc' or 'desc' ordering of resources (usually based on creation time)\n * @param {string} params.events_page_config.event_type the type of event used to filter event requests. Supports wildcard options with :* eg. 'members:*'\n * @param {Boolean} params.enableEventsQueue=true mechanism to guarantee order of events received during a session\n * @param {string} params.token the jwt token for network requests\n *\n * @emits NexmoClient#connecting\n * @emits NexmoClient#disconnect\n * @emits NexmoClient#error\n * @emits NexmoClient#ready\n * @emits NexmoClient#reconnect\n * @emits NexmoClient#reconnecting\n*/\nclass NexmoClient {\n  constructor(params = {}) {\n    // save an array of instances\n    const inputParams = params;\n    this.config = {\n      debug: 'silent',\n      log_reporter: {\n        enabled: false,\n        bugsnag_key: null\n      },\n      environment: 'production',\n      ips_url: 'https://api-us.vonage.com/v1/image',\n      nexmo_api_url: 'https://api-us.vonage.com',\n      path: '/v2/rtc',\n      repository: 'https://github.com/Nexmo/conversation-js-sdk',\n      SDK_version: '9.1.6-beta2',\n      socket_io: {\n        reconnection: true,\n        reconnectionAttempts: 5,\n        reconnectionDelay: 2000,\n        randomizationFactor: 0.75,\n        reconnectionDelayMax: 15000,\n        forceNew: true,\n        autoConnect: true,\n        transports: ['websocket']\n      },\n      sync: 'none',\n      url: 'https://ws-us.vonage.com',\n      iceServers: [{\n        urls: 'stun:stun.l.google.com:19302'\n      }],\n      rtcstats: {\n        remote_collection: true,\n        remote_collection_url: 'https://hlg.tokbox.com/prod/logging/nexmo_client_js_stats',\n        remote_collection_interval: 5000,\n        emit_events: false,\n        emit_rtc_analytics: false,\n        emit_interval: 1000\n      },\n      conversations_page_config: {\n        page_size: 10,\n        order: 'asc',\n        cursor: ''\n      },\n      events_page_config: {\n        page_size: 10,\n        order: 'asc',\n        event_type: ''\n      },\n      enableEventsQueue: true,\n      enableInboundOffer: false,\n      token: null\n    };\n    this.config.socket_io.query = {\n      token: '',\n      SDK_version: this.config.SDK_version,\n      session_version: '0.0.2',\n      OS_family: 'js',\n      OS_revision: typeof navigator !== 'undefined' ? navigator.userAgent : typeof window !== 'undefined' ? window.navigator.userAgent : 'Generic JS navigator'\n    };\n    this.sessionReady = false;\n    this.session_id = null;\n    this.apiKey = null;\n    this.requests = {};\n    this.application = null;\n    /*\n      Definitions of log levels\n      error: major error messages, some lost functionality\n      warn: error messages which do not cause a functional failure\n      info: informational messages, showing completion, progress, etc.\n      debug: messages to help in diagnosing a problem\n    */\n    if (['debug', 'info', 'warn', 'error'].includes(inputParams.debug)) {\n      loglevel_1.default.setLevel(inputParams.debug);\n    } else if (inputParams.debug === true) {\n      loglevel_1.default.setLevel('debug');\n    } else {\n      loglevel_1.default.setLevel('silent');\n    }\n    this.log = loglevel_1.default.noConflict();\n    // set our config from the inputParams\n    this.config = utils_1.default.deepMergeObj(this.config, this._sanitizeConfig(inputParams));\n    // inject bug reporting tool\n    if (this.config.log_reporter.enabled) {\n      const bugsnagConfig = {\n        apiKey: this.config.log_reporter.bugsnag_key || utils_1.default._getBugsnagKey(),\n        appVersion: this.config.socket_io.query.SDK_version,\n        releaseStage: this.config.environment\n      };\n      global.NXMbugsnagClient = js_1.default(bugsnagConfig);\n    }\n    WildEmitter.mixin(NexmoClient);\n  }\n  /**\n   * Creates and sets the socket_io connection\n   *\n   * @private\n  */\n  _createAndSetConnection() {\n    let connection;\n    // Create the socket.io connection and allow multiple instances\n    let socket_io_config = Object.assign({\n      path: this.config.path\n    }, this.config.socket_io);\n    connection = socket_io_client_1.default.connect(this.config.url, socket_io_config);\n    this.connection = connection;\n    /**\n     * Client listening for ready event.\n     *\n     * @event NexmoClient#ready\n     * @example <caption>Listen for websocket ready event </caption>\n     *     rtc.on(\"ready\", () => {\n     *      console.log(\"connection ready\");\n     *     });\n    */\n    connection.on('connect', () => {\n      this.emit('ready');\n      this.sessionReady = true;\n      this.log.info('websocket ready');\n    });\n    // Listen to socket.io events\n    /**\n     * Client listening for connecting event.\n     *\n     * @event NexmoClient#connecting\n     * @example <caption>Listen for websocket connecting event </caption>\n     *     rtc.on(\"connecting\", () => {\n     *      console.log(\"connecting\");\n     *     });\n    */\n    connection.on('connecting', () => {\n      this.emit('connecting');\n      this.log.info('websocket connecting');\n    });\n    /**\n     * Client listening for disconnect event.\n     *\n     * @event NexmoClient#disconnect\n     * @example <caption>Listen for websocket disconnect event </caption>\n     *     rtc.on(\"disconnect\", () => {\n     *      console.log(\"disconnect\");\n     *     });\n    */\n    connection.on('disconnect', reason => {\n      this.emit('disconnect', reason === \"io client disconnect\" ? NexmoClient.DISCONNECT_REASON.ClientDisconnected : reason === \"io server disconnect\" && this.session_id ? NexmoClient.DISCONNECT_REASON.TokenExpired : NexmoClient.DISCONNECT_REASON.ConnectionError);\n      this.log.info('websocket disconnected');\n    });\n    /**\n     * Client listening for reconnect event.\n     *\n     * @event NexmoClient#reconnect\n     * @example <caption>Listen for websocket reconnect event </caption>\n     *     rtc.on(\"reconnect\", (retry_number) => {\n     *      console.log(\"reconnect\", retry_number);\n     *     });\n    */\n    connection.on('reconnect', retry_number => {\n      this.emit('reconnect', retry_number);\n      this.log.info('websocket reconnect');\n    });\n    /**\n     * Client listening for reconnecting event.\n     *\n     * @event NexmoClient#reconnecting\n     * @example <caption>Listen for websocket reconnecting event </caption>\n     *     rtc.on(\"reconnecting\", (retry_number): void => {\n     *      console.log(\"reconnecting\", retry_number);\n     *     });\n    */\n    connection.on('reconnecting', retry_number => {\n      this.emit('reconnecting', retry_number);\n      this.log.info('websocket reconnecting');\n    });\n    /**\n     * Client listening for error event.\n     *\n     * @event NexmoClient#error\n     * @example <caption>Listen for websocket error event </caption>\n     *     rtc.on(\"error\", (error) => {\n     *      console.log(\"error\", error);\n     *     });\n    */\n    connection.on('error', error => {\n      this.emit('error', new nexmoClientError_1.NexmoClientError(error));\n      this.log.error('Socket.io reported a generic error', error);\n    });\n    connection.on(\"reconnect_failed\", () => {\n      this.emit('error', new nexmoClientError_1.NexmoClientError(\"error:client:reconnection_failed\"));\n      this.log.error('websocket Reconnection error');\n    });\n    connection.io.on('packet', packet => {\n      if (packet.type !== 2) return;\n      if (packet.data[0] === 'echo') return; // ignore echo events\n      const response = packet.data[1];\n      // Set the type of the response\n      response.type = packet.data[0];\n      this.log.debug('<--', response.type, response);\n      if (this.requests['session:login']) {\n        const callback = this.requests['session:login'].callback;\n        delete this.requests['session:login'];\n        callback(response);\n      } else if (response.rid in this.requests) {\n        const callback = this.requests[response.rid].callback;\n        delete this.requests[response.rid];\n        delete response.delay;\n        if (this.errorsEmitter) {\n          this.errorsEmitter.emitResponseIfError(response);\n        }\n        callback(response);\n      } else {\n        // This is an unsolicited event we emit it in application level\n        // Excluding session:* events from being processed and check if event type is a system:error:* one\n        if (this.errorsEmitter && response.type.startsWith('system:error:')) {\n          this.errorsEmitter.emitResponseIfError(response);\n        } else if (response.type.startsWith('session:')) {\n          // Handle Events emitted from Reconnection\n          this.updateSession(response);\n        } else if (this.application) {\n          this.application._enqueueEvent(response);\n        }\n      }\n    });\n    return connection;\n  }\n  /**\n   * Revert any invalid params to our default\n   *\n   * @param {object} config the object to sanitize\n   * @private\n  */\n  _sanitizeConfig(incomingConfig) {\n    // make sure we allow specific values for the params\n    // Sync\n    let sanitizedConfig = incomingConfig;\n    if (incomingConfig.sync && ['none', 'lite', 'full'].indexOf(incomingConfig.sync) === -1) {\n      this.log.warn(`invalid param '${incomingConfig.sync}' for sync, reverting to ${this.config.sync}`);\n      sanitizedConfig.sync = this.config.sync;\n    }\n    return sanitizedConfig;\n  }\n  /**\n   * Conversation listening for text events.\n   *\n   * @event Conversation#text\n   *\n   * @property {Member} sender - The sender of the text\n   * @property {TextEvent} text - The text message received\n   * @example <caption>listen for text events</caption>\n   *  conversation.on(\"text\",(sender, message) => {\n   *    console.log(sender, message);\n   *    // Identify your own message.\n   *    if (message.from === conversation.me.id){\n   *        renderMyMessages(message)\n   *    } else {\n   *        renderOtherMessages(message)\n   *    }\n   *  });\n   */\n  /**\n   *\n   * Conversation listening for image events.\n   *\n   * @event Conversation#image\n   *\n   * @property {Member} sender - The sender of the image\n   * @property {ImageEvent} image - The image message received\n   * @example <caption>listen for image events</caption>\n   *  conversation.on(\"image\", (sender, image) => {\n   *    console.log(sender,image);\n   *    // Identify if your own imageEvent or someone else's.\n   *    if (image.from !== conversation.me.id){\n   *        displayImages(image);\n   *    }\n   *  });\n   */\n  /**\n   * Conversation listening for deleted events.\n   *\n   * @event Conversation#event:delete\n   *\n   * @property {Member} member - the Member who deleted an event\n   * @property {NXMEvent} event - deleted event: event.id\n   * @example <caption>get details about the deleted event</caption>\n   * conversation.on(\"event:delete\", (member, event) => {\n   *  console.log(event.id);\n   *  console.log(event.body.timestamp.deleted);\n   * });\n   */\n  /**\n   * Conversation listening for new Members.\n   *\n   * @event Conversation#member:joined\n   *\n   * @property {Member} member - the Member that joined\n   * @property {NXMEvent} event - the join event\n   * @example <caption>get the name of the new Member</caption>\n   * conversation.on(\"member:joined\", (member, event) => {\n   *  console.log(event.id)\n   *  console.log(member.userName+ \" joined the conversation\");\n   * });\n   */\n  /**\n   * Conversation listening for Members being invited.\n   *\n   * @event Conversation#member:invited\n   *\n   * @property {Member} member - the Member that is invited\n   * @property {NXMEvent} event - data regarding the receiver of the invitation\n   * @example <caption>get the name of the invited Member</caption>\n   * conversation.on(\"member:invited\", (member, event) => {\n   *  console.log(member.userName + \" invited to the conversation\");\n   * });\n   */\n  /**\n   * Conversation listening for Members callStatus changes.\n   *\n   * @event Conversation#member:call:status\n   *\n   * @property {Member} member - the Member that has left\n   * @example <caption>get the callStatus of the member that changed call status</caption>\n   * conversation.on(\"member:call:status\", (member) => {\n   *  console.log(member.callStatus);\n   * });\n   */\n  /**\n   * Conversation listening for Members leaving (kicked or left).\n   *\n   * @event Conversation#member:left\n   *\n   * @property {Member} member - the Member that has left\n   * @property {NXMEvent} event - data regarding the receiver of the invitation\n   * @example <caption>get the username of the Member that left</caption>\n   * conversation.on(\"member:left\", (member , event) => {\n   *  console.log(member.userName + \" left\");\n   *  console.log(event.body.reason);\n   * });\n   */\n  /**\n   * Conversation listening for Members typing.\n   *\n   * @event Conversation#text:typing:on\n   *\n   * @property {Member} member - the member that started typing\n   * @property {NXMEvent} event - the start typing event\n   * @example <caption>get the display name of the Member that is typing</caption>\n   * conversation.on(\"text:typing:on\", (member, event) => {\n   *  console.log(member.displayName + \" is typing...\");\n   * });\n   */\n  /**\n   * Conversation listening for Members stopped typing.\n   *\n   * @event Conversation#text:typing:off\n   *\n   * @property {Member} member - the member that stopped typing\n   * @property {NXMEvent} event - the stop typing event\n   * @example <caption>get the display name of the Member that stopped typing</caption>\n   * conversation.on(\"text:typing:off\", (member, event) => {\n   *  console.log(member.displayName + \" stopped typing...\");\n   * });\n   */\n  /**\n   * Conversation listening for Members' seen texts.\n   *\n   * @event Conversation#text:seen\n   *\n   * @property {Member} member - the Member that saw the text\n   * @property {TextEvent} text - the text that was seen\n   * @example <caption>listen for seen text events</caption>\n   * conversation.on(\"text:seen\", (member, text) => {\n   *  console.log(text);\n   *  if (conversation.me.id !== member.memberId) {\n   *    console.log(member);\n   *  }\n   * });\n   */\n  /**\n   * Conversation listening for Members' seen images.\n   * @event Conversation#image:seen\n   *\n   * @property {Member} member - the member that saw the image\n   * @property {ImageEvent} image - the image that was seen\n   * @example <caption>listen for seen image events</caption>\n   * conversation.on(\"image:seen\", (member, image) => {\n   *  console.log(image);\n   *  if (conversation.me.id !== member.memberId) {\n   *    console.log(member);\n   *  };\n   * });\n   */\n  /**\n   * Conversation listening for Members submitted messages.\n   * @event Conversation#message:submitted\n   *\n   * @property {Member} member - the member that message was submitted to\n   * @property {MessageEvent} message - the message that was submitted\n   * @example <caption>listen for submitted message events</caption>\n   * conversation.on(\"message:submitted\", (member, message) => {\n   *  console.log(message);\n   *  if (conversation.me.id !== member.memberId) {\n   *    console.log(member);\n   *  };\n   * });\n   */\n  /**\n   * Conversation listening for Members rejected messages.\n   * @event Conversation#message:rejected\n   *\n   * @property {Member} member - the member that message was rejected by\n   * @property {MessageEvent} message - the message that was rejected\n   * @example <caption>listen for rejected message events</caption>\n   * conversation.on(\"message:rejected\", (member, message) => {\n   *  console.log(message);\n   *  if (conversation.me.id !== member.memberId) {\n   *    console.log(member);\n   *  };\n   * });\n   */\n  /**\n   * Conversation listening for Members undeliverable messages.\n   * @event Conversation#message:undeliverable\n   *\n   * @property {Member} member - the member that message was undeliverable to\n   * @property {MessageEvent} message - the message that was undeliverable\n   * @example <caption>listen for undeliverable message events</caption>\n   * conversation.on(\"message:undeliverable\", (member, message) => {\n   *  console.log(message);\n   *  if (conversation.me.id !== member.memberId) {\n   *    console.log(member);\n   *  };\n   * });\n   */\n  /**\n   * Conversation listening for Members delivered messages.\n   * @event Conversation#message:delivered\n   *\n   * @property {Member} member - the member that message was delivered to\n   * @property {MessageEvent} message - the message that was delivered\n   * @example <caption>listen for delivered message events</caption>\n   * conversation.on(\"message:delivered\", (member, message) => {\n   *  console.log(message);\n   *  if (conversation.me.id !== member.memberId) {\n   *    console.log(member);\n   *  };\n   * });\n   */\n  /**\n   * Conversation listening for Members seen messages.\n   * @event Conversation#message:seen\n   *\n   * @property {Member} member - the member that message was seen by\n   * @property {MessageEvent} message - the message that was seen\n   * @example <caption>listen for seen message events</caption>\n   * conversation.on(\"message:seen\", (member, message) => {\n   *  console.log(message);\n   *  if (conversation.me.id !== member.memberId) {\n   *    console.log(member);\n   *  };\n   * });\n   */\n  /**\n   * Conversation listening for Members media changes (audio,text)\n   *\n   * Change in media presence state. They are in the Conversation with text or audio.\n   *\n   * @event Conversation#member:media\n   *\n   * @property {Member} member - the Member object linked to this event\n   * @property {NXMEvent} event - information about media presence state\n   * @property {boolean} event.body.audio  - is audio enabled\n   * @example <caption>get every Member's media change events </caption>\n   * conversation.on(\"member:media\", (member, event) => {\n   *  console.log(event.body.media); //{\"audio\": true, \"audio_settings\": {\"enabled\": true, \"muted\": false, \"earmuffed\": false}}\n   * });\n   */\n  /**\n   * Conversation listening for mute on events\n   * A Member has muted their audio\n   *\n   * @event Conversation#audio:mute:on\n   *\n   * @property {Member} member - the Member object linked to this event\n   * @property {NXMEvent} event - information about the mute event\n   * @example <caption>listen for audio mute on events </caption>\n   * conversation.on(\"audio:mute:on\", (member, event) => {\n   *  console.log(\"member that is muted \", member);\n   *  console.log(event);\n   * });\n   */\n  /**\n   * Conversation listening for mute off events\n   * A member has unmuted their audio\n   *\n   * @event Conversation#audio:mute:off\n   *\n   * @property {Member} member - the member object linked to this event\n   * @property {NXMEvent} event - information about the mute event\n   * @example <caption>listen for audio mute off events </caption>\n   * conversation.on(\"audio:mute:off\", (member, event) => {\n   *  console.log(\"member that is unmuted \", member);\n   *  console.log(event);\n   * });\n   */\n  sendRequest(request, callback) {\n    // Add a message ID to the request and set up a listener for the reply (or error)\n    request.tid = utils_1.default.allocateUUID();\n    const type = request.type;\n    delete request.type;\n    this.log.debug('-->', type, request);\n    this.log.info('-->', type, request.tid);\n    this.connection.emit(type, request);\n    this.requests[request.tid] = {\n      type: type,\n      request,\n      callback\n    };\n  }\n  async sendNetworkRequest(params) {\n    const version = params.version || 'beta';\n    const url = `${this.config.nexmo_api_url}/${version}/${params.path}`;\n    if (!(params.type === 'GET' || params.type === 'DELETE')) {\n      if (params.data) {\n        params.data.originating_session = this.session_id;\n      } else {\n        params.data = {\n          originating_session: this.session_id\n        };\n      }\n    }\n    try {\n      const request = {\n        type: params.type,\n        url,\n        data: params.data ? params.data : null,\n        token: (params.data || {}).token ? params.data.token : this.config.token || null\n      };\n      this.log.debug('sendNetworkRequest: ', {\n        request\n      });\n      const {\n        response\n      } = await utils_1.default.networkRequest(request);\n      return response;\n    } catch ({\n      response\n    }) {\n      throw response;\n    }\n  }\n  /**\n   * Create a new Session.\n   * @param {string} token - the user JSON Web Token (JWT)\n   * @returns  {Promise<Application>} - the application logged in to\n   * @example <caption>Create a session and return the Application</caption>\n   *  rtc.createSession(token).then((application) => {\n   *    console.log(application);\n   *  }).catch((error) => {\n   *    console.log(error);\n   *  });\n  */\n  createSession(token) {\n    this.config.socket_io.query.token = token;\n    this._createAndSetConnection();\n    // return a promise for the application\n    return new Promise((resolve, reject) => {\n      this.log.info(`Client-SDK Version: ${this.config.SDK_version}`);\n      this.config.token = null;\n      this.requests['session:login'] = {\n        type: 'session:login',\n        callback: async response => {\n          if (response.type === 'session:success') {\n            this.session_id = response.body.id;\n            this.apiKey = response.body.api_key;\n            // Store token in config\n            this.config.token = token;\n            // adds the session id as a query parameter in order to\n            // connect to the same session in case of a reconnection\n            this.connection.io.opts.query = {\n              session_id: this.session_id,\n              token: this.config.token\n            };\n            if (!this.application || this.application.me && this.application.me.id !== response.body.user_id) {\n              this.application = new application_1.default(this, {});\n            }\n            if (!this.application.me) {\n              this.application.me = new user_1.default(this.application, {\n                id: response.body.user_id,\n                name: response.body.name\n              });\n            }\n            if (!this.errorsEmitter) {\n              this.errorsEmitter = new errors_emitter_1.default(this.application);\n            }\n            // Set Bugsnag user to application.me.id\n            if (this.config.log_reporter.enabled) {\n              global.NXMbugsnagClient.user = {\n                id: this.application.me.id,\n                name: this.application.me.name,\n                session_id: response.body.id\n              };\n            }\n            if (this.config.sync !== 'none') {\n              // Retrieve the existing conversation data for this user\n              try {\n                await this.application.getConversations();\n                resolve(this.application);\n              } catch (error) {\n                reject(error);\n              }\n            } else {\n              resolve(this.application);\n            }\n          } else {\n            reject(new nexmoClientError_1.NexmoApiError(response));\n          }\n        }\n      };\n    });\n  }\n  /**\n   * Delete existing Session.\n   * @returns  {Promise<CAPIResponse>} - response with rid and type\n   * @example <caption>Delete existing session</caption>\n   *  rtc.deleteSession().then((response) => {\n   *    console.log(response);\n   *  }).catch((error) => {\n   *    console.log(error);\n   *  });\n  */\n  deleteSession() {\n    return new Promise(async (resolve, reject) => {\n      const logoutRequest = () => {\n        return this.sendRequest({\n          type: 'session:logout',\n          body: {}\n        }, response => {\n          if (response.type === 'session:logged-out' || response.type === 'session:terminated') {\n            this.disconnect();\n            delete this.errorsEmitter;\n            delete this.application;\n            delete this.connection;\n            this.requests = {};\n            this.sessionReady = false;\n            resolve(response);\n          } else {\n            reject(response);\n          }\n        });\n      };\n      // prepare for deleteSession\n      if (this.application) {\n        let disablePromises = [];\n        if (this.application.conversations.size) {\n          for (let conversation of this.application.conversations.values()) {\n            disablePromises.push(conversation.media.disable());\n          }\n        }\n        try {\n          await Promise.all(disablePromises);\n        } catch (error) {\n          this.log.error(\"deleteSession: \", error);\n        }\n        return logoutRequest();\n      } else {\n        return logoutRequest();\n      }\n    });\n  }\n  updateSession(event) {\n    if (event.type === 'session:success') {\n      this.session_id = event.body.id;\n      this.connection.io.opts.query.session_id = event.body.id;\n    }\n  }\n  /**\n   * Disconnect from the cloud.\n   *\n  */\n  disconnect() {\n    return this.connection.disconnect();\n  }\n  /**\n   * Connect to the cloud.\n   *\n  */\n  connect() {\n    return this.connection.connect();\n  }\n  /**\n     * Get a connectivity report for all Vonage DCs and Media Servers.\n   * @param {string} token - the JSON Web Token (JWT)\n   * @param {object} options - configure the connectivityReport\n   * @param {Function} options.dcListCallback - a callback function to edit the list of datacenters before connectivity checks\n     * @returns  {Promise<Report>}\n     * @example <caption>Get a connectivity report</caption>\n   *\n     *  rtc.connectivityReport(token, {\n   *    dcListCallback: (dcList) => {...dcList, additionalDc}\n   *  }).then((report) => {\n   *    console.log(report);\n   *  }).catch((error) => {\n   *    console.log(error);\n   *  });\n  */\n  async connectivityReport(token, options) {\n    var _a;\n    const ip = !rtc_helper_1.default.isNode() ? await publicip_1.default.v4() : undefined;\n    const report = {\n      machineInfo: {\n        ip\n      },\n      connectivityReport: []\n    };\n    try {\n      const {\n        response\n      } = await utils_1.default.networkRequest({\n        type: 'GET',\n        url: `${this.config.nexmo_api_url}/v0.3/discovery/api`,\n        token\n      });\n      let dcList = response;\n      if ((_a = options) === null || _a === void 0 ? void 0 : _a.dcListCallback) {\n        dcList = options.dcListCallback(dcList);\n      }\n      for (const dc in dcList) {\n        const endpoint = dcList[dc].endpoint;\n        const apiUrl = dcList[dc].https;\n        const wsUrl = dcList[dc].ws;\n        try {\n          const httpRes = await utils_1.default._checkHttpConnectivity(apiUrl);\n          const wsRes = await utils_1.default._checkWsConnectivity(wsUrl, this.config.path, this.config.socket_io);\n          const mediaConnectionReport = await utils_1.default._checkMediaServers(token, endpoint, dc);\n          const rep = {\n            name: dc,\n            signalConnectionReport: {\n              https: httpRes,\n              ws: wsRes\n            },\n            mediaConnectionReport\n          };\n          report.connectivityReport.push(rep);\n        } catch (error) {\n          this.log.error(`Error generating report for ${dc}`, error);\n        }\n      }\n    } catch (error) {\n      this.log.error(`Error fetching nexmo servers information`, error);\n    }\n    return report;\n  }\n  /**\n    * Return a list with the connection health of the media servers for a specific datacenter.\n    * @returns  {Promise<MediaConnectionReport[]>}\n  * @param {string} token - the JSON Web Token (JWT)\n  * @param {string} nexmo_api_url - url of the nexmo api to be called\n  * @param {string} datacenter - datacenter of interest\n    * @example <caption>Return a list with the connection health of the media servers</caption>\n  *\n    *  rtc.checkMediaServers('nexmo-api-url','dc').then((responseArray) => {\n    *    console.log(responseArray);\n    *  }).catch((error) => {\n    *    console.log(error);\n    *  });\n   */\n  async checkMediaServers(token, nexmo_api_url, datacenter) {\n    return await utils_1.default._checkMediaServers(token, nexmo_api_url, datacenter);\n  }\n  /**\n  * Return the connection health of a single media server including possible connectionTime in ms.\n  * @returns  {Promise<MediaConnectionReport>}\n  * @param {string} ip - ip address of the Media Server\n  * @param {string} port - port number of the Media Server\n  * @example <caption>Return the connection health of a single media server</caption>\n  *\n  *  rtc.checkMediaConnectivity('ip-address','1').then((response) => {\n  *    console.log(`IP Address of media server: ${response.ip}`);\n  *    console.log(`Able to connect: ${response.canConnect}`);\n  *    console.log(`ConnectionTime in ms: ${resonse.connectionTime}`);\n  *  }).catch((error) => {\n  *    console.log(error);\n  *  });\n  */\n  async checkMediaConnectivity(ip, port) {\n    return await utils_1.default._checkMediaConnectivity(ip, port);\n  }\n}\nexports.default = NexmoClient;\n/**\n * Enum for NexmoClient disconnection reason.\n * @readonly\n * @enum {string}\n * @alias NexmoClient.DISCONNECT_REASON\n*/\nNexmoClient.DISCONNECT_REASON = {\n  ClientDisconnected: 'ClientDisconnected',\n  TokenExpired: 'TokenExpired',\n  ConnectionError: 'ConnectionError'\n};\nmodule.exports = NexmoClient;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","WildEmitter","require","loglevel_plugin_prefix_1","loglevel_1","nexmoClientError_1","socket_io_client_1","js_1","publicip_1","utils_1","application_1","errors_emitter_1","user_1","rtc_helper_1","default","reg","apply","template","timestampFormatter","date","toTimeString","replace","levelFormatter","level","toUpperCase","nameFormatter","name","NexmoClient","constructor","params","inputParams","config","debug","log_reporter","enabled","bugsnag_key","environment","ips_url","nexmo_api_url","path","repository","SDK_version","socket_io","reconnection","reconnectionAttempts","reconnectionDelay","randomizationFactor","reconnectionDelayMax","forceNew","autoConnect","transports","sync","url","iceServers","urls","rtcstats","remote_collection","remote_collection_url","remote_collection_interval","emit_events","emit_rtc_analytics","emit_interval","conversations_page_config","page_size","order","cursor","events_page_config","event_type","enableEventsQueue","enableInboundOffer","token","query","session_version","OS_family","OS_revision","navigator","userAgent","window","sessionReady","session_id","apiKey","requests","application","includes","setLevel","log","noConflict","deepMergeObj","_sanitizeConfig","bugsnagConfig","_getBugsnagKey","appVersion","releaseStage","global","NXMbugsnagClient","mixin","_createAndSetConnection","connection","socket_io_config","assign","connect","on","emit","info","reason","DISCONNECT_REASON","ClientDisconnected","TokenExpired","ConnectionError","retry_number","error","NexmoClientError","io","packet","type","data","response","callback","rid","delay","errorsEmitter","emitResponseIfError","startsWith","updateSession","_enqueueEvent","incomingConfig","sanitizedConfig","indexOf","warn","sendRequest","request","tid","allocateUUID","sendNetworkRequest","version","originating_session","networkRequest","createSession","Promise","resolve","reject","body","id","api_key","opts","me","user_id","user","getConversations","NexmoApiError","deleteSession","logoutRequest","disconnect","disablePromises","conversations","size","conversation","values","push","media","disable","all","event","connectivityReport","options","_a","ip","isNode","v4","undefined","report","machineInfo","dcList","dcListCallback","dc","endpoint","apiUrl","https","wsUrl","ws","httpRes","_checkHttpConnectivity","wsRes","_checkWsConnectivity","mediaConnectionReport","_checkMediaServers","rep","signalConnectionReport","checkMediaServers","datacenter","checkMediaConnectivity","port","_checkMediaConnectivity","module"],"sources":["/Users/vineetkhodre/react-workspace/thoughtctlchatapp/client/node_modules/nexmo-client/dist/sdk.js"],"sourcesContent":["'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  Main wrapper\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst WildEmitter = require('wildemitter');\nconst loglevel_plugin_prefix_1 = __importDefault(require(\"loglevel-plugin-prefix\"));\nconst loglevel_1 = __importDefault(require(\"loglevel\"));\nconst nexmoClientError_1 = require(\"./nexmoClientError\");\nconst socket_io_client_1 = __importDefault(require(\"socket.io-client\"));\nconst js_1 = __importDefault(require(\"@bugsnag/js\"));\nconst publicip_1 = __importDefault(require(\"./modules/publicip\"));\nconst utils_1 = __importDefault(require(\"./utils\"));\nconst application_1 = __importDefault(require(\"./application\"));\nconst errors_emitter_1 = __importDefault(require(\"./modules/errors_emitter\"));\nconst user_1 = __importDefault(require(\"./user\"));\nconst rtc_helper_1 = __importDefault(require(\"./modules/rtc_helper\"));\nloglevel_plugin_prefix_1.default.reg(loglevel_1.default);\nloglevel_plugin_prefix_1.default.apply(loglevel_1.default, {\n    template: '[%t] %l (NXM-%n):',\n    timestampFormatter: (date) => {\n        return date.toTimeString().replace(/.*(\\d{2}:\\d{2}:\\d{2}).*/, '$1');\n    },\n    levelFormatter: (level) => {\n        return level.toUpperCase();\n    },\n    nameFormatter: (name) => {\n        return name || 'SDK';\n    }\n});\n/**\n * The parent NexmoClient class.\n *\n * @class NexmoClient\n *\n * @param {object} params the settings to initialise the SDK\n * @param {string} params.debug='silent' set mode to 'debug', 'info', 'warn', or 'error' for customized logging levels in the console\n * @param {string} params.url='nexmo_ws_url' Nexmo Conversation Websocket url, default is wss://ws.nexmo.com (wss://ws-us-1.nexmo.com for WDC, wss://ws-us-2.nexmo.com for DAL, wss://ws-eu-1.nexmo.com for LON, wss://ws-sg-1.nexmo.com for SNG)\n * @param {string} params.nexmo_api_url=Nexmo Conversation Api url, default is https://api.nexmo.com (https://api-us-1.nexmo.com for WDC, https://api-us-2.nexmo.com for DAL, https://api-eu-1.nexmo.com for LON, https://api-sg-1.nexmo.com for SNG)\n * @param {string} params.ips_url='ips_url' Nexmo IPS url for image upload, default is https://api.nexmo.com/v1/image (https://api-us-1.nexmo.com/v1/image for WDC, https://api-us-2.nexmo.com/v1/image for DAL, https://api-eu-1.nexmo.com/v1/image for LON, https://api-sg-1.nexmo.com/v1/image for SNG)\n * @param {string} params.path='/v2/rtc' Nexmo Conversation Websocket url path suffix\n * @param {RTCStatsConfig} params.rtcstats set reporting for stream statistics (Internal event emit)\n * @param {Boolean} params.rtcstats.emit_events=false receive rtcstats:report event (deprecated)\n * @param {Boolean} params.rtcstats.emit_rtc_analytics=false receive rtcstats:analytics event\n * @param {number} params.rtcstats.emit_interval=1000 interval in ms for rtcstats:report and rtcstats:analytics\n * @param {Boolean} params.rtcstats.remote_collection=true collect client logs internally\n * @param {Boolean} params.rtcstats.remote_collection_url='gollum_url' url for collecting client logs internally\n * @param {number} params.rtcstats.remote_collection_interval=5000 interval in ms to collect client logs internally\n * @param {object} params.socket_io configure socket.io\n * @param {Boolean} params.socket_io.forceNew=true configure socket.io forceNew attribute\n * @param {Boolean} params.socket_io.autoConnect=true socket.io autoConnect attribute\n * @param {Boolean} params.socket_io.reconnection=true socket.io reconnection attribute\n * @param {number} params.socket_io.reconnectionAttempts=5 socket.io reconnectionAttempts attribute\n * @param {string[]} params.socket_io.transports='websocket' socket.io transports protocols\n * @param {string} params.sync='none' {'none' || 'lite' || 'full'} after a successful session creation, synchronise conversations, include events or nothing\n * @param {string} params.environment='production' development / production environment\n * @param {object[]} params.iceServers configure iceServers for RTCPeerConnection\n * @param {string} params.iceServers.urls='stun:stun.l.google.com:19302' urls for iceServers\n * @param {object} params.log_reporter configure log reports for bugsnag tool\n * @param {Boolean} params.log_reporter.enabled=true\n * @param {string} params.log_reporter.bugsnag_key your bugsnag api key / defaults to Nexmo api key\n * @param {object} params.conversations_page_config configure paginated requests for conversations\n * @param {number} params.conversations_page_config.page_size=10 the number of resources returned in a single request list\n * @param {string} params.conversations_page_config.order=asc 'asc' or 'desc' ordering of resources (usually based on creation time)\n * @param {string} params.conversations_page_config.cursor cursor parameter to access the next or previous page of a data set\n * @param {object} params.events_page_config configure paginated requests for events\n * @param {number} params.events_page_config.page_size=10 the number of resources returned in a single request list\n * @param {string} params.events_page_config.order=asc 'asc' or 'desc' ordering of resources (usually based on creation time)\n * @param {string} params.events_page_config.event_type the type of event used to filter event requests. Supports wildcard options with :* eg. 'members:*'\n * @param {Boolean} params.enableEventsQueue=true mechanism to guarantee order of events received during a session\n * @param {string} params.token the jwt token for network requests\n *\n * @emits NexmoClient#connecting\n * @emits NexmoClient#disconnect\n * @emits NexmoClient#error\n * @emits NexmoClient#ready\n * @emits NexmoClient#reconnect\n * @emits NexmoClient#reconnecting\n*/\nclass NexmoClient {\n    constructor(params = {}) {\n        // save an array of instances\n        const inputParams = params;\n        this.config = {\n            debug: 'silent',\n            log_reporter: {\n                enabled: false,\n                bugsnag_key: null\n            },\n            environment: 'production',\n            ips_url: 'https://api-us.vonage.com/v1/image',\n            nexmo_api_url: 'https://api-us.vonage.com',\n            path: '/v2/rtc',\n            repository: 'https://github.com/Nexmo/conversation-js-sdk',\n            SDK_version: '9.1.6-beta2',\n            socket_io: {\n                reconnection: true,\n                reconnectionAttempts: 5,\n                reconnectionDelay: 2000,\n                randomizationFactor: 0.75,\n                reconnectionDelayMax: 15000,\n                forceNew: true,\n                autoConnect: true,\n                transports: ['websocket']\n            },\n            sync: 'none',\n            url: 'https://ws-us.vonage.com',\n            iceServers: [{\n                    urls: 'stun:stun.l.google.com:19302'\n                }],\n            rtcstats: {\n                remote_collection: true,\n                remote_collection_url: 'https://hlg.tokbox.com/prod/logging/nexmo_client_js_stats',\n                remote_collection_interval: 5000,\n                emit_events: false,\n                emit_rtc_analytics: false,\n                emit_interval: 1000,\n            },\n            conversations_page_config: {\n                page_size: 10,\n                order: 'asc',\n                cursor: ''\n            },\n            events_page_config: {\n                page_size: 10,\n                order: 'asc',\n                event_type: ''\n            },\n            enableEventsQueue: true,\n            enableInboundOffer: false,\n            token: null\n        };\n        this.config.socket_io.query = {\n            token: '',\n            SDK_version: this.config.SDK_version,\n            session_version: '0.0.2',\n            OS_family: 'js',\n            OS_revision: (typeof navigator !== 'undefined') ? navigator.userAgent : (typeof window !== 'undefined') ? window.navigator.userAgent : 'Generic JS navigator'\n        };\n        this.sessionReady = false;\n        this.session_id = null;\n        this.apiKey = null;\n        this.requests = {};\n        this.application = null;\n        /*\n          Definitions of log levels\n          error: major error messages, some lost functionality\n          warn: error messages which do not cause a functional failure\n          info: informational messages, showing completion, progress, etc.\n          debug: messages to help in diagnosing a problem\n        */\n        if (['debug', 'info', 'warn', 'error'].includes(inputParams.debug)) {\n            loglevel_1.default.setLevel(inputParams.debug);\n        }\n        else if (inputParams.debug === true) {\n            loglevel_1.default.setLevel('debug');\n        }\n        else {\n            loglevel_1.default.setLevel('silent');\n        }\n        this.log = loglevel_1.default.noConflict();\n        // set our config from the inputParams\n        this.config = utils_1.default.deepMergeObj(this.config, this._sanitizeConfig(inputParams));\n        // inject bug reporting tool\n        if (this.config.log_reporter.enabled) {\n            const bugsnagConfig = {\n                apiKey: this.config.log_reporter.bugsnag_key || utils_1.default._getBugsnagKey(),\n                appVersion: this.config.socket_io.query.SDK_version,\n                releaseStage: this.config.environment\n            };\n            global.NXMbugsnagClient = js_1.default(bugsnagConfig);\n        }\n        WildEmitter.mixin(NexmoClient);\n    }\n    /**\n     * Creates and sets the socket_io connection\n     *\n     * @private\n    */\n    _createAndSetConnection() {\n        let connection;\n        // Create the socket.io connection and allow multiple instances\n        let socket_io_config = Object.assign({ path: this.config.path }, this.config.socket_io);\n        connection = socket_io_client_1.default.connect(this.config.url, socket_io_config);\n        this.connection = connection;\n        /**\n         * Client listening for ready event.\n         *\n         * @event NexmoClient#ready\n         * @example <caption>Listen for websocket ready event </caption>\n         *     rtc.on(\"ready\", () => {\n         *      console.log(\"connection ready\");\n         *     });\n        */\n        connection.on('connect', () => {\n            this.emit('ready');\n            this.sessionReady = true;\n            this.log.info('websocket ready');\n        });\n        // Listen to socket.io events\n        /**\n         * Client listening for connecting event.\n         *\n         * @event NexmoClient#connecting\n         * @example <caption>Listen for websocket connecting event </caption>\n         *     rtc.on(\"connecting\", () => {\n         *      console.log(\"connecting\");\n         *     });\n        */\n        connection.on('connecting', () => {\n            this.emit('connecting');\n            this.log.info('websocket connecting');\n        });\n        /**\n         * Client listening for disconnect event.\n         *\n         * @event NexmoClient#disconnect\n         * @example <caption>Listen for websocket disconnect event </caption>\n         *     rtc.on(\"disconnect\", () => {\n         *      console.log(\"disconnect\");\n         *     });\n        */\n        connection.on('disconnect', (reason) => {\n            this.emit('disconnect', (reason === \"io client disconnect\")\n                ? NexmoClient.DISCONNECT_REASON.ClientDisconnected\n                : (reason === \"io server disconnect\" && this.session_id) ? NexmoClient.DISCONNECT_REASON.TokenExpired\n                    : NexmoClient.DISCONNECT_REASON.ConnectionError);\n            this.log.info('websocket disconnected');\n        });\n        /**\n         * Client listening for reconnect event.\n         *\n         * @event NexmoClient#reconnect\n         * @example <caption>Listen for websocket reconnect event </caption>\n         *     rtc.on(\"reconnect\", (retry_number) => {\n         *      console.log(\"reconnect\", retry_number);\n         *     });\n        */\n        connection.on('reconnect', (retry_number) => {\n            this.emit('reconnect', retry_number);\n            this.log.info('websocket reconnect');\n        });\n        /**\n         * Client listening for reconnecting event.\n         *\n         * @event NexmoClient#reconnecting\n         * @example <caption>Listen for websocket reconnecting event </caption>\n         *     rtc.on(\"reconnecting\", (retry_number): void => {\n         *      console.log(\"reconnecting\", retry_number);\n         *     });\n        */\n        connection.on('reconnecting', (retry_number) => {\n            this.emit('reconnecting', retry_number);\n            this.log.info('websocket reconnecting');\n        });\n        /**\n         * Client listening for error event.\n         *\n         * @event NexmoClient#error\n         * @example <caption>Listen for websocket error event </caption>\n         *     rtc.on(\"error\", (error) => {\n         *      console.log(\"error\", error);\n         *     });\n        */\n        connection.on('error', (error) => {\n            this.emit('error', new nexmoClientError_1.NexmoClientError(error));\n            this.log.error('Socket.io reported a generic error', error);\n        });\n        connection.on(\"reconnect_failed\", () => {\n            this.emit('error', new nexmoClientError_1.NexmoClientError(\"error:client:reconnection_failed\"));\n            this.log.error('websocket Reconnection error');\n        });\n        connection.io.on('packet', (packet) => {\n            if (packet.type !== 2)\n                return;\n            if (packet.data[0] === 'echo')\n                return; // ignore echo events\n            const response = packet.data[1];\n            // Set the type of the response\n            response.type = packet.data[0];\n            this.log.debug('<--', response.type, response);\n            if (this.requests['session:login']) {\n                const callback = this.requests['session:login'].callback;\n                delete this.requests['session:login'];\n                callback(response);\n            }\n            else if (response.rid in this.requests) {\n                const callback = this.requests[response.rid].callback;\n                delete this.requests[response.rid];\n                delete response.delay;\n                if (this.errorsEmitter) {\n                    this.errorsEmitter.emitResponseIfError(response);\n                }\n                callback(response);\n            }\n            else {\n                // This is an unsolicited event we emit it in application level\n                // Excluding session:* events from being processed and check if event type is a system:error:* one\n                if (this.errorsEmitter && response.type.startsWith('system:error:')) {\n                    this.errorsEmitter.emitResponseIfError(response);\n                }\n                else if (response.type.startsWith('session:')) {\n                    // Handle Events emitted from Reconnection\n                    this.updateSession(response);\n                }\n                else if (this.application) {\n                    this.application._enqueueEvent(response);\n                }\n            }\n        });\n        return connection;\n    }\n    /**\n     * Revert any invalid params to our default\n     *\n     * @param {object} config the object to sanitize\n     * @private\n    */\n    _sanitizeConfig(incomingConfig) {\n        // make sure we allow specific values for the params\n        // Sync\n        let sanitizedConfig = incomingConfig;\n        if (incomingConfig.sync && ['none', 'lite', 'full'].indexOf(incomingConfig.sync) === -1) {\n            this.log.warn(`invalid param '${incomingConfig.sync}' for sync, reverting to ${this.config.sync}`);\n            sanitizedConfig.sync = this.config.sync;\n        }\n        return sanitizedConfig;\n    }\n    /**\n     * Conversation listening for text events.\n     *\n     * @event Conversation#text\n     *\n     * @property {Member} sender - The sender of the text\n     * @property {TextEvent} text - The text message received\n     * @example <caption>listen for text events</caption>\n     *  conversation.on(\"text\",(sender, message) => {\n     *    console.log(sender, message);\n     *    // Identify your own message.\n     *    if (message.from === conversation.me.id){\n     *        renderMyMessages(message)\n     *    } else {\n     *        renderOtherMessages(message)\n     *    }\n     *  });\n     */\n    /**\n     *\n     * Conversation listening for image events.\n     *\n     * @event Conversation#image\n     *\n     * @property {Member} sender - The sender of the image\n     * @property {ImageEvent} image - The image message received\n     * @example <caption>listen for image events</caption>\n     *  conversation.on(\"image\", (sender, image) => {\n     *    console.log(sender,image);\n     *    // Identify if your own imageEvent or someone else's.\n     *    if (image.from !== conversation.me.id){\n     *        displayImages(image);\n     *    }\n     *  });\n     */\n    /**\n     * Conversation listening for deleted events.\n     *\n     * @event Conversation#event:delete\n     *\n     * @property {Member} member - the Member who deleted an event\n     * @property {NXMEvent} event - deleted event: event.id\n     * @example <caption>get details about the deleted event</caption>\n     * conversation.on(\"event:delete\", (member, event) => {\n     *  console.log(event.id);\n     *  console.log(event.body.timestamp.deleted);\n     * });\n     */\n    /**\n     * Conversation listening for new Members.\n     *\n     * @event Conversation#member:joined\n     *\n     * @property {Member} member - the Member that joined\n     * @property {NXMEvent} event - the join event\n     * @example <caption>get the name of the new Member</caption>\n     * conversation.on(\"member:joined\", (member, event) => {\n     *  console.log(event.id)\n     *  console.log(member.userName+ \" joined the conversation\");\n     * });\n     */\n    /**\n     * Conversation listening for Members being invited.\n     *\n     * @event Conversation#member:invited\n     *\n     * @property {Member} member - the Member that is invited\n     * @property {NXMEvent} event - data regarding the receiver of the invitation\n     * @example <caption>get the name of the invited Member</caption>\n     * conversation.on(\"member:invited\", (member, event) => {\n     *  console.log(member.userName + \" invited to the conversation\");\n     * });\n     */\n    /**\n     * Conversation listening for Members callStatus changes.\n     *\n     * @event Conversation#member:call:status\n     *\n     * @property {Member} member - the Member that has left\n     * @example <caption>get the callStatus of the member that changed call status</caption>\n     * conversation.on(\"member:call:status\", (member) => {\n     *  console.log(member.callStatus);\n     * });\n     */\n    /**\n     * Conversation listening for Members leaving (kicked or left).\n     *\n     * @event Conversation#member:left\n     *\n     * @property {Member} member - the Member that has left\n     * @property {NXMEvent} event - data regarding the receiver of the invitation\n     * @example <caption>get the username of the Member that left</caption>\n     * conversation.on(\"member:left\", (member , event) => {\n     *  console.log(member.userName + \" left\");\n     *  console.log(event.body.reason);\n     * });\n     */\n    /**\n     * Conversation listening for Members typing.\n     *\n     * @event Conversation#text:typing:on\n     *\n     * @property {Member} member - the member that started typing\n     * @property {NXMEvent} event - the start typing event\n     * @example <caption>get the display name of the Member that is typing</caption>\n     * conversation.on(\"text:typing:on\", (member, event) => {\n     *  console.log(member.displayName + \" is typing...\");\n     * });\n     */\n    /**\n     * Conversation listening for Members stopped typing.\n     *\n     * @event Conversation#text:typing:off\n     *\n     * @property {Member} member - the member that stopped typing\n     * @property {NXMEvent} event - the stop typing event\n     * @example <caption>get the display name of the Member that stopped typing</caption>\n     * conversation.on(\"text:typing:off\", (member, event) => {\n     *  console.log(member.displayName + \" stopped typing...\");\n     * });\n     */\n    /**\n     * Conversation listening for Members' seen texts.\n     *\n     * @event Conversation#text:seen\n     *\n     * @property {Member} member - the Member that saw the text\n     * @property {TextEvent} text - the text that was seen\n     * @example <caption>listen for seen text events</caption>\n     * conversation.on(\"text:seen\", (member, text) => {\n     *  console.log(text);\n     *  if (conversation.me.id !== member.memberId) {\n     *    console.log(member);\n     *  }\n     * });\n     */\n    /**\n     * Conversation listening for Members' seen images.\n     * @event Conversation#image:seen\n     *\n     * @property {Member} member - the member that saw the image\n     * @property {ImageEvent} image - the image that was seen\n     * @example <caption>listen for seen image events</caption>\n     * conversation.on(\"image:seen\", (member, image) => {\n     *  console.log(image);\n     *  if (conversation.me.id !== member.memberId) {\n     *    console.log(member);\n     *  };\n     * });\n     */\n    /**\n     * Conversation listening for Members submitted messages.\n     * @event Conversation#message:submitted\n     *\n     * @property {Member} member - the member that message was submitted to\n     * @property {MessageEvent} message - the message that was submitted\n     * @example <caption>listen for submitted message events</caption>\n     * conversation.on(\"message:submitted\", (member, message) => {\n     *  console.log(message);\n     *  if (conversation.me.id !== member.memberId) {\n     *    console.log(member);\n     *  };\n     * });\n     */\n    /**\n     * Conversation listening for Members rejected messages.\n     * @event Conversation#message:rejected\n     *\n     * @property {Member} member - the member that message was rejected by\n     * @property {MessageEvent} message - the message that was rejected\n     * @example <caption>listen for rejected message events</caption>\n     * conversation.on(\"message:rejected\", (member, message) => {\n     *  console.log(message);\n     *  if (conversation.me.id !== member.memberId) {\n     *    console.log(member);\n     *  };\n     * });\n     */\n    /**\n     * Conversation listening for Members undeliverable messages.\n     * @event Conversation#message:undeliverable\n     *\n     * @property {Member} member - the member that message was undeliverable to\n     * @property {MessageEvent} message - the message that was undeliverable\n     * @example <caption>listen for undeliverable message events</caption>\n     * conversation.on(\"message:undeliverable\", (member, message) => {\n     *  console.log(message);\n     *  if (conversation.me.id !== member.memberId) {\n     *    console.log(member);\n     *  };\n     * });\n     */\n    /**\n     * Conversation listening for Members delivered messages.\n     * @event Conversation#message:delivered\n     *\n     * @property {Member} member - the member that message was delivered to\n     * @property {MessageEvent} message - the message that was delivered\n     * @example <caption>listen for delivered message events</caption>\n     * conversation.on(\"message:delivered\", (member, message) => {\n     *  console.log(message);\n     *  if (conversation.me.id !== member.memberId) {\n     *    console.log(member);\n     *  };\n     * });\n     */\n    /**\n     * Conversation listening for Members seen messages.\n     * @event Conversation#message:seen\n     *\n     * @property {Member} member - the member that message was seen by\n     * @property {MessageEvent} message - the message that was seen\n     * @example <caption>listen for seen message events</caption>\n     * conversation.on(\"message:seen\", (member, message) => {\n     *  console.log(message);\n     *  if (conversation.me.id !== member.memberId) {\n     *    console.log(member);\n     *  };\n     * });\n     */\n    /**\n     * Conversation listening for Members media changes (audio,text)\n     *\n     * Change in media presence state. They are in the Conversation with text or audio.\n     *\n     * @event Conversation#member:media\n     *\n     * @property {Member} member - the Member object linked to this event\n     * @property {NXMEvent} event - information about media presence state\n     * @property {boolean} event.body.audio  - is audio enabled\n     * @example <caption>get every Member's media change events </caption>\n     * conversation.on(\"member:media\", (member, event) => {\n     *  console.log(event.body.media); //{\"audio\": true, \"audio_settings\": {\"enabled\": true, \"muted\": false, \"earmuffed\": false}}\n     * });\n     */\n    /**\n     * Conversation listening for mute on events\n     * A Member has muted their audio\n     *\n     * @event Conversation#audio:mute:on\n     *\n     * @property {Member} member - the Member object linked to this event\n     * @property {NXMEvent} event - information about the mute event\n     * @example <caption>listen for audio mute on events </caption>\n     * conversation.on(\"audio:mute:on\", (member, event) => {\n     *  console.log(\"member that is muted \", member);\n     *  console.log(event);\n     * });\n     */\n    /**\n     * Conversation listening for mute off events\n     * A member has unmuted their audio\n     *\n     * @event Conversation#audio:mute:off\n     *\n     * @property {Member} member - the member object linked to this event\n     * @property {NXMEvent} event - information about the mute event\n     * @example <caption>listen for audio mute off events </caption>\n     * conversation.on(\"audio:mute:off\", (member, event) => {\n     *  console.log(\"member that is unmuted \", member);\n     *  console.log(event);\n     * });\n     */\n    sendRequest(request, callback) {\n        // Add a message ID to the request and set up a listener for the reply (or error)\n        request.tid = utils_1.default.allocateUUID();\n        const type = request.type;\n        delete request.type;\n        this.log.debug('-->', type, request);\n        this.log.info('-->', type, request.tid);\n        this.connection.emit(type, request);\n        this.requests[request.tid] = {\n            type: type,\n            request,\n            callback\n        };\n    }\n    async sendNetworkRequest(params) {\n        const version = params.version || 'beta';\n        const url = `${this.config.nexmo_api_url}/${version}/${params.path}`;\n        if (!(params.type === 'GET' || params.type === 'DELETE')) {\n            if (params.data) {\n                params.data.originating_session = this.session_id;\n            }\n            else {\n                params.data = {\n                    originating_session: this.session_id\n                };\n            }\n        }\n        try {\n            const request = {\n                type: params.type,\n                url,\n                data: (params.data) ? params.data : null,\n                token: (params.data || {}).token ? params.data.token : this.config.token || null\n            };\n            this.log.debug('sendNetworkRequest: ', { request });\n            const { response } = await utils_1.default.networkRequest(request);\n            return response;\n        }\n        catch ({ response }) {\n            throw response;\n        }\n    }\n    /**\n     * Create a new Session.\n     * @param {string} token - the user JSON Web Token (JWT)\n     * @returns  {Promise<Application>} - the application logged in to\n     * @example <caption>Create a session and return the Application</caption>\n     *  rtc.createSession(token).then((application) => {\n     *    console.log(application);\n     *  }).catch((error) => {\n     *    console.log(error);\n     *  });\n    */\n    createSession(token) {\n        this.config.socket_io.query.token = token;\n        this._createAndSetConnection();\n        // return a promise for the application\n        return new Promise((resolve, reject) => {\n            this.log.info(`Client-SDK Version: ${this.config.SDK_version}`);\n            this.config.token = null;\n            this.requests['session:login'] = {\n                type: 'session:login',\n                callback: async (response) => {\n                    if (response.type === 'session:success') {\n                        this.session_id = response.body.id;\n                        this.apiKey = response.body.api_key;\n                        // Store token in config\n                        this.config.token = token;\n                        // adds the session id as a query parameter in order to\n                        // connect to the same session in case of a reconnection\n                        this.connection.io.opts.query = {\n                            session_id: this.session_id,\n                            token: this.config.token\n                        };\n                        if (!this.application || (this.application.me && this.application.me.id !== response.body.user_id)) {\n                            this.application = new application_1.default(this, {});\n                        }\n                        if (!this.application.me) {\n                            this.application.me = new user_1.default(this.application, {\n                                id: response.body.user_id,\n                                name: response.body.name\n                            });\n                        }\n                        if (!this.errorsEmitter) {\n                            this.errorsEmitter = new errors_emitter_1.default(this.application);\n                        }\n                        // Set Bugsnag user to application.me.id\n                        if (this.config.log_reporter.enabled) {\n                            global.NXMbugsnagClient.user = {\n                                id: this.application.me.id,\n                                name: this.application.me.name,\n                                session_id: response.body.id\n                            };\n                        }\n                        if (this.config.sync !== 'none') {\n                            // Retrieve the existing conversation data for this user\n                            try {\n                                await this.application.getConversations();\n                                resolve(this.application);\n                            }\n                            catch (error) {\n                                reject(error);\n                            }\n                        }\n                        else {\n                            resolve(this.application);\n                        }\n                    }\n                    else {\n                        reject(new nexmoClientError_1.NexmoApiError(response));\n                    }\n                }\n            };\n        });\n    }\n    /**\n     * Delete existing Session.\n     * @returns  {Promise<CAPIResponse>} - response with rid and type\n     * @example <caption>Delete existing session</caption>\n     *  rtc.deleteSession().then((response) => {\n     *    console.log(response);\n     *  }).catch((error) => {\n     *    console.log(error);\n     *  });\n    */\n    deleteSession() {\n        return new Promise(async (resolve, reject) => {\n            const logoutRequest = () => {\n                return this.sendRequest({\n                    type: 'session:logout',\n                    body: {}\n                }, (response) => {\n                    if (response.type === 'session:logged-out' || response.type === 'session:terminated') {\n                        this.disconnect();\n                        delete this.errorsEmitter;\n                        delete this.application;\n                        delete this.connection;\n                        this.requests = {};\n                        this.sessionReady = false;\n                        resolve(response);\n                    }\n                    else {\n                        reject(response);\n                    }\n                });\n            };\n            // prepare for deleteSession\n            if (this.application) {\n                let disablePromises = [];\n                if (this.application.conversations.size) {\n                    for (let conversation of this.application.conversations.values()) {\n                        disablePromises.push(conversation.media.disable());\n                    }\n                }\n                try {\n                    await Promise.all(disablePromises);\n                }\n                catch (error) {\n                    this.log.error(\"deleteSession: \", error);\n                }\n                return logoutRequest();\n            }\n            else {\n                return logoutRequest();\n            }\n        });\n    }\n    updateSession(event) {\n        if (event.type === 'session:success') {\n            this.session_id = event.body.id;\n            this.connection.io.opts.query.session_id = event.body.id;\n        }\n    }\n    /**\n     * Disconnect from the cloud.\n     *\n    */\n    disconnect() {\n        return this.connection.disconnect();\n    }\n    /**\n     * Connect to the cloud.\n     *\n    */\n    connect() {\n        return this.connection.connect();\n    }\n    /**\n       * Get a connectivity report for all Vonage DCs and Media Servers.\n     * @param {string} token - the JSON Web Token (JWT)\n     * @param {object} options - configure the connectivityReport\n     * @param {Function} options.dcListCallback - a callback function to edit the list of datacenters before connectivity checks\n       * @returns  {Promise<Report>}\n       * @example <caption>Get a connectivity report</caption>\n     *\n       *  rtc.connectivityReport(token, {\n     *    dcListCallback: (dcList) => {...dcList, additionalDc}\n     *  }).then((report) => {\n     *    console.log(report);\n     *  }).catch((error) => {\n     *    console.log(error);\n     *  });\n    */\n    async connectivityReport(token, options) {\n        var _a;\n        const ip = !rtc_helper_1.default.isNode() ? await publicip_1.default.v4() : undefined;\n        const report = {\n            machineInfo: { ip },\n            connectivityReport: []\n        };\n        try {\n            const { response } = await utils_1.default.networkRequest({\n                type: 'GET',\n                url: `${this.config.nexmo_api_url}/v0.3/discovery/api`,\n                token\n            });\n            let dcList = response;\n            if ((_a = options) === null || _a === void 0 ? void 0 : _a.dcListCallback) {\n                dcList = options.dcListCallback(dcList);\n            }\n            for (const dc in dcList) {\n                const endpoint = dcList[dc].endpoint;\n                const apiUrl = dcList[dc].https;\n                const wsUrl = dcList[dc].ws;\n                try {\n                    const httpRes = await utils_1.default._checkHttpConnectivity(apiUrl);\n                    const wsRes = await utils_1.default._checkWsConnectivity(wsUrl, this.config.path, this.config.socket_io);\n                    const mediaConnectionReport = await utils_1.default._checkMediaServers(token, endpoint, dc);\n                    const rep = {\n                        name: dc,\n                        signalConnectionReport: {\n                            https: httpRes,\n                            ws: wsRes,\n                        },\n                        mediaConnectionReport\n                    };\n                    report.connectivityReport.push(rep);\n                }\n                catch (error) {\n                    this.log.error(`Error generating report for ${dc}`, error);\n                }\n            }\n        }\n        catch (error) {\n            this.log.error(`Error fetching nexmo servers information`, error);\n        }\n        return report;\n    }\n    /**\n      * Return a list with the connection health of the media servers for a specific datacenter.\n      * @returns  {Promise<MediaConnectionReport[]>}\n    * @param {string} token - the JSON Web Token (JWT)\n    * @param {string} nexmo_api_url - url of the nexmo api to be called\n    * @param {string} datacenter - datacenter of interest\n      * @example <caption>Return a list with the connection health of the media servers</caption>\n    *\n      *  rtc.checkMediaServers('nexmo-api-url','dc').then((responseArray) => {\n      *    console.log(responseArray);\n      *  }).catch((error) => {\n      *    console.log(error);\n      *  });\n     */\n    async checkMediaServers(token, nexmo_api_url, datacenter) {\n        return await utils_1.default._checkMediaServers(token, nexmo_api_url, datacenter);\n    }\n    /**\n    * Return the connection health of a single media server including possible connectionTime in ms.\n    * @returns  {Promise<MediaConnectionReport>}\n    * @param {string} ip - ip address of the Media Server\n    * @param {string} port - port number of the Media Server\n    * @example <caption>Return the connection health of a single media server</caption>\n    *\n    *  rtc.checkMediaConnectivity('ip-address','1').then((response) => {\n    *    console.log(`IP Address of media server: ${response.ip}`);\n    *    console.log(`Able to connect: ${response.canConnect}`);\n    *    console.log(`ConnectionTime in ms: ${resonse.connectionTime}`);\n    *  }).catch((error) => {\n    *    console.log(error);\n    *  });\n   */\n    async checkMediaConnectivity(ip, port) {\n        return await utils_1.default._checkMediaConnectivity(ip, port);\n    }\n}\nexports.default = NexmoClient;\n/**\n * Enum for NexmoClient disconnection reason.\n * @readonly\n * @enum {string}\n * @alias NexmoClient.DISCONNECT_REASON\n*/\nNexmoClient.DISCONNECT_REASON = {\n    ClientDisconnected: 'ClientDisconnected',\n    TokenExpired: 'TokenExpired',\n    ConnectionError: 'ConnectionError'\n};\nmodule.exports = NexmoClient;\n"],"mappings":"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AI,CAACF,aAAa,CAACC,mBAAmB,CAACL,QAAQ,CAAC;QACpD,CAAC,MACI,IAAIA,QAAQ,CAACF,IAAI,CAACQ,UAAU,CAAC,UAAU,CAAC,EAAE;UAC3C;UACA,IAAI,CAACC,aAAa,CAACP,QAAQ,CAAC;QAChC,CAAC,MACI,IAAI,IAAI,CAAClC,WAAW,EAAE;UACvB,IAAI,CAACA,WAAW,CAAC0C,aAAa,CAACR,QAAQ,CAAC;QAC5C;MACJ;IACJ,CAAC,CAAC;IACF,OAAOnB,UAAU;EACrB;EACA;AACJ;AACA;AACA;AACA;AACA;EACIT,eAAeA,CAACqC,cAAc,EAAE;IAC5B;IACA;IACA,IAAIC,eAAe,GAAGD,cAAc;IACpC,IAAIA,cAAc,CAAC1E,IAAI,IAAI,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC4E,OAAO,CAACF,cAAc,CAAC1E,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;MACrF,IAAI,CAACkC,GAAG,CAAC2C,IAAI,CAAE,kBAAiBH,cAAc,CAAC1E,IAAK,4BAA2B,IAAI,CAACpB,MAAM,CAACoB,IAAK,EAAC,CAAC;MAClG2E,eAAe,CAAC3E,IAAI,GAAG,IAAI,CAACpB,MAAM,CAACoB,IAAI;IAC3C;IACA,OAAO2E,eAAe;EAC1B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,WAAWA,CAACC,OAAO,EAAEb,QAAQ,EAAE;IAC3B;IACAa,OAAO,CAACC,GAAG,GAAG1H,OAAO,CAACK,OAAO,CAACsH,YAAY,CAAC,CAAC;IAC5C,MAAMlB,IAAI,GAAGgB,OAAO,CAAChB,IAAI;IACzB,OAAOgB,OAAO,CAAChB,IAAI;IACnB,IAAI,CAAC7B,GAAG,CAACrD,KAAK,CAAC,KAAK,EAAEkF,IAAI,EAAEgB,OAAO,CAAC;IACpC,IAAI,CAAC7C,GAAG,CAACkB,IAAI,CAAC,KAAK,EAAEW,IAAI,EAAEgB,OAAO,CAACC,GAAG,CAAC;IACvC,IAAI,CAAClC,UAA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"},"metadata":{},"sourceType":"script","externalDependencies":[]}