{"ast":null,"code":"'use strict';\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Nexmo Client SDK\n *  Application Object Model\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst WildEmitter = require('wildemitter');\nconst loglevel_1 = require(\"loglevel\");\nconst nexmoClientError_1 = require(\"./nexmoClientError\");\nconst user_1 = __importDefault(require(\"./user\"));\nconst conversation_1 = __importDefault(require(\"./conversation\"));\nconst nxmCall_1 = __importDefault(require(\"./modules/nxmCall\"));\nconst sip_events_1 = __importDefault(require(\"./handlers/sip_events\"));\nconst rtc_events_1 = __importDefault(require(\"./handlers/rtc_events\"));\nconst application_events_1 = __importDefault(require(\"./handlers/application_events\"));\nconst utils_1 = __importDefault(require(\"./utils\"));\nconst page_config_1 = __importDefault(require(\"./pages/page_config\"));\nconst conversations_page_1 = __importDefault(require(\"./pages/conversations_page\"));\nconst user_sessions_page_1 = __importDefault(require(\"./pages/user_sessions_page\"));\nconst events_queue_1 = require(\"./handlers/events_queue\");\nconst member_1 = __importDefault(require(\"./member\"));\nlet sipEventHandler = null;\nlet rtcEventHandler = null;\nlet applicationEventsHandler = null;\n/**\n * Core application class for the SDK.\n * Application is the parent object holding the list of conversations, the session object.\n * Provides methods to create conversations and retrieve a list of the user's conversations, while it holds the listeners for\n * user's invitations\n * @class Application\n * @param {NexmoClient} SDK session Object\n * @param {object} params\n * @example <caption>Accessing the list of conversations</caption>\n *  rtc.createSession(token).then((application) => {\n *    console.log(application.conversations);\n *    console.log(application.me.name, application.me.id);\n *  }).catch((error) => {\n *    console.error(error);\n *  });\n * @emits Application#member:invited\n * @emits Application#member:joined\n * @emits Application#NXM-errors\n * @emits Application#rtcstats:analytics\n*/\nclass Application {\n  constructor(session, params) {\n    this.log = loglevel_1.getLogger(this.constructor.name);\n    this.session = session;\n    this.conversations = new Map();\n    this.synced_conversations_count = 0;\n    this.start_sync_time = 0;\n    this.stop_sync_time = 0;\n    // conversation_id, nxmCall\n    this.calls = new Map();\n    // knocking_id, nxmCall\n    this._call_draft_list = new Map();\n    this.pageConfig = new page_config_1.default((session.config || {}).conversations_page_config);\n    this.conversations_page_last = null;\n    this.activeStreams = [];\n    sipEventHandler = new sip_events_1.default(this);\n    rtcEventHandler = new rtc_events_1.default(this);\n    applicationEventsHandler = new application_events_1.default(this);\n    this.me = null;\n    Object.assign(this, params);\n    WildEmitter.mixin(Application);\n  }\n  /**\n   * Update Conversation instance or create a new one.\n   *\n   * Pre-created conversation exist from getConversations\n   * like initialised templates. When we explicitly ask to\n   * getConversation(), we receive members and other details\n   *\n   * @param {object} payload Conversation payload\n   * @private\n  */\n  updateOrCreateConversation(payload) {\n    const conversation = this.conversations.get(payload.id);\n    if (conversation) {\n      conversation._updateObjectInstance(payload);\n      this.conversations.set(payload.id, conversation);\n    } else {\n      this.conversations.set(payload.id, new conversation_1.default(this, payload));\n    }\n    return this.conversations.get(payload.id);\n  }\n  /**\n   * Application listening for member invited events.\n   *\n   * @event Application#member:invited\n   *\n   * @property {Member} member - The invited member\n   * @property {NXMEvent} event - The invitation event\n   *\n   * @example <caption>listen for member invited events on Application level</caption>\n   *  application.on(\"member:invited\",(member, event) => {\n   *    console.log(\"Invited to the conversation: \" + event.conversation.display_name || event.conversation.name);\n   *    // identify the sender.\n   *    console.log(\"Invited by: \" + member.invited_by);\n   *    //accept an invitation.\n   *    application.conversations.get(event.conversation.id).join();\n   *    //decline the invitation.\n   *     application.conversations.get(event.conversation.id).leave();\n   *  });\n  */\n  /**\n   * Application listening for member joined events.\n   *\n   * @event Application#member:joined\n   *\n   * @property {Member} member - the member that joined the conversation\n   * @property {NXMEvent} event - the join event\n   *\n   * @example <caption>listen for member joined events on Application level</caption>\n   *  application.on(\"member:joined\",(member, event) => {\n   *    console.log(\"JOINED\", \"Joined conversation: \" + event.conversation.display_name || event.conversation.name);\n   *  });\n  */\n  /**\n     * Entry point for queing events in Application level\n     * @private\n  */\n  async _enqueueEvent(response) {\n    if (this.session.config.enableEventsQueue) {\n      if (!this.eventsQueue) {\n        this.eventsQueue = new events_queue_1.EventsQueue(event => this._handleEvent(event));\n      }\n      this.eventsQueue.enqueue(response, this);\n    } else {\n      this._handleEvent(response);\n    }\n  }\n  /**\n   * Entry point for events in Application level\n   * @private\n  */\n  async _handleEvent(event) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const isEventFromMe = ((_a = event._embedded) === null || _a === void 0 ? void 0 : _a.from_user) ? ((_c = (_b = event._embedded) === null || _b === void 0 ? void 0 : _b.from_user) === null || _c === void 0 ? void 0 : _c.id) === ((_d = this.me) === null || _d === void 0 ? void 0 : _d.id) : ((_f = (_e = event.body) === null || _e === void 0 ? void 0 : _e.user) === null || _f === void 0 ? void 0 : _f.user_id) === ((_g = this.me) === null || _g === void 0 ? void 0 : _g.id);\n    // check if user is already part of the conversation and if it has a member on a valid\n    // state (INVITED, JOINED) otherwise user is being re-invited and we need to fetch the\n    // conversation and members info again\n    const isUserReInvited = utils_1.default._checkIfUserIsReInvited(this.conversations, event);\n    if (event.type.startsWith('sip')) {\n      sipEventHandler._handleSipCallEvent(event);\n      return event;\n    }\n    if (this.conversations.has(event.cid) && event.type !== \"rtc:transfer\" && !isUserReInvited) {\n      if (event.type.startsWith('rtc')) {\n        rtcEventHandler._handleRtcEvent(event);\n      }\n      this.conversations.get(event.cid)._handleEvent(event);\n      if ((event.type === 'member:joined' || event.type === 'member:invited') && isEventFromMe) {\n        this._handleApplicationEvent(event);\n      }\n      return event;\n    } else {\n      // if event has cid get the conversation you don't know about (case: joined by another user)\n      if (event.cid) {\n        try {\n          if (isUserReInvited) this.conversations.delete(event.cid);\n          let conversation;\n          if (utils_1.default._isCallEvent(event)) {\n            conversation = await this.getConversation(event.cid, Application.CONVERSATION_API_VERSION.v1);\n          } else {\n            conversation = await this.getConversation(event.cid, Application.CONVERSATION_API_VERSION.v3);\n          }\n          this.conversations.set(event.cid, conversation);\n          await conversation._handleEvent(event);\n          await this._handleApplicationEvent(event);\n          if (event.type.startsWith(\"rtc\")) {\n            rtcEventHandler._handleRtcEvent(event);\n          }\n          return Promise.resolve(event);\n        } catch (error) {\n          this.log.error(error);\n          return Promise.reject(error);\n        }\n      }\n    }\n  }\n  /**\n   * Update user's token that was generated when they were first authenticated.\n   * @param {string} token - the new token\n   * @returns {Promise}\n  * @example <caption>listen for expired-token error events and then update the token on Application level</caption>\n  * application.on('system:error:expired-token', 'NXM-errors', (error) => {\n  * \tconsole.log('token expired');\n  * \tapplication.updateToken(token);\n  * });\n  */\n  async updateToken(token) {\n    // SDK can be disconnected because of expired token\n    // this lets us update token for next reconnection attempt\n    if (this.session.connection && this.session.connection.disconnected) {\n      this.session.config.token = token;\n      this.session.connection.io.opts.query.token = token;\n      return Promise.resolve();\n    }\n    const reqObj = {\n      url: `${this.session.config.nexmo_api_url}/v0.2/sessions/${this.session.session_id}`,\n      type: 'PUT',\n      token\n    };\n    try {\n      await utils_1.default.networkRequest(reqObj);\n      if (this.me) {\n        this.session.config.token = token;\n        this.session.connection.io.opts.query.token = token;\n      }\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n   * Update the event to map local generated events\n   * in case we need a more specific event to pass in the application listener\n   * or f/w the event as it comes\n   * @private\n  */\n  async _handleApplicationEvent(event) {\n    try {\n      this.log.debug(\"_handleApplicationEvent: \", {\n        event\n      });\n      const processed_event = applicationEventsHandler.handleEvent(event);\n      const conversation = this.conversations.get(event.cid);\n      let member;\n      if (conversation.members.has((processed_event || {}).from)) {\n        member = conversation.members.get(processed_event.from);\n      } else if (event.type === 'member:joined' || event.type === 'member:invited') {\n        const params = {\n          ...event.body,\n          ...(event.from && {\n            member_id: event.from\n          })\n        };\n        member = new member_1.default(conversation, params);\n      } else {\n        try {\n          member = await conversation.getMember(processed_event.from);\n        } catch (error) {\n          this.log.warn(`There is an error getting the member ${error}`);\n        }\n      }\n      this.emit(processed_event.type, member, processed_event);\n      return event;\n    } catch (e) {\n      this.log.error(\"_handleApplicationEvent: \", e);\n      throw e;\n    }\n  }\n  /**\n   * Creates a call to specified user/s.\n   * @classdesc creates a call between the defined users\n   * @param {string[]} usernames - the user names for those we want to call\n   * @returns {Promise<NXMCall>} a NXMCall object with all the call properties\n   * @example <caption>Create a call with users</caption>\n   *  application.on(\"call:status:changed\", (nxmCall) => {\n   *    if (nxmCall.status === nxmCall.CALL_STATUS.STARTED) {\n   *\t\t  console.log('the call has started');\n   *\t\t}\n   *  });\n   *\n   *  application.inAppCall(usernames).then(() => {\n   *    console.log('Calling user(s)...');\n   *  }).catch((error) => {\n   *    console.error(error);\n   *  });\n  */\n  async inAppCall(usernames) {\n    if (!usernames || !Array.isArray(usernames) || usernames.length === 0) {\n      return Promise.reject(new nexmoClientError_1.NexmoClientError('error:application:call:params'));\n    }\n    try {\n      const nxmCall = new nxmCall_1.default(this);\n      await nxmCall.createCall(usernames);\n      nxmCall.direction = nxmCall.CALL_DIRECTION.OUTBOUND;\n      return nxmCall;\n    } catch (error) {\n      throw error;\n    }\n  }\n  /**\n   * Creates a call to phone a number.\n   * The call object is created under application.calls when the call has started.\n   * listen for it with application.on(\"call:status:changed\")\n   *\n   * You don't need to start the stream, the SDK will play the audio for you\n   *\n   * @classdesc creates a call to a phone number\n  * @param {string} user the phone number or the username you want to call\n  * @param {string} [type=\"phone\"] the type of the call you want to have. possible values \"phone\" or \"app\" (default is \"phone\")\n  * @param {object} [custom_data] custom data to be included in the call object, i.e. { yourCustomKey: yourCustomValue }\n   * @returns {Promise<NXMCall>}\n   * @example <caption>Create a call to a phone</caption>\n   *  application.on(\"call:status:changed\", (nxmCall) => {\n   *    if (nxmCall.status === nxmCall.CALL_STATUS.STARTED) {\n   *\t\t  console.log('the call has started');\n  *\t\t}\n  *  });\n  *\n   *  application.callServer(phone_number).then((nxmCall) => {\n   *    console.log('Calling phone ' + phone_number);\n  *    console.log('Call Object ': nxmCall);\n   *  }).catch((error) => {\n  *    console.error(error);\n  *  });\n  */\n  async callServer(user, type = 'phone', custom_data = {}) {\n    try {\n      const nxmCall = new nxmCall_1.default(this);\n      nxmCall.direction = nxmCall.CALL_DIRECTION.OUTBOUND;\n      await nxmCall.createServerCall(user, type, custom_data);\n      return nxmCall;\n    } catch (error) {\n      throw error;\n    }\n  }\n  /**\n     * Reconnect a leg to an ongoing call.\n     * You don't need to start the stream, the SDK will play the audio for you\n     *\n     * @classdesc reconnect leg to an ongoing call\n   * @param {string} conversation_id the conversation that you want to reconnect\n   * @param {string} rtc_id the id of the leg that will be reconnected\n   * @param {object} [mediaParams] - MediaStream params (same as Media.enable())\n     * @returns {Promise<NXMCall>}\n     * @example <caption>Reconnect a leg to an ongoing call</caption>\n     *  application.reconnectCall(\"conversation_id\", \"rtc_id\").then((nxmCall) => {\n     *    console.log(nxmCall);\n     *  }).catch((error) => {\n   *    console.error(error);\n   *  });\n   *\n   * @example <caption>Reconnect a leg to an ongoing call without auto playing audio</caption>\n     *  application.reconnectCall(\"conversation_id\", \"rtc_id\", { autoPlayAudio: false }).then((nxmCall) => {\n     *    console.log(nxmCall);\n     *  }).catch((error) => {\n   *    console.error(error);\n   *  });\n   *\n   * @example <caption>Reconnect a leg to an ongoing call choosing device ID</caption>\n     *  application.reconnectCall(\"conversation_id\", \"rtc_id\", { audioConstraints: { deviceId: \"device_id\" } }).then((nxmCall) => {\n     *    console.log(nxmCall);\n     *  }).catch((error) => {\n   *    console.error(error);\n   *  });\n    */\n  async reconnectCall(conversationId, rtcId, mediaParams = {}) {\n    try {\n      if (!conversationId || !rtcId) {\n        throw new nexmoClientError_1.NexmoClientError('error:missing:params');\n      }\n      const conversation = await this.getConversation(conversationId, Application.CONVERSATION_API_VERSION.v1);\n      await conversation.media.enable({\n        ...mediaParams,\n        reconnectRtcId: rtcId\n      });\n      const nxmCall = new nxmCall_1.default(this, conversation);\n      // assigning the correct call status taking into account the sip status (outbound)\n      // on inbound calls the reconnect will happen after the call is estabilished and both legs are answered\n      const event_types = Array.from(conversation.events.values()).map(event => event.type);\n      if (event_types.includes('sip:answered')) nxmCall.status = nxmCall.CALL_STATUS.ANSWERED;else if (event_types.includes('sip:ringing')) nxmCall.status = nxmCall.CALL_STATUS.RINGING;else nxmCall.status = nxmCall.CALL_STATUS.STARTED;\n      nxmCall.rtcObjects = conversation.media.rtcObjects;\n      this.calls.set(conversation.id, nxmCall);\n      return nxmCall;\n    } catch (error) {\n      throw error;\n    }\n  }\n  /**\n   * Query the service to create a new conversation\n   * The conversation name must be unique per application.\n   * @param {object} [params] - leave empty to get a GUID as name\n   * @param {string} params.name - the name of the conversation. A UID will be assigned if this is skipped\n   * @param {string} params.display_name - the display_name of the conversation.\n   * @returns {Promise<Conversation>} - the created Conversation\n   * @example <caption>Create a conversation and join</caption>\n   *  application.newConversation().then((conversation) => {\n   *    //join the created conversation\n   *    conversation.join().then((member) => {\n   *      //Get the user's member belonging in this conversation.\n   *      //You can also access it via conversation.me\n   *      console.log(\"Joined as \" + member.user.name);\n  *    });\n   *  }).catch((error) => {\n   *    console.error(error);\n   *  });\n  */\n  async newConversation(data = {}) {\n    try {\n      const response = await this.session.sendNetworkRequest({\n        type: 'POST',\n        path: 'conversations',\n        data\n      });\n      const conv = new conversation_1.default(this, response);\n      this.conversations.set(conv.id, conv);\n      // do a get conversation to get the whole model as shaped in the service,\n      return this.getConversation(conv.id, Application.CONVERSATION_API_VERSION.v1);\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n   * Query the service to create a new conversation and join it\n   * The conversation name must be unique per application.\n   * @param {object} [params] - leave empty to get a GUID as name\n   * @param {string} params.name - the name of the conversation. A UID will be assigned if this is skipped\n   * @param {string} params.display_name - the display_name of the conversation.\n   * @returns {Promise<Conversation>} - the created Conversation\n   * @example <caption>Create a conversation and join</caption>\n   *  application.newConversationAndJoin().then((conversation) => {\n   *    console.log(\"Joined as \" + conversation.me.display_name);\n   *  }).catch((error) => {\n   *    console.error(\"Error creating a conversation and joining \", error);\n   *  });\n  */\n  async newConversationAndJoin(params) {\n    const conversation = await this.newConversation(params);\n    await conversation.join();\n    return conversation;\n  }\n  /**\n   * Query the service to see if this conversation exists with the\n   * logged in user as a member and retrieve the data object\n   * Result added (or updated) in this.conversations\n   *\n   * @param {string} id - the id of the conversation to fetch\n  * @param {string} version=Application.CONVERSATION_API_VERSION.v3 {Application.CONVERSATION_API_VERSION.v1 || Application.CONVERSATION_API_VERSION.v3} - the version of the Conversation Service API to use (v1 includes the full list of the members of the conversation but v3 does not)\n   * @returns {Promise<Conversation>} - the requested conversation\n   * @example <caption>Get a conversation</caption>\n   *  application.getConversation(id).then((conversation) => {\n   *      console.log(\"Retrieved conversation: \", conversation);\n   *  }).catch((error) => {\n   *    console.error(error);\n   *  });\n  */\n  async getConversation(id, version = Application.CONVERSATION_API_VERSION.v3) {\n    if (version !== Application.CONVERSATION_API_VERSION.v1 && version !== Application.CONVERSATION_API_VERSION.v3) {\n      throw new nexmoClientError_1.NexmoClientError('error:conversation-service:version');\n    }\n    let response;\n    if (version === Application.CONVERSATION_API_VERSION.v1) {\n      try {\n        response = await this.session.sendNetworkRequest({\n          type: 'GET',\n          path: `conversations/${id}`\n        });\n        response['id'] = response['uuid'];\n        delete response['uuid'];\n      } catch (error) {\n        throw new nexmoClientError_1.NexmoApiError(error);\n      }\n    } else {\n      try {\n        response = await this.session.sendNetworkRequest({\n          type: 'GET',\n          path: `conversations/${id}`,\n          version: 'v0.3'\n        });\n      } catch (error) {\n        throw new nexmoClientError_1.NexmoApiError(error);\n      }\n    }\n    const conversation_object = this.updateOrCreateConversation(response);\n    if (version === Application.CONVERSATION_API_VERSION.v3 && !conversation_object.me) {\n      try {\n        const member = await conversation_object.getMyMember();\n        conversation_object.me = member;\n        conversation_object.members.set(member.id, member);\n      } catch (error) {\n        // add a retry in case of a failure in fetching the member\n        try {\n          const member = await conversation_object.getMyMember();\n          conversation_object.me = member;\n          conversation_object.members.set(member.id, member);\n        } catch (error) {\n          this.log.warn(`You don't have any membership in ${conversation_object.id}`);\n        }\n      }\n    }\n    if (this.session.config.sync === 'full') {\n      // Populate the events\n      const {\n        items\n      } = await conversation_object.getEvents();\n      conversation_object.events = items;\n      return conversation_object;\n    } else {\n      return conversation_object;\n    }\n  }\n  /**\n   * Query the service to obtain a complete list of conversations of which the\n   * logged-in user is a member with a state of `JOINED` or `INVITED`.\n  * @param {object} params configure defaults for paginated conversations query\n  * @param {string} params.order 'asc' or 'desc' ordering of resources based on creation time\n  * @param {number} params.page_size the number of resources returned in a single request list\n  * @param {string} [params.cursor] string to access the starting point of a dataset\n   *\n   * @returns {Promise<Page<Map<Conversation>>>} - Populate Application.conversations.\n  * @example <caption>Get Conversations</caption>\n  *  application.getConversations({ page_size: 20 }).then((conversations_page) => {\n  *    conversations_page.items.forEach(conversation => {\n  *      render(conversation)\n  *    })\n  *  }).catch((error) => {\n  *      console.error(error);\n  *  });\n  *\n  */\n  async getConversations(params = {}) {\n    const url = `${this.session.config.nexmo_api_url}/beta2/users/${this.me.id}/conversations`;\n    // Create pageConfig if some elements given otherwise use default\n    let pageConfig = Object.keys(params).length === 0 ? this.pageConfig : new page_config_1.default(params);\n    try {\n      const response = await utils_1.default.paginationRequest(url, pageConfig, this.session.config.token);\n      response.application = this;\n      const conversations_page = new conversations_page_1.default(response);\n      this.conversations_page_last = conversations_page;\n      return conversations_page;\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n   * Application listening for sync status events.\n   *\n   * @event Application#sync:progress\n   *\n   * @property {number} status.sync_progress - Percentage of fetched conversations\n   * @example <caption>listen for changes in the synchronisation progress events on Application level</caption>\n   *  application.on(\"sync:progress\",(status) => {\n   *\t  console.log(status.sync_progress);\n   *  });\n  */\n  /**\n   * Fetching all the conversations and sync progress events\n  */\n  syncConversations(conversations) {\n    const conversation_array = Array.from(conversations.values());\n    const conversations_length = conversation_array.length;\n    const d = new Date();\n    this.start_sync_time = typeof window !== 'undefined' && window.performance ? window.performance.now() : d.getTime();\n    const fetchConversationForStorage = async () => {\n      this.synced_conversations_percentage = Number((this.synced_conversations_count / conversations_length * 100).toFixed(2));\n      const status_payload = {\n        sync_progress: this.synced_conversations_percentage\n      };\n      this.emit('sync:progress', status_payload);\n      this.log.info('Loading sync progress: ' + this.synced_conversations_count + '/' + conversations_length + ' - ' + this.synced_conversations_percentage + '%');\n      if (this.synced_conversations_percentage >= 100) {\n        const d = new Date();\n        this.stop_sync_time = typeof window !== 'undefined' && window.performance ? window.performance.now() : d.getTime();\n        this.log.info('Loaded conversations in ' + (this.stop_sync_time - this.start_sync_time) + 'ms');\n      }\n      if (this.synced_conversations_count < conversations_length) {\n        await this.getConversation(conversation_array[this.synced_conversations_count].id);\n        fetchConversationForStorage();\n        this.synced_conversations_count++;\n        this.sync_progress_buffer++;\n      }\n    };\n    fetchConversationForStorage();\n  }\n  /**\n   * Get Details of a user by using their id. If no id is present, will return your own user details.\n   * @param {string} id - the id of the user to fetch, if skipped, it returns your own user details\n   * @returns {Promise<User>}\n   * @example <caption>Get User details</caption>\n   *  application.getUser(id).then((user) => {\n   *    console.log('User details: 'user);\n   *  }).catch((error) => {\n   *      console.error(error);\n   *  });\n  */\n  async getUser(user_id = this.me.id) {\n    try {\n      const response = await this.session.sendNetworkRequest({\n        type: 'GET',\n        path: `users/${user_id}`\n      });\n      return new user_1.default(this, response);\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n   * Query the service to obtain a complete list of userSessions of a given user\n  * @param {object} params configure defaults for paginated user sessions query\n  * @param {string} params.order 'asc' or 'desc' ordering of resources based on creation time\n  * @param {number} params.page_size the number of resources returned in a single request list\n  * @param {string} [params.cursor] string to access the starting point of a dataset\n  * @param {string} [params.user_id] the user id that the sessions are being fetched\n   *\n   * @returns {Promise<Page<Map<UserSession>>>}\n  * @example <caption>Get User Sessions</caption>\n  *  application.getUserSessions({ user_id: \"id\", page_size: 20 }).then((user_sessions_page) => {\n  *    user_sessions_page.items.forEach(user_session => {\n  *      render(user_session)\n  *    })\n  *  }).catch((error) => {\n  *      console.error(error);\n  *  });\n  *\n  */\n  async getUserSessions(params = {}) {\n    var _a;\n    const user_id = ((_a = params) === null || _a === void 0 ? void 0 : _a.user_id) || this.me.id;\n    const url = `${this.session.config.nexmo_api_url}/v0.3/users/${user_id}/sessions`;\n    // Create pageConfig if some elements given otherwise use default\n    let pageConfig = Object.keys(params).length === 0 ? this.pageConfig : new page_config_1.default(params);\n    try {\n      const response = await utils_1.default.paginationRequest(url, pageConfig, this.session.config.token, Application.CONVERSATION_API_VERSION.v3);\n      response.application = this;\n      const user_sessions_page = new user_sessions_page_1.default(response);\n      this.user_sessions_page_last = user_sessions_page;\n      return user_sessions_page;\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n}\nexports.default = Application;\n/**\n * Enum for Application getConversation version.\n * @readonly\n * @enum {string}\n * @alias Application.CONVERSATION_API_VERSION\n*/\nApplication.CONVERSATION_API_VERSION = {\n  v1: 'v0.1',\n  v3: 'v0.3'\n};\nmodule.exports = Application;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","WildEmitter","require","loglevel_1","nexmoClientError_1","user_1","conversation_1","nxmCall_1","sip_events_1","rtc_events_1","application_events_1","utils_1","page_config_1","conversations_page_1","user_sessions_page_1","events_queue_1","member_1","sipEventHandler","rtcEventHandler","applicationEventsHandler","Application","constructor","session","params","log","getLogger","name","conversations","Map","synced_conversations_count","start_sync_time","stop_sync_time","calls","_call_draft_list","pageConfig","default","config","conversations_page_config","conversations_page_last","activeStreams","me","assign","mixin","updateOrCreateConversation","payload","conversation","get","id","_updateObjectInstance","set","_enqueueEvent","response","enableEventsQueue","eventsQueue","EventsQueue","event","_handleEvent","enqueue","_a","_b","_c","_d","_e","_f","_g","isEventFromMe","_embedded","from_user","body","user","user_id","isUserReInvited","_checkIfUserIsReInvited","type","startsWith","_handleSipCallEvent","has","cid","_handleRtcEvent","_handleApplicationEvent","delete","_isCallEvent","getConversation","CONVERSATION_API_VERSION","v1","v3","Promise","resolve","error","reject","updateToken","token","connection","disconnected","io","opts","query","reqObj","url","nexmo_api_url","session_id","networkRequest","NexmoApiError","debug","processed_event","handleEvent","member","members","from","member_id","getMember","warn","emit","e","inAppCall","usernames","Array","isArray","length","NexmoClientError","nxmCall","createCall","direction","CALL_DIRECTION","OUTBOUND","callServer","custom_data","createServerCall","reconnectCall","conversationId","rtcId","mediaParams","media","enable","reconnectRtcId","event_types","events","values","map","includes","status","CALL_STATUS","ANSWERED","RINGING","STARTED","rtcObjects","newConversation","data","sendNetworkRequest","path","conv","newConversationAndJoin","join","version","conversation_object","getMyMember","sync","items","getEvents","getConversations","keys","paginationRequest","application","conversations_page","syncConversations","conversation_array","conversations_length","d","Date","window","performance","now","getTime","fetchConversationForStorage","synced_conversations_percentage","Number","toFixed","status_payload","sync_progress","info","sync_progress_buffer","getUser","getUserSessions","user_sessions_page","user_sessions_page_last","module"],"sources":["/Users/vineetkhodre/react-workspace/thoughtctlchatapp/client/node_modules/nexmo-client/dist/application.js"],"sourcesContent":["'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  Application Object Model\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst WildEmitter = require('wildemitter');\nconst loglevel_1 = require(\"loglevel\");\nconst nexmoClientError_1 = require(\"./nexmoClientError\");\nconst user_1 = __importDefault(require(\"./user\"));\nconst conversation_1 = __importDefault(require(\"./conversation\"));\nconst nxmCall_1 = __importDefault(require(\"./modules/nxmCall\"));\nconst sip_events_1 = __importDefault(require(\"./handlers/sip_events\"));\nconst rtc_events_1 = __importDefault(require(\"./handlers/rtc_events\"));\nconst application_events_1 = __importDefault(require(\"./handlers/application_events\"));\nconst utils_1 = __importDefault(require(\"./utils\"));\nconst page_config_1 = __importDefault(require(\"./pages/page_config\"));\nconst conversations_page_1 = __importDefault(require(\"./pages/conversations_page\"));\nconst user_sessions_page_1 = __importDefault(require(\"./pages/user_sessions_page\"));\nconst events_queue_1 = require(\"./handlers/events_queue\");\nconst member_1 = __importDefault(require(\"./member\"));\nlet sipEventHandler = null;\nlet rtcEventHandler = null;\nlet applicationEventsHandler = null;\n/**\n * Core application class for the SDK.\n * Application is the parent object holding the list of conversations, the session object.\n * Provides methods to create conversations and retrieve a list of the user's conversations, while it holds the listeners for\n * user's invitations\n * @class Application\n * @param {NexmoClient} SDK session Object\n * @param {object} params\n * @example <caption>Accessing the list of conversations</caption>\n *  rtc.createSession(token).then((application) => {\n *    console.log(application.conversations);\n *    console.log(application.me.name, application.me.id);\n *  }).catch((error) => {\n *    console.error(error);\n *  });\n * @emits Application#member:invited\n * @emits Application#member:joined\n * @emits Application#NXM-errors\n * @emits Application#rtcstats:analytics\n*/\nclass Application {\n    constructor(session, params) {\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        this.session = session;\n        this.conversations = new Map();\n        this.synced_conversations_count = 0;\n        this.start_sync_time = 0;\n        this.stop_sync_time = 0;\n        // conversation_id, nxmCall\n        this.calls = new Map();\n        // knocking_id, nxmCall\n        this._call_draft_list = new Map();\n        this.pageConfig = new page_config_1.default((session.config || {}).conversations_page_config);\n        this.conversations_page_last = null;\n        this.activeStreams = [];\n        sipEventHandler = new sip_events_1.default(this);\n        rtcEventHandler = new rtc_events_1.default(this);\n        applicationEventsHandler = new application_events_1.default(this);\n        this.me = null;\n        Object.assign(this, params);\n        WildEmitter.mixin(Application);\n    }\n    /**\n     * Update Conversation instance or create a new one.\n     *\n     * Pre-created conversation exist from getConversations\n     * like initialised templates. When we explicitly ask to\n     * getConversation(), we receive members and other details\n     *\n     * @param {object} payload Conversation payload\n     * @private\n    */\n    updateOrCreateConversation(payload) {\n        const conversation = this.conversations.get(payload.id);\n        if (conversation) {\n            conversation._updateObjectInstance(payload);\n            this.conversations.set(payload.id, conversation);\n        }\n        else {\n            this.conversations.set(payload.id, new conversation_1.default(this, payload));\n        }\n        return this.conversations.get(payload.id);\n    }\n    /**\n     * Application listening for member invited events.\n     *\n     * @event Application#member:invited\n     *\n     * @property {Member} member - The invited member\n     * @property {NXMEvent} event - The invitation event\n     *\n     * @example <caption>listen for member invited events on Application level</caption>\n     *  application.on(\"member:invited\",(member, event) => {\n     *    console.log(\"Invited to the conversation: \" + event.conversation.display_name || event.conversation.name);\n     *    // identify the sender.\n     *    console.log(\"Invited by: \" + member.invited_by);\n     *    //accept an invitation.\n     *    application.conversations.get(event.conversation.id).join();\n     *    //decline the invitation.\n     *     application.conversations.get(event.conversation.id).leave();\n     *  });\n    */\n    /**\n     * Application listening for member joined events.\n     *\n     * @event Application#member:joined\n     *\n     * @property {Member} member - the member that joined the conversation\n     * @property {NXMEvent} event - the join event\n     *\n     * @example <caption>listen for member joined events on Application level</caption>\n     *  application.on(\"member:joined\",(member, event) => {\n     *    console.log(\"JOINED\", \"Joined conversation: \" + event.conversation.display_name || event.conversation.name);\n     *  });\n  */\n    /**\n       * Entry point for queing events in Application level\n       * @private\n    */\n    async _enqueueEvent(response) {\n        if (this.session.config.enableEventsQueue) {\n            if (!this.eventsQueue) {\n                this.eventsQueue = new events_queue_1.EventsQueue((event) => this._handleEvent(event));\n            }\n            this.eventsQueue.enqueue(response, this);\n        }\n        else {\n            this._handleEvent(response);\n        }\n    }\n    /**\n     * Entry point for events in Application level\n     * @private\n    */\n    async _handleEvent(event) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const isEventFromMe = ((_a = event._embedded) === null || _a === void 0 ? void 0 : _a.from_user) ? ((_c = (_b = event._embedded) === null || _b === void 0 ? void 0 : _b.from_user) === null || _c === void 0 ? void 0 : _c.id) === ((_d = this.me) === null || _d === void 0 ? void 0 : _d.id)\n            : ((_f = (_e = event.body) === null || _e === void 0 ? void 0 : _e.user) === null || _f === void 0 ? void 0 : _f.user_id) === ((_g = this.me) === null || _g === void 0 ? void 0 : _g.id);\n        // check if user is already part of the conversation and if it has a member on a valid\n        // state (INVITED, JOINED) otherwise user is being re-invited and we need to fetch the\n        // conversation and members info again\n        const isUserReInvited = utils_1.default._checkIfUserIsReInvited(this.conversations, event);\n        if (event.type.startsWith('sip')) {\n            sipEventHandler._handleSipCallEvent(event);\n            return event;\n        }\n        if (this.conversations.has(event.cid) && event.type !== \"rtc:transfer\" && !isUserReInvited) {\n            if (event.type.startsWith('rtc')) {\n                rtcEventHandler._handleRtcEvent(event);\n            }\n            this.conversations.get(event.cid)._handleEvent(event);\n            if ((event.type === 'member:joined' || event.type === 'member:invited') && isEventFromMe) {\n                this._handleApplicationEvent(event);\n            }\n            return event;\n        }\n        else {\n            // if event has cid get the conversation you don't know about (case: joined by another user)\n            if (event.cid) {\n                try {\n                    if (isUserReInvited)\n                        this.conversations.delete(event.cid);\n                    let conversation;\n                    if (utils_1.default._isCallEvent(event)) {\n                        conversation = await this.getConversation(event.cid, Application.CONVERSATION_API_VERSION.v1);\n                    }\n                    else {\n                        conversation = await this.getConversation(event.cid, Application.CONVERSATION_API_VERSION.v3);\n                    }\n                    this.conversations.set(event.cid, conversation);\n                    await conversation._handleEvent(event);\n                    await this._handleApplicationEvent(event);\n                    if (event.type.startsWith(\"rtc\")) {\n                        rtcEventHandler._handleRtcEvent(event);\n                    }\n                    return Promise.resolve(event);\n                }\n                catch (error) {\n                    this.log.error(error);\n                    return Promise.reject(error);\n                }\n            }\n        }\n    }\n    /**\n     * Update user's token that was generated when they were first authenticated.\n     * @param {string} token - the new token\n     * @returns {Promise}\n   * @example <caption>listen for expired-token error events and then update the token on Application level</caption>\n   * application.on('system:error:expired-token', 'NXM-errors', (error) => {\n   * \tconsole.log('token expired');\n   * \tapplication.updateToken(token);\n   * });\n  */\n    async updateToken(token) {\n        // SDK can be disconnected because of expired token\n        // this lets us update token for next reconnection attempt\n        if (this.session.connection && this.session.connection.disconnected) {\n            this.session.config.token = token;\n            this.session.connection.io.opts.query.token = token;\n            return Promise.resolve();\n        }\n        const reqObj = {\n            url: `${this.session.config.nexmo_api_url}/v0.2/sessions/${this.session.session_id}`,\n            type: 'PUT',\n            token\n        };\n        try {\n            await utils_1.default.networkRequest(reqObj);\n            if (this.me) {\n                this.session.config.token = token;\n                this.session.connection.io.opts.query.token = token;\n            }\n        }\n        catch (error) {\n            throw (new nexmoClientError_1.NexmoApiError(error));\n        }\n    }\n    /**\n     * Update the event to map local generated events\n     * in case we need a more specific event to pass in the application listener\n     * or f/w the event as it comes\n     * @private\n    */\n    async _handleApplicationEvent(event) {\n        try {\n            this.log.debug(\"_handleApplicationEvent: \", { event });\n            const processed_event = applicationEventsHandler.handleEvent(event);\n            const conversation = this.conversations.get(event.cid);\n            let member;\n            if (conversation.members.has((processed_event || {}).from)) {\n                member = conversation.members.get(processed_event.from);\n            }\n            else if (event.type === 'member:joined' || event.type === 'member:invited') {\n                const params = { ...event.body, ...(event.from && { member_id: event.from }) };\n                member = new member_1.default(conversation, params);\n            }\n            else {\n                try {\n                    member = await conversation.getMember(processed_event.from);\n                }\n                catch (error) {\n                    this.log.warn(`There is an error getting the member ${error}`);\n                }\n            }\n            this.emit(processed_event.type, member, processed_event);\n            return event;\n        }\n        catch (e) {\n            this.log.error(\"_handleApplicationEvent: \", e);\n            throw (e);\n        }\n    }\n    /**\n     * Creates a call to specified user/s.\n     * @classdesc creates a call between the defined users\n     * @param {string[]} usernames - the user names for those we want to call\n     * @returns {Promise<NXMCall>} a NXMCall object with all the call properties\n     * @example <caption>Create a call with users</caption>\n     *  application.on(\"call:status:changed\", (nxmCall) => {\n     *    if (nxmCall.status === nxmCall.CALL_STATUS.STARTED) {\n     *\t\t  console.log('the call has started');\n     *\t\t}\n     *  });\n     *\n     *  application.inAppCall(usernames).then(() => {\n     *    console.log('Calling user(s)...');\n     *  }).catch((error) => {\n     *    console.error(error);\n     *  });\n    */\n    async inAppCall(usernames) {\n        if (!usernames || !Array.isArray(usernames) || usernames.length === 0) {\n            return Promise.reject(new nexmoClientError_1.NexmoClientError('error:application:call:params'));\n        }\n        try {\n            const nxmCall = new nxmCall_1.default(this);\n            await nxmCall.createCall(usernames);\n            nxmCall.direction = nxmCall.CALL_DIRECTION.OUTBOUND;\n            return nxmCall;\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    /**\n     * Creates a call to phone a number.\n     * The call object is created under application.calls when the call has started.\n     * listen for it with application.on(\"call:status:changed\")\n     *\n     * You don't need to start the stream, the SDK will play the audio for you\n     *\n     * @classdesc creates a call to a phone number\n   * @param {string} user the phone number or the username you want to call\n   * @param {string} [type=\"phone\"] the type of the call you want to have. possible values \"phone\" or \"app\" (default is \"phone\")\n   * @param {object} [custom_data] custom data to be included in the call object, i.e. { yourCustomKey: yourCustomValue }\n     * @returns {Promise<NXMCall>}\n     * @example <caption>Create a call to a phone</caption>\n     *  application.on(\"call:status:changed\", (nxmCall) => {\n     *    if (nxmCall.status === nxmCall.CALL_STATUS.STARTED) {\n     *\t\t  console.log('the call has started');\n   *\t\t}\n   *  });\n   *\n     *  application.callServer(phone_number).then((nxmCall) => {\n     *    console.log('Calling phone ' + phone_number);\n   *    console.log('Call Object ': nxmCall);\n     *  }).catch((error) => {\n   *    console.error(error);\n   *  });\n    */\n    async callServer(user, type = 'phone', custom_data = {}) {\n        try {\n            const nxmCall = new nxmCall_1.default(this);\n            nxmCall.direction = nxmCall.CALL_DIRECTION.OUTBOUND;\n            await nxmCall.createServerCall(user, type, custom_data);\n            return nxmCall;\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    /**\n       * Reconnect a leg to an ongoing call.\n       * You don't need to start the stream, the SDK will play the audio for you\n       *\n       * @classdesc reconnect leg to an ongoing call\n     * @param {string} conversation_id the conversation that you want to reconnect\n     * @param {string} rtc_id the id of the leg that will be reconnected\n     * @param {object} [mediaParams] - MediaStream params (same as Media.enable())\n       * @returns {Promise<NXMCall>}\n       * @example <caption>Reconnect a leg to an ongoing call</caption>\n       *  application.reconnectCall(\"conversation_id\", \"rtc_id\").then((nxmCall) => {\n       *    console.log(nxmCall);\n       *  }).catch((error) => {\n     *    console.error(error);\n     *  });\n     *\n     * @example <caption>Reconnect a leg to an ongoing call without auto playing audio</caption>\n       *  application.reconnectCall(\"conversation_id\", \"rtc_id\", { autoPlayAudio: false }).then((nxmCall) => {\n       *    console.log(nxmCall);\n       *  }).catch((error) => {\n     *    console.error(error);\n     *  });\n     *\n     * @example <caption>Reconnect a leg to an ongoing call choosing device ID</caption>\n       *  application.reconnectCall(\"conversation_id\", \"rtc_id\", { audioConstraints: { deviceId: \"device_id\" } }).then((nxmCall) => {\n       *    console.log(nxmCall);\n       *  }).catch((error) => {\n     *    console.error(error);\n     *  });\n      */\n    async reconnectCall(conversationId, rtcId, mediaParams = {}) {\n        try {\n            if (!conversationId || !rtcId) {\n                throw new nexmoClientError_1.NexmoClientError('error:missing:params');\n            }\n            const conversation = await this.getConversation(conversationId, Application.CONVERSATION_API_VERSION.v1);\n            await conversation.media.enable({ ...mediaParams, reconnectRtcId: rtcId });\n            const nxmCall = new nxmCall_1.default(this, conversation);\n            // assigning the correct call status taking into account the sip status (outbound)\n            // on inbound calls the reconnect will happen after the call is estabilished and both legs are answered\n            const event_types = Array.from(conversation.events.values()).map(event => event.type);\n            if (event_types.includes('sip:answered'))\n                nxmCall.status = nxmCall.CALL_STATUS.ANSWERED;\n            else if (event_types.includes('sip:ringing'))\n                nxmCall.status = nxmCall.CALL_STATUS.RINGING;\n            else\n                nxmCall.status = nxmCall.CALL_STATUS.STARTED;\n            nxmCall.rtcObjects = conversation.media.rtcObjects;\n            this.calls.set(conversation.id, nxmCall);\n            return nxmCall;\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    /**\n     * Query the service to create a new conversation\n     * The conversation name must be unique per application.\n     * @param {object} [params] - leave empty to get a GUID as name\n     * @param {string} params.name - the name of the conversation. A UID will be assigned if this is skipped\n     * @param {string} params.display_name - the display_name of the conversation.\n     * @returns {Promise<Conversation>} - the created Conversation\n     * @example <caption>Create a conversation and join</caption>\n     *  application.newConversation().then((conversation) => {\n     *    //join the created conversation\n     *    conversation.join().then((member) => {\n     *      //Get the user's member belonging in this conversation.\n     *      //You can also access it via conversation.me\n     *      console.log(\"Joined as \" + member.user.name);\n   *    });\n     *  }).catch((error) => {\n     *    console.error(error);\n     *  });\n    */\n    async newConversation(data = {}) {\n        try {\n            const response = await this.session.sendNetworkRequest({\n                type: 'POST',\n                path: 'conversations',\n                data\n            });\n            const conv = new conversation_1.default(this, response);\n            this.conversations.set(conv.id, conv);\n            // do a get conversation to get the whole model as shaped in the service,\n            return this.getConversation(conv.id, Application.CONVERSATION_API_VERSION.v1);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Query the service to create a new conversation and join it\n     * The conversation name must be unique per application.\n     * @param {object} [params] - leave empty to get a GUID as name\n     * @param {string} params.name - the name of the conversation. A UID will be assigned if this is skipped\n     * @param {string} params.display_name - the display_name of the conversation.\n     * @returns {Promise<Conversation>} - the created Conversation\n     * @example <caption>Create a conversation and join</caption>\n     *  application.newConversationAndJoin().then((conversation) => {\n     *    console.log(\"Joined as \" + conversation.me.display_name);\n     *  }).catch((error) => {\n     *    console.error(\"Error creating a conversation and joining \", error);\n     *  });\n    */\n    async newConversationAndJoin(params) {\n        const conversation = await this.newConversation(params);\n        await conversation.join();\n        return conversation;\n    }\n    /**\n     * Query the service to see if this conversation exists with the\n     * logged in user as a member and retrieve the data object\n     * Result added (or updated) in this.conversations\n     *\n     * @param {string} id - the id of the conversation to fetch\n   * @param {string} version=Application.CONVERSATION_API_VERSION.v3 {Application.CONVERSATION_API_VERSION.v1 || Application.CONVERSATION_API_VERSION.v3} - the version of the Conversation Service API to use (v1 includes the full list of the members of the conversation but v3 does not)\n     * @returns {Promise<Conversation>} - the requested conversation\n     * @example <caption>Get a conversation</caption>\n     *  application.getConversation(id).then((conversation) => {\n     *      console.log(\"Retrieved conversation: \", conversation);\n     *  }).catch((error) => {\n     *    console.error(error);\n     *  });\n    */\n    async getConversation(id, version = Application.CONVERSATION_API_VERSION.v3) {\n        if (version !== Application.CONVERSATION_API_VERSION.v1 && version !== Application.CONVERSATION_API_VERSION.v3) {\n            throw new nexmoClientError_1.NexmoClientError('error:conversation-service:version');\n        }\n        let response;\n        if (version === Application.CONVERSATION_API_VERSION.v1) {\n            try {\n                response = await this.session.sendNetworkRequest({\n                    type: 'GET',\n                    path: `conversations/${id}`\n                });\n                response['id'] = response['uuid'];\n                delete response['uuid'];\n            }\n            catch (error) {\n                throw new nexmoClientError_1.NexmoApiError(error);\n            }\n        }\n        else {\n            try {\n                response = await this.session.sendNetworkRequest({\n                    type: 'GET',\n                    path: `conversations/${id}`,\n                    version: 'v0.3'\n                });\n            }\n            catch (error) {\n                throw new nexmoClientError_1.NexmoApiError(error);\n            }\n        }\n        const conversation_object = this.updateOrCreateConversation(response);\n        if (version === Application.CONVERSATION_API_VERSION.v3 && !conversation_object.me) {\n            try {\n                const member = await conversation_object.getMyMember();\n                conversation_object.me = member;\n                conversation_object.members.set(member.id, member);\n            }\n            catch (error) {\n                // add a retry in case of a failure in fetching the member\n                try {\n                    const member = await conversation_object.getMyMember();\n                    conversation_object.me = member;\n                    conversation_object.members.set(member.id, member);\n                }\n                catch (error) {\n                    this.log.warn(`You don't have any membership in ${conversation_object.id}`);\n                }\n            }\n        }\n        if (this.session.config.sync === 'full') {\n            // Populate the events\n            const { items } = await conversation_object.getEvents();\n            conversation_object.events = items;\n            return conversation_object;\n        }\n        else {\n            return conversation_object;\n        }\n    }\n    /**\n     * Query the service to obtain a complete list of conversations of which the\n     * logged-in user is a member with a state of `JOINED` or `INVITED`.\n   * @param {object} params configure defaults for paginated conversations query\n   * @param {string} params.order 'asc' or 'desc' ordering of resources based on creation time\n   * @param {number} params.page_size the number of resources returned in a single request list\n   * @param {string} [params.cursor] string to access the starting point of a dataset\n     *\n     * @returns {Promise<Page<Map<Conversation>>>} - Populate Application.conversations.\n   * @example <caption>Get Conversations</caption>\n   *  application.getConversations({ page_size: 20 }).then((conversations_page) => {\n   *    conversations_page.items.forEach(conversation => {\n   *      render(conversation)\n   *    })\n   *  }).catch((error) => {\n   *      console.error(error);\n   *  });\n   *\n    */\n    async getConversations(params = {}) {\n        const url = `${this.session.config.nexmo_api_url}/beta2/users/${this.me.id}/conversations`;\n        // Create pageConfig if some elements given otherwise use default\n        let pageConfig = Object.keys(params).length === 0 ? this.pageConfig : new page_config_1.default(params);\n        try {\n            const response = await utils_1.default.paginationRequest(url, pageConfig, this.session.config.token);\n            response.application = this;\n            const conversations_page = new conversations_page_1.default(response);\n            this.conversations_page_last = conversations_page;\n            return conversations_page;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Application listening for sync status events.\n     *\n     * @event Application#sync:progress\n     *\n     * @property {number} status.sync_progress - Percentage of fetched conversations\n     * @example <caption>listen for changes in the synchronisation progress events on Application level</caption>\n     *  application.on(\"sync:progress\",(status) => {\n     *\t  console.log(status.sync_progress);\n     *  });\n    */\n    /**\n     * Fetching all the conversations and sync progress events\n    */\n    syncConversations(conversations) {\n        const conversation_array = Array.from(conversations.values());\n        const conversations_length = conversation_array.length;\n        const d = new Date();\n        this.start_sync_time = (typeof window !== 'undefined' && window.performance) ? window.performance.now() : d.getTime();\n        const fetchConversationForStorage = async () => {\n            this.synced_conversations_percentage = Number(((this.synced_conversations_count / conversations_length) * 100).toFixed(2));\n            const status_payload = {\n                sync_progress: this.synced_conversations_percentage\n            };\n            this.emit('sync:progress', status_payload);\n            this.log.info('Loading sync progress: ' + this.synced_conversations_count + '/' +\n                conversations_length + ' - ' + this.synced_conversations_percentage + '%');\n            if (this.synced_conversations_percentage >= 100) {\n                const d = new Date();\n                this.stop_sync_time = (typeof window !== 'undefined' && window.performance) ? window.performance.now() : d.getTime();\n                this.log.info('Loaded conversations in ' + (this.stop_sync_time - this.start_sync_time) + 'ms');\n            }\n            if (this.synced_conversations_count < conversations_length) {\n                await this.getConversation(conversation_array[this.synced_conversations_count].id);\n                fetchConversationForStorage();\n                this.synced_conversations_count++;\n                this.sync_progress_buffer++;\n            }\n        };\n        fetchConversationForStorage();\n    }\n    /**\n     * Get Details of a user by using their id. If no id is present, will return your own user details.\n     * @param {string} id - the id of the user to fetch, if skipped, it returns your own user details\n     * @returns {Promise<User>}\n     * @example <caption>Get User details</caption>\n     *  application.getUser(id).then((user) => {\n     *    console.log('User details: 'user);\n     *  }).catch((error) => {\n     *      console.error(error);\n     *  });\n    */\n    async getUser(user_id = this.me.id) {\n        try {\n            const response = await this.session.sendNetworkRequest({\n                type: 'GET',\n                path: `users/${user_id}`\n            });\n            return new user_1.default(this, response);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Query the service to obtain a complete list of userSessions of a given user\n   * @param {object} params configure defaults for paginated user sessions query\n   * @param {string} params.order 'asc' or 'desc' ordering of resources based on creation time\n   * @param {number} params.page_size the number of resources returned in a single request list\n   * @param {string} [params.cursor] string to access the starting point of a dataset\n   * @param {string} [params.user_id] the user id that the sessions are being fetched\n     *\n     * @returns {Promise<Page<Map<UserSession>>>}\n   * @example <caption>Get User Sessions</caption>\n   *  application.getUserSessions({ user_id: \"id\", page_size: 20 }).then((user_sessions_page) => {\n   *    user_sessions_page.items.forEach(user_session => {\n   *      render(user_session)\n   *    })\n   *  }).catch((error) => {\n   *      console.error(error);\n   *  });\n   *\n    */\n    async getUserSessions(params = {}) {\n        var _a;\n        const user_id = ((_a = params) === null || _a === void 0 ? void 0 : _a.user_id) || this.me.id;\n        const url = `${this.session.config.nexmo_api_url}/v0.3/users/${user_id}/sessions`;\n        // Create pageConfig if some elements given otherwise use default\n        let pageConfig = Object.keys(params).length === 0 ? this.pageConfig : new page_config_1.default(params);\n        try {\n            const response = await utils_1.default.paginationRequest(url, pageConfig, this.session.config.token, Application.CONVERSATION_API_VERSION.v3);\n            response.application = this;\n            const user_sessions_page = new user_sessions_page_1.default(response);\n            this.user_sessions_page_last = user_sessions_page;\n            return user_sessions_page;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n}\nexports.default = Application;\n/**\n * Enum for Application getConversation version.\n * @readonly\n * @enum {string}\n * @alias Application.CONVERSATION_API_VERSION\n*/\nApplication.CONVERSATION_API_VERSION = {\n    v1: 'v0.1',\n    v3: 'v0.3'\n};\nmodule.exports = Application;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}