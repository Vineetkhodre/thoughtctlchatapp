{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Nexmo Client SDK\n *  RTC Events Handler\n *\n * Copyright (c) Nexmo Inc.\n */\nconst loglevel_1 = require(\"loglevel\");\n/**\n * Handle rtc Events\n *\n * @class RtcEventHandler\n * @private\n */\nclass RtcEventHandler {\n  constructor(application) {\n    this.log = loglevel_1.getLogger(this.constructor.name);\n    this.application = application;\n    this._handleRtcEventMap = {\n      'rtc:transfer': this._processRtcTransfer,\n      'rtc:answer': this._processRtcAnswer,\n      'rtc:hangup': this._processRtcHangup\n    };\n  }\n  /**\n   * Entry point for rtc events\n   * @param {object} event\n   * @private\n   */\n  _handleRtcEvent(event) {\n    if (this._handleRtcEventMap.hasOwnProperty(event.type)) {\n      return this._handleRtcEventMap[event.type].call(this, event);\n    }\n  }\n  /**\n    * on transfer event\n    * update the conversation object in the NXMCall,\n    * update the media object in the new conversation\n    * set `transferred_to` <Conversation> on the member that is transferred\n    * @param {object} event\n    * @private\n  */\n  _processRtcTransfer(event) {\n    this.log.debug('_processRtcTransfer: ', {\n      event\n    });\n    const old_conversation = this.application.conversations.get(event.body.transferred_from);\n    const new_conversation = this.application.conversations.get(event.cid);\n    const nxmCall = this.application.calls.get(event.body.transferred_from);\n    if (!nxmCall) {\n      this.log.warn('NXMCall transfer for unknown nxmCall');\n      return;\n    }\n    // mark the transferred member in the old conversation\n    nxmCall.conversation.members.get(event.body.was_member).transferred_to = new_conversation;\n    nxmCall._setupConversationObject(new_conversation);\n    nxmCall.transferred = true;\n    this.application.calls.set(event.cid, nxmCall);\n    this.application.calls.delete(event.body.transferred_from);\n    // in case we joined in the middle of a transfer and we don't have the\n    // previous conversation in our list yet\n    if (old_conversation) {\n      new_conversation.members.get(event.from).transferred_from = old_conversation;\n      new_conversation.media._attachEndingEventHandlers();\n      // Checking to see if old conversation has rtcObject, pc or activeStreams while new conversation does not and if so add\n      // to new conversation the missing rtcObject, pc or activeStream\n      if (Object.entries(new_conversation.media.rtcObjects).length === 0 && Object.entries(old_conversation.media.rtcObjects).length !== 0) {\n        Object.assign(new_conversation.media.rtcObjects, old_conversation.media.rtcObjects);\n      }\n      if (!new_conversation.media.pc && old_conversation.media.pc) {\n        Object.assign(new_conversation.media.pc = old_conversation.media.pc);\n      }\n      if (new_conversation.application.activeStreams.length === 0 && old_conversation.application.activeStreams.length > 0) {\n        new_conversation.application.activeStreams = old_conversation.application.activeStreams;\n      }\n    }\n  }\n  /**\n   * Handle rtc:answer event\n   *\n   * @param {object} event\n   * @private\n   */\n  _processRtcAnswer(event) {\n    this.log.debug('_processRtcAnswer: ', {\n      event\n    });\n    if (this.application.calls.has(event.cid)) {\n      this.application.calls.get(event.cid).id = event.body.rtc_id;\n    }\n  }\n  /**\n   * Handle rtc:hangup event\n   *\n   * @param {object} event\n   * @private\n   */\n  _processRtcHangup(event) {\n    this.log.debug('_processRtcHangup: ', {\n      event\n    });\n    if (this.application.calls.has(event.cid)) {\n      let call = this.application.calls.get(event.cid);\n      call._handleStatusChange(event);\n    }\n  }\n}\nexports.default = RtcEventHandler;\nmodule.exports = RtcEventHandler;","map":{"version":3,"names":["Object","defineProperty","exports","value","loglevel_1","require","RtcEventHandler","constructor","application","log","getLogger","name","_handleRtcEventMap","_processRtcTransfer","_processRtcAnswer","_processRtcHangup","_handleRtcEvent","event","hasOwnProperty","type","call","debug","old_conversation","conversations","get","body","transferred_from","new_conversation","cid","nxmCall","calls","warn","conversation","members","was_member","transferred_to","_setupConversationObject","transferred","set","delete","from","media","_attachEndingEventHandlers","entries","rtcObjects","length","assign","pc","activeStreams","has","id","rtc_id","_handleStatusChange","default","module"],"sources":["/Users/vineetkhodre/react-workspace/thoughtctlchatapp/client/node_modules/nexmo-client/dist/handlers/rtc_events.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  RTC Events Handler\n *\n * Copyright (c) Nexmo Inc.\n */\nconst loglevel_1 = require(\"loglevel\");\n/**\n * Handle rtc Events\n *\n * @class RtcEventHandler\n * @private\n */\nclass RtcEventHandler {\n    constructor(application) {\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        this.application = application;\n        this._handleRtcEventMap = {\n            'rtc:transfer': this._processRtcTransfer,\n            'rtc:answer': this._processRtcAnswer,\n            'rtc:hangup': this._processRtcHangup\n        };\n    }\n    /**\n     * Entry point for rtc events\n     * @param {object} event\n     * @private\n     */\n    _handleRtcEvent(event) {\n        if (this._handleRtcEventMap.hasOwnProperty(event.type)) {\n            return this._handleRtcEventMap[event.type].call(this, event);\n        }\n    }\n    /**\n      * on transfer event\n      * update the conversation object in the NXMCall,\n      * update the media object in the new conversation\n      * set `transferred_to` <Conversation> on the member that is transferred\n      * @param {object} event\n      * @private\n    */\n    _processRtcTransfer(event) {\n        this.log.debug('_processRtcTransfer: ', { event });\n        const old_conversation = this.application.conversations.get(event.body.transferred_from);\n        const new_conversation = this.application.conversations.get(event.cid);\n        const nxmCall = this.application.calls.get(event.body.transferred_from);\n        if (!nxmCall) {\n            this.log.warn('NXMCall transfer for unknown nxmCall');\n            return;\n        }\n        // mark the transferred member in the old conversation\n        nxmCall.conversation.members.get(event.body.was_member).transferred_to = new_conversation;\n        nxmCall._setupConversationObject(new_conversation);\n        nxmCall.transferred = true;\n        this.application.calls.set(event.cid, nxmCall);\n        this.application.calls.delete(event.body.transferred_from);\n        // in case we joined in the middle of a transfer and we don't have the\n        // previous conversation in our list yet\n        if (old_conversation) {\n            new_conversation.members.get(event.from).transferred_from = old_conversation;\n            new_conversation.media._attachEndingEventHandlers();\n            // Checking to see if old conversation has rtcObject, pc or activeStreams while new conversation does not and if so add\n            // to new conversation the missing rtcObject, pc or activeStream\n            if (Object.entries(new_conversation.media.rtcObjects).length === 0 && Object.entries(old_conversation.media.rtcObjects).length !== 0) {\n                Object.assign(new_conversation.media.rtcObjects, old_conversation.media.rtcObjects);\n            }\n            if (!new_conversation.media.pc && old_conversation.media.pc) {\n                Object.assign(new_conversation.media.pc = old_conversation.media.pc);\n            }\n            if (new_conversation.application.activeStreams.length === 0 && old_conversation.application.activeStreams.length > 0) {\n                new_conversation.application.activeStreams = old_conversation.application.activeStreams;\n            }\n        }\n    }\n    /**\n     * Handle rtc:answer event\n     *\n     * @param {object} event\n     * @private\n     */\n    _processRtcAnswer(event) {\n        this.log.debug('_processRtcAnswer: ', { event });\n        if (this.application.calls.has(event.cid)) {\n            this.application.calls.get(event.cid).id = event.body.rtc_id;\n        }\n    }\n    /**\n     * Handle rtc:hangup event\n     *\n     * @param {object} event\n     * @private\n     */\n    _processRtcHangup(event) {\n        this.log.debug('_processRtcHangup: ', { event });\n        if (this.application.calls.has(event.cid)) {\n            let call = this.application.calls.get(event.cid);\n            call._handleStatusChange(event);\n        }\n    }\n}\nexports.default = RtcEventHandler;\nmodule.exports = RtcEventHandler;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,UAAU,GAAGC,OAAO,CAAC,UAAU,CAAC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,eAAe,CAAC;EAClBC,WAAWA,CAACC,WAAW,EAAE;IACrB,IAAI,CAACC,GAAG,GAAGL,UAAU,CAACM,SAAS,CAAC,IAAI,CAACH,WAAW,CAACI,IAAI,CAAC;IACtD,IAAI,CAACH,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACI,kBAAkB,GAAG;MACtB,cAAc,EAAE,IAAI,CAACC,mBAAmB;MACxC,YAAY,EAAE,IAAI,CAACC,iBAAiB;MACpC,YAAY,EAAE,IAAI,CAACC;IACvB,CAAC;EACL;EACA;AACJ;AACA;AACA;AACA;EACIC,eAAeA,CAACC,KAAK,EAAE;IACnB,IAAI,IAAI,CAACL,kBAAkB,CAACM,cAAc,CAACD,KAAK,CAACE,IAAI,CAAC,EAAE;MACpD,OAAO,IAAI,CAACP,kBAAkB,CAACK,KAAK,CAACE,IAAI,CAAC,CAACC,IAAI,CAAC,IAAI,EAAEH,KAAK,CAAC;IAChE;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIJ,mBAAmBA,CAACI,KAAK,EAAE;IACvB,IAAI,CAACR,GAAG,CAACY,KAAK,CAAC,uBAAuB,EAAE;MAAEJ;IAAM,CAAC,CAAC;IAClD,MAAMK,gBAAgB,GAAG,IAAI,CAACd,WAAW,CAACe,aAAa,CAACC,GAAG,CAACP,KAAK,CAACQ,IAAI,CAACC,gBAAgB,CAAC;IACxF,MAAMC,gBAAgB,GAAG,IAAI,CAACnB,WAAW,CAACe,aAAa,CAACC,GAAG,CAACP,KAAK,CAACW,GAAG,CAAC;IACtE,MAAMC,OAAO,GAAG,IAAI,CAACrB,WAAW,CAACsB,KAAK,CAACN,GAAG,CAACP,KAAK,CAACQ,IAAI,CAACC,gBAAgB,CAAC;IACvE,IAAI,CAACG,OAAO,EAAE;MACV,IAAI,CAACpB,GAAG,CAACsB,IAAI,CAAC,sCAAsC,CAAC;MACrD;IACJ;IACA;IACAF,OAAO,CAACG,YAAY,CAACC,OAAO,CAACT,GAAG,CAACP,KAAK,CAACQ,IAAI,CAACS,UAAU,CAAC,CAACC,cAAc,GAAGR,gBAAgB;IACzFE,OAAO,CAACO,wBAAwB,CAACT,gBAAgB,CAAC;IAClDE,OAAO,CAACQ,WAAW,GAAG,IAAI;IAC1B,IAAI,CAAC7B,WAAW,CAACsB,KAAK,CAACQ,GAAG,CAACrB,KAAK,CAACW,GAAG,EAAEC,OAAO,CAAC;IAC9C,IAAI,CAACrB,WAAW,CAACsB,KAAK,CAACS,MAAM,CAACtB,KAAK,CAACQ,IAAI,CAACC,gBAAgB,CAAC;IAC1D;IACA;IACA,IAAIJ,gBAAgB,EAAE;MAClBK,gBAAgB,CAACM,OAAO,CAACT,GAAG,CAACP,KAAK,CAACuB,IAAI,CAAC,CAACd,gBAAgB,GAAGJ,gBAAgB;MAC5EK,gBAAgB,CAACc,KAAK,CAACC,0BAA0B,CAAC,CAAC;MACnD;MACA;MACA,IAAI1C,MAAM,CAAC2C,OAAO,CAAChB,gBAAgB,CAACc,KAAK,CAACG,UAAU,CAAC,CAACC,MAAM,KAAK,CAAC,IAAI7C,MAAM,CAAC2C,OAAO,CAACrB,gBAAgB,CAACmB,KAAK,CAACG,UAAU,CAAC,CAACC,MAAM,KAAK,CAAC,EAAE;QAClI7C,MAAM,CAAC8C,MAAM,CAACnB,gBAAgB,CAACc,KAAK,CAACG,UAAU,EAAEtB,gBAAgB,CAACmB,KAAK,CAACG,UAAU,CAAC;MACvF;MACA,IAAI,CAACjB,gBAAgB,CAACc,KAAK,CAACM,EAAE,IAAIzB,gBAAgB,CAACmB,KAAK,CAACM,EAAE,EAAE;QACzD/C,MAAM,CAAC8C,MAAM,CAACnB,gBAAgB,CAACc,KAAK,CAACM,EAAE,GAAGzB,gBAAgB,CAACmB,KAAK,CAACM,EAAE,CAAC;MACxE;MACA,IAAIpB,gBAAgB,CAACnB,WAAW,CAACwC,aAAa,CAACH,MAAM,KAAK,CAAC,IAAIvB,gBAAgB,CAACd,WAAW,CAACwC,aAAa,CAACH,MAAM,GAAG,CAAC,EAAE;QAClHlB,gBAAgB,CAACnB,WAAW,CAACwC,aAAa,GAAG1B,gBAAgB,CAACd,WAAW,CAACwC,aAAa;MAC3F;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACIlC,iBAAiBA,CAACG,KAAK,EAAE;IACrB,IAAI,CAACR,GAAG,CAACY,KAAK,CAAC,qBAAqB,EAAE;MAAEJ;IAAM,CAAC,CAAC;IAChD,IAAI,IAAI,CAACT,WAAW,CAACsB,KAAK,CAACmB,GAAG,CAAChC,KAAK,CAACW,GAAG,CAAC,EAAE;MACvC,IAAI,CAACpB,WAAW,CAACsB,KAAK,CAACN,GAAG,CAACP,KAAK,CAACW,GAAG,CAAC,CAACsB,EAAE,GAAGjC,KAAK,CAACQ,IAAI,CAAC0B,MAAM;IAChE;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACIpC,iBAAiBA,CAACE,KAAK,EAAE;IACrB,IAAI,CAACR,GAAG,CAACY,KAAK,CAAC,qBAAqB,EAAE;MAAEJ;IAAM,CAAC,CAAC;IAChD,IAAI,IAAI,CAACT,WAAW,CAACsB,KAAK,CAACmB,GAAG,CAAChC,KAAK,CAACW,GAAG,CAAC,EAAE;MACvC,IAAIR,IAAI,GAAG,IAAI,CAACZ,WAAW,CAACsB,KAAK,CAACN,GAAG,CAACP,KAAK,CAACW,GAAG,CAAC;MAChDR,IAAI,CAACgC,mBAAmB,CAACnC,KAAK,CAAC;IACnC;EACJ;AACJ;AACAf,OAAO,CAACmD,OAAO,GAAG/C,eAAe;AACjCgD,MAAM,CAACpD,OAAO,GAAGI,eAAe"},"metadata":{},"sourceType":"script","externalDependencies":[]}