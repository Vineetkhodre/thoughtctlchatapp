{"ast":null,"code":"'use strict';\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Nexmo Client SDK\n * Events Queue\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst nexmoClientError_1 = require(\"../nexmoClientError\");\nconst utils_1 = __importDefault(require(\"../utils\"));\nconst loglevel_1 = require(\"loglevel\");\n/**\n * Handle Mapping of Conversation Ids to ConversationEventsProcessor\n *\n * @class EventsQueue\n * @private\n */\nclass EventsQueue {\n  constructor(callback) {\n    this.callback = callback;\n    this.cidMap = new Map();\n    this.log = loglevel_1.getLogger(this.constructor.name);\n  }\n  // enqueue(item)\n  async enqueue(event, application) {\n    var _a, _b, _c, _d;\n    //Check if cid or event id and if not just send to application to be processed\n    const {\n      cid,\n      id\n    } = event;\n    const eventId = Number(id);\n    if (!cid || isNaN(eventId)) return this.callback(event);\n    // Check if Conversation Events Queue for CID and if not create one\n    if (!this.cidMap.get(cid)) {\n      this.log.debug(`enqueue: create new ConversationEventsProcessor for ${cid}`);\n      const newConversationEventsProcessor = new ConversationEventsProcessor(cid, eventId - 1, application);\n      // edge case for member:media or  member:joined event before transfer or member:joined && channel:id\n      if (event.type == 'member:media' && ((_b = (_a = event.body) === null || _a === void 0 ? void 0 : _a.media) === null || _b === void 0 ? void 0 : _b.audio) || event.type == 'member:joined' && ((_d = (_c = event.body) === null || _c === void 0 ? void 0 : _c.channel) === null || _d === void 0 ? void 0 : _d.id)) {\n        //fetch last 20 events of conversation & if there is a transfer to this converstaion\n        const startingFetchEventId = eventId - 20 < 1 ? 1 : eventId - 20;\n        const events = await newConversationEventsProcessor.fetchConversationEvents(startingFetchEventId, 20);\n        let transferEventFound = false;\n        events.forEach(fetchedEvent => {\n          if (fetchedEvent.type === 'rtc:transfer' && fetchedEvent.from === event.from) {\n            transferEventFound = true;\n            // reset the events processor to process transfer event next\n            newConversationEventsProcessor.lastEventIdProcessed = Number(fetchedEvent.id) - 1;\n          }\n          if (transferEventFound) {\n            //Enqueue all events after rtc:transfer event found\n            newConversationEventsProcessor.enqueue(Number(fetchedEvent.id), fetchedEvent);\n          }\n        });\n      }\n      this.cidMap.set(cid, newConversationEventsProcessor);\n    }\n    const conversationEventsProcessor = this.cidMap.get(cid);\n    // Add new event to conversation events queue\n    conversationEventsProcessor.enqueue(eventId, event);\n    // If not currently processing events in queue begin processing\n    if (!conversationEventsProcessor.processing) {\n      conversationEventsProcessor.processing = true;\n      const processingEvents = await conversationEventsProcessor.processEvents();\n    }\n    return;\n  }\n}\nexports.EventsQueue = EventsQueue;\n/**\n * Handle Ordering of Conversation Events for Processing\n *\n * @class ConversationEventsProcessor\n * @private\n */\nclass ConversationEventsProcessor {\n  constructor(cid, lastEventIdProcessed, application) {\n    this.cid = cid;\n    this.eventsMap = new Map();\n    this.callback = event => application._handleEvent(event);\n    this.lastEventIdProcessed = lastEventIdProcessed;\n    this.largestEventIdInQueue = lastEventIdProcessed;\n    this.processing = false;\n    this.application = application;\n    this.eventsFetchRange = 9;\n    this.log = loglevel_1.getLogger(this.constructor.name);\n  }\n  enqueue(eventId, event) {\n    if (eventId > this.largestEventIdInQueue) this.largestEventIdInQueue = eventId;\n    if (eventId > this.lastEventIdProcessed) this.eventsMap.set(eventId, event);\n    return event;\n  }\n  dequeue(eventId) {\n    const event = this.eventsMap.get(eventId);\n    this.eventsMap.delete(eventId);\n    return event;\n  }\n  async processEvents() {\n    const doneProcessing = () => {\n      this.eventsMap.clear();\n      this.log.debug(`processEvents: Done Processing`);\n      return this.processing = false;\n    };\n    if (this.eventsMap.size < 1) return doneProcessing();\n    const nextEventToProcess = this.lastEventIdProcessed + 1;\n    const processedEvent = await this.processNextEvent(nextEventToProcess);\n    if (processedEvent) {\n      this.lastEventIdProcessed = Number(processedEvent.id);\n      return this.processEvents();\n    } else {\n      return doneProcessing();\n    }\n  }\n  async processNextEvent(eventId) {\n    this.log.debug(`processNextEvent: processing event number ${eventId}`);\n    const event = this.dequeue(eventId);\n    try {\n      if (event) {\n        await this.callback(event);\n        return event;\n      } else {\n        // The next event in the sequence was not in the map, if larger event id in queue (gap)\n        // make a request to CS to get all conversation events and add any missed\n        if (this.largestEventIdInQueue > eventId) {\n          this.log.debug(`processNextEvent: largestEventIdInQueue-${this.largestEventIdInQueue} > eventId-${eventId}`);\n          const foundEvent = await this.fetchEventsAndProcess(eventId);\n          if (foundEvent) {\n            this.log.debug(\"processNextEvent: foundEvent \", {\n              foundEvent\n            });\n            await this.callback(foundEvent);\n            return foundEvent;\n          } else {\n            this.log.debug(`processNextEvent: not found process next ${eventId + 1}`);\n            return this.processNextEvent(eventId + 1);\n          }\n        }\n        return;\n      }\n    } catch (e) {\n      return;\n    }\n  }\n  async fetchEventsAndProcess(missingEvent) {\n    //fetch conversation events\n    try {\n      const eventsList = await this.fetchConversationEvents(missingEvent, this.eventsFetchRange);\n      this.log.debug(\"fetchEventsAndProcess: fetched events list \", {\n        eventsList\n      });\n      //check for next event id\n      let foundEvent;\n      eventsList.forEach(event => {\n        //add cid back to fetched event\n        event.cid = this.cid;\n        const eventId = Number(event.id);\n        if (isNaN(eventId) || eventId < missingEvent) return;\n        if (eventId > missingEvent) {\n          this.log.debug(`fetchEventsAndProcess: event > missingEvent ${eventId} `, {\n            missingEvent\n          });\n          this.enqueue(eventId, event);\n        } else {\n          this.log.debug(\"fetchEventsAndProcess: foundEvent \", {\n            event\n          });\n          foundEvent = event;\n        }\n      });\n      return foundEvent;\n    } catch (e) {\n      this.log.debug(\"fetchEventsAndProcess: error \", {\n        e\n      });\n      return;\n    }\n  }\n  async fetchConversationEvents(start_id, range) {\n    this.log.debug(\"fetchConversationEvents: \", this.cid, start_id);\n    // from & to by event id to restrict\n    const end_id = this.largestEventIdInQueue > start_id ? this.largestEventIdInQueue + range : start_id + range;\n    const url = `${this.application.session.config.nexmo_api_url}/beta2/conversations/${this.cid}/events`;\n    try {\n      const response = await utils_1.default.paginationRequest(url, {\n        start_id,\n        end_id\n      }, this.application.session.config.token);\n      const eventsList = response.items;\n      return eventsList;\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n}\nexports.ConversationEventsProcessor = ConversationEventsProcessor;\nmodule.exports = {\n  EventsQueue: EventsQueue,\n  ConversationEventsProcessor: ConversationEventsProcessor\n};","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","nexmoClientError_1","require","utils_1","loglevel_1","EventsQueue","constructor","callback","cidMap","Map","log","getLogger","name","enqueue","event","application","_a","_b","_c","_d","cid","id","eventId","Number","isNaN","get","debug","newConversationEventsProcessor","ConversationEventsProcessor","type","body","media","audio","channel","startingFetchEventId","events","fetchConversationEvents","transferEventFound","forEach","fetchedEvent","from","lastEventIdProcessed","set","conversationEventsProcessor","processing","processingEvents","processEvents","eventsMap","_handleEvent","largestEventIdInQueue","eventsFetchRange","dequeue","delete","doneProcessing","clear","size","nextEventToProcess","processedEvent","processNextEvent","foundEvent","fetchEventsAndProcess","e","missingEvent","eventsList","start_id","range","end_id","url","session","config","nexmo_api_url","response","default","paginationRequest","token","items","error","NexmoApiError","module"],"sources":["/Users/vineetkhodre/react-workspace/thoughtctlchatapp/client/node_modules/nexmo-client/dist/handlers/events_queue.js"],"sourcesContent":["'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n * Events Queue\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst nexmoClientError_1 = require(\"../nexmoClientError\");\nconst utils_1 = __importDefault(require(\"../utils\"));\nconst loglevel_1 = require(\"loglevel\");\n/**\n * Handle Mapping of Conversation Ids to ConversationEventsProcessor\n *\n * @class EventsQueue\n * @private\n */\nclass EventsQueue {\n    constructor(callback) {\n        this.callback = callback;\n        this.cidMap = new Map();\n        this.log = loglevel_1.getLogger(this.constructor.name);\n    }\n    // enqueue(item)\n    async enqueue(event, application) {\n        var _a, _b, _c, _d;\n        //Check if cid or event id and if not just send to application to be processed\n        const { cid, id } = event;\n        const eventId = Number(id);\n        if (!cid || isNaN(eventId))\n            return this.callback(event);\n        // Check if Conversation Events Queue for CID and if not create one\n        if (!this.cidMap.get(cid)) {\n            this.log.debug(`enqueue: create new ConversationEventsProcessor for ${cid}`);\n            const newConversationEventsProcessor = new ConversationEventsProcessor(cid, eventId - 1, application);\n            // edge case for member:media or  member:joined event before transfer or member:joined && channel:id\n            if (event.type == 'member:media' && ((_b = (_a = event.body) === null || _a === void 0 ? void 0 : _a.media) === null || _b === void 0 ? void 0 : _b.audio) ||\n                event.type == 'member:joined' && ((_d = (_c = event.body) === null || _c === void 0 ? void 0 : _c.channel) === null || _d === void 0 ? void 0 : _d.id)) {\n                //fetch last 20 events of conversation & if there is a transfer to this converstaion\n                const startingFetchEventId = eventId - 20 < 1 ? 1 : eventId - 20;\n                const events = await newConversationEventsProcessor.fetchConversationEvents(startingFetchEventId, 20);\n                let transferEventFound = false;\n                events.forEach(fetchedEvent => {\n                    if (fetchedEvent.type === 'rtc:transfer' && fetchedEvent.from === event.from) {\n                        transferEventFound = true;\n                        // reset the events processor to process transfer event next\n                        newConversationEventsProcessor.lastEventIdProcessed = Number(fetchedEvent.id) - 1;\n                    }\n                    if (transferEventFound) {\n                        //Enqueue all events after rtc:transfer event found\n                        newConversationEventsProcessor.enqueue(Number(fetchedEvent.id), fetchedEvent);\n                    }\n                });\n            }\n            this.cidMap.set(cid, newConversationEventsProcessor);\n        }\n        const conversationEventsProcessor = this.cidMap.get(cid);\n        // Add new event to conversation events queue\n        conversationEventsProcessor.enqueue(eventId, event);\n        // If not currently processing events in queue begin processing\n        if (!conversationEventsProcessor.processing) {\n            conversationEventsProcessor.processing = true;\n            const processingEvents = await conversationEventsProcessor.processEvents();\n        }\n        return;\n    }\n}\nexports.EventsQueue = EventsQueue;\n/**\n * Handle Ordering of Conversation Events for Processing\n *\n * @class ConversationEventsProcessor\n * @private\n */\nclass ConversationEventsProcessor {\n    constructor(cid, lastEventIdProcessed, application) {\n        this.cid = cid;\n        this.eventsMap = new Map();\n        this.callback = (event) => application._handleEvent(event);\n        this.lastEventIdProcessed = lastEventIdProcessed;\n        this.largestEventIdInQueue = lastEventIdProcessed;\n        this.processing = false;\n        this.application = application;\n        this.eventsFetchRange = 9;\n        this.log = loglevel_1.getLogger(this.constructor.name);\n    }\n    enqueue(eventId, event) {\n        if (eventId > this.largestEventIdInQueue)\n            this.largestEventIdInQueue = eventId;\n        if (eventId > this.lastEventIdProcessed)\n            this.eventsMap.set(eventId, event);\n        return event;\n    }\n    dequeue(eventId) {\n        const event = this.eventsMap.get(eventId);\n        this.eventsMap.delete(eventId);\n        return event;\n    }\n    async processEvents() {\n        const doneProcessing = () => {\n            this.eventsMap.clear();\n            this.log.debug(`processEvents: Done Processing`);\n            return this.processing = false;\n        };\n        if (this.eventsMap.size < 1)\n            return doneProcessing();\n        const nextEventToProcess = this.lastEventIdProcessed + 1;\n        const processedEvent = await this.processNextEvent(nextEventToProcess);\n        if (processedEvent) {\n            this.lastEventIdProcessed = Number(processedEvent.id);\n            return this.processEvents();\n        }\n        else {\n            return doneProcessing();\n        }\n    }\n    async processNextEvent(eventId) {\n        this.log.debug(`processNextEvent: processing event number ${eventId}`);\n        const event = this.dequeue(eventId);\n        try {\n            if (event) {\n                await this.callback(event);\n                return event;\n            }\n            else {\n                // The next event in the sequence was not in the map, if larger event id in queue (gap)\n                // make a request to CS to get all conversation events and add any missed\n                if (this.largestEventIdInQueue > eventId) {\n                    this.log.debug(`processNextEvent: largestEventIdInQueue-${this.largestEventIdInQueue} > eventId-${eventId}`);\n                    const foundEvent = await this.fetchEventsAndProcess(eventId);\n                    if (foundEvent) {\n                        this.log.debug(\"processNextEvent: foundEvent \", { foundEvent });\n                        await this.callback(foundEvent);\n                        return foundEvent;\n                    }\n                    else {\n                        this.log.debug(`processNextEvent: not found process next ${eventId + 1}`);\n                        return this.processNextEvent(eventId + 1);\n                    }\n                }\n                return;\n            }\n        }\n        catch (e) {\n            return;\n        }\n    }\n    async fetchEventsAndProcess(missingEvent) {\n        //fetch conversation events\n        try {\n            const eventsList = await this.fetchConversationEvents(missingEvent, this.eventsFetchRange);\n            this.log.debug(\"fetchEventsAndProcess: fetched events list \", { eventsList });\n            //check for next event id\n            let foundEvent;\n            eventsList.forEach((event) => {\n                //add cid back to fetched event\n                event.cid = this.cid;\n                const eventId = Number(event.id);\n                if (isNaN(eventId) || eventId < missingEvent)\n                    return;\n                if (eventId > missingEvent) {\n                    this.log.debug(`fetchEventsAndProcess: event > missingEvent ${eventId} `, { missingEvent });\n                    this.enqueue(eventId, event);\n                }\n                else {\n                    this.log.debug(\"fetchEventsAndProcess: foundEvent \", { event });\n                    foundEvent = event;\n                }\n            });\n            return foundEvent;\n        }\n        catch (e) {\n            this.log.debug(\"fetchEventsAndProcess: error \", { e });\n            return;\n        }\n    }\n    async fetchConversationEvents(start_id, range) {\n        this.log.debug(\"fetchConversationEvents: \", this.cid, start_id);\n        // from & to by event id to restrict\n        const end_id = this.largestEventIdInQueue > start_id ? this.largestEventIdInQueue + range : start_id + range;\n        const url = `${this.application.session.config.nexmo_api_url}/beta2/conversations/${this.cid}/events`;\n        try {\n            const response = await utils_1.default.paginationRequest(url, { start_id, end_id }, this.application.session.config.token);\n            const eventsList = response.items;\n            return eventsList;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n}\nexports.ConversationEventsProcessor = ConversationEventsProcessor;\nmodule.exports = {\n    EventsQueue: EventsQueue,\n    ConversationEventsProcessor: ConversationEventsProcessor\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}