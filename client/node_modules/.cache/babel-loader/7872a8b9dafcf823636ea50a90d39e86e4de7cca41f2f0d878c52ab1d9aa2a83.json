{"ast":null,"code":"'use strict';\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Nexmo Client SDK\n *  NXMCall Object Model\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst WildEmitter = require('wildemitter');\nconst loglevel_1 = require(\"loglevel\");\nconst nexmoClientError_1 = require(\"../nexmoClientError\");\nconst rtc_helper_1 = __importDefault(require(\"./rtc_helper\"));\n/**\n * Conversation NXMCall Object.\n * @class NXMCall\n * @param {Application} application - The Application object.\n * @param {Conversation} conversation - The Conversation object that belongs to this nxmCall.\n * @param {Member} from - The member that initiated the nxmCall.\n * @property {Application} application -  The Application object that the nxmCall belongs to.\n * @property {Conversation} conversation -  The Conversation object that belongs to this nxmCall.\n * @property {Member} from - The caller. The member object of the caller (not a reference to the one in conversation.members)\n * @property {Map<string, Member>} to - The callees keyed by a member's id. The members that receive the nxmCall (not a reference to conversation.members)\n * @property {String} id - The nxmCall id (our member's leg_id, comes from rtc:answer event, or member:media)\n * @property {NXMCall.CALL_STATUS} CALL_STATUS=\"started\" - the available nxmCall statuses\n * @property {NXMCall.CALL_DIRECTION} direction - the Direction of the nxmCall, Outbound, Inbound\n * @property {NXMCall.STATUS_PERMITTED_FLOW} STATUS_PERMITTED_FLOW - the permitted nxmCall status transition map, describes the \"from\" and allowed \"to\" transitions\n * @property {object[]} rtcObjects data related to the rtc connection\n * @property {string} rtcObjects.rtc_id the rtc_id\n * @property {PeerConnection} rtcObjects.pc the current PeerConnection object\n * @property {Stream} rtcObjects.stream the stream of the specific rtc_id\n * @property {string} [rtcObjects.type] audio the type of the stream\n * @property {number} rtcObjects.streamIndex the index number of the stream (e.g. use to mute)\n * @property {Stream} stream the remote stream\n * @emits Application#member:call\n * @emits Application#call:status:changed\n*/\n/**\n * Application listening for member call events.\n *\n * @event Application#member:call\n *\n * @property {Member} member - the member that initiated the nxmCall\n * @property {NXMCall} nxmCall -  resolves the nxmCall object\n *\n * @example <caption>listen for member call events on Application level</caption>\n *  application.on(\"member:call\", (member, nxmCall) => {\n *    console.log(\"NXMCall \", nxmCall);\n *  });\n*/\n/**\n * Application listening for nxmCall status changed events.\n *\n * @event Application#call:status:changed\n * @property {NXMCall} nxmCall -  the actual event\n * @example <caption>listen for nxmCall status changed events on Application level</caption>\n *  application.on(\"call:status:changed\",(nxmCall) => {\n *    console.log(\"call: \" + nxmCall.status);\n *  });\n*/\nclass NXMCall {\n  constructor(application, conversation, from) {\n    this.application = application;\n    this.log = loglevel_1.getLogger(this.constructor.name);\n    this.from = from;\n    this.conversation = null;\n    this.rtcObjects = {};\n    /**\n     * Enum for NXMCall status.\n     * @readonly\n     * @enum {string}\n     * @alias NXMCall.CALL_STATUS\n    */\n    this.CALL_STATUS = {\n      /** The NXMCall is in started status */\n      STARTED: 'started',\n      /** The NXMCall is in ringing status */\n      RINGING: 'ringing',\n      /** The NXMCall is in answered status */\n      ANSWERED: 'answered',\n      /** The NXMCall is in completed status */\n      COMPLETED: 'completed',\n      /** The NXMCall is in busy status */\n      BUSY: 'busy',\n      /** The NXMCall is in timeout status */\n      TIMEOUT: 'timeout',\n      /** The NXMCall is in unanswered status */\n      UNANSWERED: 'unanswered',\n      /** The NXMCall is in rejected status */\n      REJECTED: 'rejected',\n      /** The NXMCall is in failed status */\n      FAILED: 'failed'\n    };\n    /**\n     * Enum for NXMCall direction.\n     * @readonly\n     * @enum {string}\n     * @alias NXMCall.CALL_DIRECTION\n    */\n    this.CALL_DIRECTION = {\n      /** The NXMCall started from another end */\n      INBOUND: 'inbound',\n      /** The NXMCall started from this client */\n      OUTBOUND: 'outbound'\n    };\n    Object.freeze(this.CALL_DIRECTION);\n    /**\n     * Enum for the permitted call status transition.\n     * @readonly\n     * @alias NXMCall.STATUS_PERMITTED_FLOW\n     * @enum {Map<string, Set<NXMCall.CALL_STATUS>>}\n    */\n    this.STATUS_PERMITTED_FLOW = new Map([/** Permitted transition array from STARTED  */\n    ['STARTED', new Set([this.CALL_STATUS.RINGING, this.CALL_STATUS.ANSWERED, this.CALL_STATUS.FAILED, this.CALL_STATUS.TIMEOUT, this.CALL_STATUS.UNANSWERED, this.CALL_STATUS.REJECTED, this.CALL_STATUS.BUSY])], /** Permitted transition array from RINGING  */\n    ['RINGING', new Set([this.CALL_STATUS.ANSWERED, this.CALL_STATUS.FAILED, this.CALL_STATUS.TIMEOUT, this.CALL_STATUS.UNANSWERED, this.CALL_STATUS.REJECTED, this.CALL_STATUS.BUSY])], /** Permitted transition set from ANSWERED  */\n    ['ANSWERED', new Set([this.CALL_STATUS.COMPLETED, this.CALL_STATUS.FAILED])]]);\n    Object.freeze(this.STATUS_PERMITTED_FLOW);\n    this.status = null;\n    this.call_disconnect_timeout = null;\n    this.direction = this.CALL_DIRECTION.INBOUND;\n    this._setupConversationObject(conversation);\n    WildEmitter.mixin(NXMCall);\n  }\n  /**\n   * Enable NXMCall stats to be emitted in\n  * - application.inAppCall.on('rtcstats:report')\n  * - application.inAppCall.on('rtcstats:analytics')\n   * @private\n  */\n  _enableStatsEvents() {\n    this.conversation.media._enableStatsEvents();\n  }\n  /**\n   * Attach member event listeners from the conversation\n   * @private\n  */\n  _attachCallListeners() {\n    // Conversation level listeners\n    this.log.debug(\"_attachCallListeners : \", {\n      nxmCall: this\n    });\n    try {\n      this.conversation.releaseGroup('call_module');\n      this.conversation.on('member:media', 'call_module', (from, event) => {\n        if (this.application.calls && this.application.calls.has(this.conversation.id)) {\n          this.application.calls.get(this.conversation.id)._handleStatusChange(event);\n        }\n      });\n    } catch (e) {\n      this.log.error(\"_attachCallListeners_error: \", {\n        e\n      });\n    }\n  }\n  /**\n   * Validate the current nxmCall status transition\n   * If a transition is not defined, return false\n   * @param {string} status the status to validate\n   * @returns {boolean} false if the transition is not permitted\n   * @private\n  */\n  _isValidStatusTransition(status) {\n    if (!status) {\n      throw new nexmoClientError_1.NexmoClientError(`Provide the status to validate the transition from '${this.status}'`);\n    }\n    // if the nxmCall object is just initialised allow any state\n    if (!this.status) {\n      return true;\n    }\n    const current_status = this.status.toUpperCase();\n    if (!this.STATUS_PERMITTED_FLOW.has(current_status)) {\n      return false;\n    }\n    if (this.status === status) {\n      return false;\n    }\n    return this.STATUS_PERMITTED_FLOW.get(current_status).has(status);\n  }\n  /**\n   * Go through the members of the conversation and if .me is the only one (JOINED or INVITED)\n   * nxmCall nxmCall.hangUp().\n   * @returns {Promise} - empty promise or the nxmCall.hangUp promise chain\n  */\n  hangUpIfAllLeft() {\n    this.log.debug(\"hangUpIfAllLeft: \", {\n      nxmCall: this\n    });\n    if (!this.conversation.me || this.conversation.me.state === 'LEFT' || this.conversation.members.size <= 1) {\n      return Promise.resolve();\n    }\n    for (let member of this.conversation.members.values()) {\n      if (member.state !== 'LEFT' && this.conversation.me.user.id !== member.user.id) {\n        return Promise.resolve();\n      }\n    }\n    return this.hangUp();\n  }\n  /**\n   * Set the conversation object of the NXMCall\n   * update nxmCall.from, and nxmCall.to attributes based on the conversation members\n   * @private\n  */\n  _setupConversationObject(conversation, rtc_id) {\n    if (!conversation) return;\n    this.conversation = conversation;\n    if (!conversation.me) {\n      this.log.warn('missing own member object');\n    } else {\n      this.to = new Map(conversation.members);\n      if (this.from) {\n        this.to.delete(this.from.id);\n      }\n    }\n    // Attch Conversation Listeners\n    this._attachCallListeners();\n  }\n  /**\n   * Set the from object of the NXMCall\n   * @private\n  */\n  _setFrom(from) {\n    this.from = from;\n  }\n  /**\n   * Set the from object of the NXMCall\n   * @private\n  */\n  _setOffer(offer) {\n    this.offer = offer;\n  }\n  /**\n   * Process raw events to figure out the nxmCall status\n   * @private\n  */\n  _handleStatusChange(event) {\n    var _a;\n    // for knocking case the conversation object is not yet set in the nxmCall. We know the action is initiated from us\n    const _isEventFromMe = this.conversation ? ((_a = this.conversation.me) === null || _a === void 0 ? void 0 : _a.id) === event.from : true;\n    const _isOutbound = this.direction === this.CALL_DIRECTION.OUTBOUND;\n    this.log.debug(\"_handleStatusChange: \", {\n      event\n    }, `_isEventFromMe: ${_isEventFromMe} _isOutbound: ${_isOutbound}`);\n    let _handleStatusChangeMap = new Map();\n    _handleStatusChangeMap.set('member:joined', async () => {\n      if (event.body.channel && event.body.channel.id) {\n        try {\n          this._setStatusAndEmit(this.CALL_STATUS.STARTED);\n          return;\n        } catch (error) {\n          this._setStatusAndEmit(this.CALL_STATUS.FAILED);\n          this.log.error(error);\n          throw error;\n        }\n      }\n      return Promise.resolve();\n    });\n    _handleStatusChangeMap.set('member:invited', () => {\n      if (event.body.invited_by === null && event.body.user.media && event.body.user.media.audio_settings) {\n        this._setStatusAndEmit(this.CALL_STATUS.STARTED);\n      }\n      return Promise.resolve();\n    });\n    _handleStatusChangeMap.set('rtc:hangup', () => {\n      if (this.status === this.CALL_STATUS.ANSWERED) {\n        this._setStatusAndEmit(this.CALL_STATUS.COMPLETED);\n        return Promise.resolve();\n      } else {\n        if (_isEventFromMe && _isOutbound || !_isEventFromMe && !_isOutbound) {\n          this._setStatusAndEmit(this.CALL_STATUS.UNANSWERED);\n          return Promise.resolve();\n        } else {\n          this._setStatusAndEmit(this.CALL_STATUS.REJECTED);\n          return Promise.resolve();\n        }\n      }\n    });\n    _handleStatusChangeMap.set('member:left', () => {\n      if (!event.body.timestamp.hasOwnProperty('joined') && this.status !== this.CALL_STATUS.ANSWERED) {\n        if (_isEventFromMe && _isOutbound || !_isEventFromMe && !_isOutbound) {\n          this._setStatusAndEmit(this.CALL_STATUS.UNANSWERED);\n          return Promise.resolve();\n        } else {\n          this._setStatusAndEmit(this.CALL_STATUS.REJECTED);\n          return Promise.resolve();\n        }\n      }\n    });\n    _handleStatusChangeMap.set('member:media', () => {\n      if (this.status !== this.CALL_STATUS.ANSWERED && event.body.audio) {\n        if (_isEventFromMe && event.body.channel) {\n          this.id = event.body.channel.id;\n        }\n        if ((!_isEventFromMe || !_isOutbound) && this.id) {\n          this._setStatusAndEmit(this.CALL_STATUS.ANSWERED);\n        }\n      }\n      return Promise.resolve();\n    });\n    _handleStatusChangeMap.set('sip:ringing', () => {\n      if (this.status !== this.CALL_STATUS.RINGING) {\n        this._setStatusAndEmit(this.CALL_STATUS.RINGING);\n      }\n      return Promise.resolve();\n    });\n    _handleStatusChangeMap.set('sip:hangup', () => {\n      switch (event.body.reason.sip_code) {\n        case 486:\n          this._setStatusAndEmit(this.CALL_STATUS.BUSY);\n          break;\n        case 487:\n          this._setStatusAndEmit(this.CALL_STATUS.TIMEOUT);\n          break;\n        case 403:\n          this._setStatusAndEmit(this.CALL_STATUS.FAILED);\n          break;\n      }\n      return Promise.resolve();\n    });\n    _handleStatusChangeMap.set('knocking:delete:success', () => {\n      this._setStatusAndEmit(this.CALL_STATUS.UNANSWERED);\n      return Promise.resolve();\n    });\n    if (_handleStatusChangeMap.has(event.type)) {\n      return _handleStatusChangeMap.get(event.type).call(this);\n    }\n  }\n  /**\n   * Set the nxmCall.status and emit a call:status:changed event\n   *\n   * @param {NXMCall.CALL_STATUS} this.CALL_STATUS the canxmCallll status to set\n   * @emits Application#call:status:changed\n   * @private\n  */\n  _setStatusAndEmit(status) {\n    if (!this._isValidStatusTransition(status)) {\n      return;\n    }\n    this.status = status;\n    this.log.debug(`_setStatusAndEmit: ${status}`, {\n      nxmCall: this\n    });\n    this.application.emit('call:status:changed', this);\n  }\n  /**\n   * Answers an incoming nxmCall\n   * Join the conversation that you are invited\n   * Create autoplay Audio object\n   *\n  * @param {boolean} [autoPlayAudio=true] attach the audio stream automatically to start playing (default true)\n   * @returns {Promise<Audio>}\n  */\n  async answer(autoPlayAudio = true) {\n    this.log.debug(`answer: { autoPlayAudio: ${autoPlayAudio}`);\n    if (this.conversation) {\n      try {\n        await this.conversation.join();\n        const stream = await this.conversation.media.enable({\n          autoPlayAudio,\n          offer: this.offer\n        });\n        this.offer = undefined;\n        return stream;\n      } catch (error) {\n        this._setStatusAndEmit(this.CALL_STATUS.FAILED);\n        this.log.error(error);\n        throw error;\n      }\n    } else {\n      throw new nexmoClientError_1.NexmoClientError('error:call:answer');\n    }\n  }\n  /**\n   * Trigger the nxmCall flow for the input users.\n   * Create a conversation with prefix name \"CALL_\"\n   * and invite all the users.\n   * If at least one user is successfully invited, enable the audio.\n   *\n   * @param {string[]} usernames the usernames of the users to call\n  * @param {boolean} [autoPlayAudio=true] attach the audio stream automatically to start playing (default true)\n   * @returns {Promise[]} an array of the invite promises for the provided usernames\n   * @private\n  */\n  async createCall(usernames, autoPlayAudio = true) {\n    this.log.debug(`createCall: { usernames: ${usernames}, autoPlayAudio: ${autoPlayAudio} }`);\n    if (!usernames || !Array.isArray(usernames) || usernames.length === 0) {\n      return Promise.reject(new nexmoClientError_1.NexmoClientError('error:application:call:params'));\n    }\n    try {\n      const conversation = await this.application.newConversationAndJoin({\n        display_name: 'CALL_' + this.application.me.name + '_' + usernames.join('_').replace(' ', '')\n      });\n      conversation.members.set(conversation.me.id, conversation.me);\n      this.from = conversation.me;\n      this.successful_invited_members = new Map();\n      const invites = usernames.map(async username => {\n        // check all invites, if at least one is resolved enable audio\n        // we need to catch rejections to allow all the chain to go through (all invites)\n        // we then catch-reject a promise so that the errors are passing through the end of the chain\n        try {\n          const member = await conversation.inviteWithAudio({\n            user_name: username\n          });\n          conversation.members.set(member.id, member);\n          this.successful_invited_members.set(member.id, member);\n          return member;\n        } catch (error) {\n          this.log.error(error);\n          // resolve the error to allow the promise.all to collect\n          // and return all the promises\n          return error;\n        }\n      });\n      // helper function to process in Promise.all() the failed invites too\n      const process_invites = async () => {\n        if (this.successful_invited_members.size > 0) {\n          await conversation.media.enable({\n            audio: {\n              muted: false,\n              earmuffed: false\n            },\n            autoPlayAudio\n          });\n          this.application.calls.set(conversation.id, this);\n          return invites;\n        } else {\n          throw invites;\n        }\n      };\n      // we need to continue the invites even if one fails,\n      // in process_invites we do the check if at least one was successful\n      await Promise.all(invites);\n      this._setupConversationObject(conversation);\n      return await process_invites();\n    } catch (error) {\n      this.log.error(error);\n      this._setStatusAndEmit(this.CALL_STATUS.FAILED);\n      throw error;\n    }\n  }\n  /**\n   * Trigger the nxmCall flow for the phone call.\n   * Create a knocking event\n   *\n   * @param {string} user the phone number or the username to call\n  * @param {string} type the type of the call you want to have. possible values \"phone\" or \"app\" (default is \"phone\")\n   * @returns {Promise}\n   * @private\n  */\n  async createServerCall(user, type, custom_data) {\n    this.log.debug(`createServerCall: { user: ${user}, type: ${type}, custom_data: `, {\n      custom_data\n    });\n    const to = {\n      type\n    };\n    if (type === 'phone') {\n      to.number = user;\n    } else {\n      to.user = user;\n    }\n    try {\n      // PrewarmLeg\n      const {\n        stream,\n        legId,\n        rtcObjects\n      } = await rtc_helper_1.default.prewarmLeg(this);\n      this.log.debug(\"createServerCall: \", {\n        stream\n      }, {\n        legId\n      }, {\n        rtcObjects\n      });\n      // Add Media to the Call Object\n      this.rtcObjects = rtcObjects;\n      this.stream = stream;\n      this.id = legId;\n      // Add leg_id to the call draft list\n      this.application._call_draft_list.set(legId, this);\n      rtc_helper_1.default.playAudioStream(stream);\n      const params = {\n        type: 'POST',\n        path: 'knocking',\n        data: {\n          channel: {\n            type: 'app',\n            from: {\n              type: 'app'\n            },\n            to,\n            id: legId || null\n          },\n          ...(custom_data && Object.keys(custom_data).length && {\n            properties: {\n              custom_data\n            }\n          })\n        }\n      };\n      try {\n        const knockingResponse = await this.application.session.sendNetworkRequest(params);\n        this.knocking_id = knockingResponse.id;\n      } catch (error) {\n        throw new nexmoClientError_1.NexmoApiError(error);\n      }\n      // If knocking request doesn't result in member:joined after set time disable audio, cleanup media\n      rtc_helper_1.default.cleanCallMediaIfFailed(this);\n      return stream;\n    } catch (error) {\n      // If knocking request fails disable audio, cleanup media\n      rtc_helper_1.default.cleanMediaProperties(this);\n      throw error;\n    }\n  }\n  /**\n   * Hangs up the nxmCall\n   *\n   * If there is a knocking active, do a knocking:delete\n   * otherwise\n   * Leave from the conversation\n   * Disable the audio\n   *\n  * @param {object} [reason] the reason for hanging up the nxmCall\n  * @param {string} [reason.reason_code] the code of the reason\n  * @param {string} [reason.reason_text] the description of the reason\n   * @returns {Promise}\n  */\n  async hangUp(reason) {\n    this.log.debug(`hangUp: { reason: ${reason} }`);\n    if (this.conversation) {\n      await this.conversation.media.disable();\n    }\n    if (!this.knocking_id && this.conversation) {\n      return this.conversation.leave(reason).catch(error => {\n        if (error.type !== \"conversation:error:invalid-member-state\") {\n          return Promise.reject(error);\n        }\n      });\n    } else {\n      let path = `knocking/${this.knocking_id}`;\n      if (reason) {\n        let params = new URLSearchParams();\n        Object.keys(reason).forEach(key => {\n          params.append(key, reason[key]);\n        });\n        path += `?${params.toString()}`;\n      }\n      try {\n        const response = await this.application.session.sendNetworkRequest({\n          type: 'DELETE',\n          path\n        });\n        const nxmCall = this.application._call_draft_list.get(this.client_ref);\n        nxmCall._handleStatusChange(response);\n        this.application._call_draft_list.delete(this.client_ref);\n        return response;\n      } catch (error) {\n        // Don't switch yet to fail status, it could be an expected race between knocking:delete and conversation.leave\n        if (!this.conversation) {\n          this.log.debug('hangup: Problem cancelling the call. Knocking cancel failed and Conversation. Leave not available', error);\n          return;\n        } else {\n          this.log.error(new nexmoClientError_1.NexmoApiError(error));\n          return this.conversation.leave(reason);\n        }\n      }\n    }\n  }\n  /**\n   * Rejects an incoming nxmCall\n   * Leave from the conversation that you are invited\n   *\n  * @param {object} [reason] the reason for rejecting the nxmCall\n  * @param {string} [reason.reason_code] the code of the reason\n  * @param {string} [reason.reason_text] the description of the reason\n   * @returns {Promise}\n  */\n  reject(reason) {\n    this.log.debug(`reject: { reason: ${reason} }`);\n    if (this.conversation) {\n      return this.conversation.leave(reason);\n    } else {\n      return Promise.reject(new nexmoClientError_1.NexmoClientError('error:call:reject'));\n    }\n  }\n}\nexports.default = NXMCall;\nmodule.exports = NXMCall;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","WildEmitter","require","loglevel_1","nexmoClientError_1","rtc_helper_1","NXMCall","constructor","application","conversation","from","log","getLogger","name","rtcObjects","CALL_STATUS","STARTED","RINGING","ANSWERED","COMPLETED","BUSY","TIMEOUT","UNANSWERED","REJECTED","FAILED","CALL_DIRECTION","INBOUND","OUTBOUND","freeze","STATUS_PERMITTED_FLOW","Map","Set","status","call_disconnect_timeout","direction","_setupConversationObject","mixin","_enableStatsEvents","media","_attachCallListeners","debug","nxmCall","releaseGroup","on","event","calls","has","id","get","_handleStatusChange","e","error","_isValidStatusTransition","NexmoClientError","current_status","toUpperCase","hangUpIfAllLeft","me","state","members","size","Promise","resolve","member","values","user","hangUp","rtc_id","warn","to","delete","_setFrom","_setOffer","offer","_a","_isEventFromMe","_isOutbound","_handleStatusChangeMap","set","body","channel","_setStatusAndEmit","invited_by","audio_settings","timestamp","hasOwnProperty","audio","reason","sip_code","type","call","emit","answer","autoPlayAudio","join","stream","enable","undefined","createCall","usernames","Array","isArray","length","reject","newConversationAndJoin","display_name","replace","successful_invited_members","invites","map","username","inviteWithAudio","user_name","process_invites","muted","earmuffed","all","createServerCall","custom_data","number","legId","default","prewarmLeg","_call_draft_list","playAudioStream","params","path","data","keys","properties","knockingResponse","session","sendNetworkRequest","knocking_id","NexmoApiError","cleanCallMediaIfFailed","cleanMediaProperties","disable","leave","catch","URLSearchParams","forEach","key","append","toString","response","client_ref","module"],"sources":["/Users/vineetkhodre/react-workspace/thoughtctlchatapp/client/node_modules/nexmo-client/dist/modules/nxmCall.js"],"sourcesContent":["'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  NXMCall Object Model\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst WildEmitter = require('wildemitter');\nconst loglevel_1 = require(\"loglevel\");\nconst nexmoClientError_1 = require(\"../nexmoClientError\");\nconst rtc_helper_1 = __importDefault(require(\"./rtc_helper\"));\n/**\n * Conversation NXMCall Object.\n * @class NXMCall\n * @param {Application} application - The Application object.\n * @param {Conversation} conversation - The Conversation object that belongs to this nxmCall.\n * @param {Member} from - The member that initiated the nxmCall.\n * @property {Application} application -  The Application object that the nxmCall belongs to.\n * @property {Conversation} conversation -  The Conversation object that belongs to this nxmCall.\n * @property {Member} from - The caller. The member object of the caller (not a reference to the one in conversation.members)\n * @property {Map<string, Member>} to - The callees keyed by a member's id. The members that receive the nxmCall (not a reference to conversation.members)\n * @property {String} id - The nxmCall id (our member's leg_id, comes from rtc:answer event, or member:media)\n * @property {NXMCall.CALL_STATUS} CALL_STATUS=\"started\" - the available nxmCall statuses\n * @property {NXMCall.CALL_DIRECTION} direction - the Direction of the nxmCall, Outbound, Inbound\n * @property {NXMCall.STATUS_PERMITTED_FLOW} STATUS_PERMITTED_FLOW - the permitted nxmCall status transition map, describes the \"from\" and allowed \"to\" transitions\n * @property {object[]} rtcObjects data related to the rtc connection\n * @property {string} rtcObjects.rtc_id the rtc_id\n * @property {PeerConnection} rtcObjects.pc the current PeerConnection object\n * @property {Stream} rtcObjects.stream the stream of the specific rtc_id\n * @property {string} [rtcObjects.type] audio the type of the stream\n * @property {number} rtcObjects.streamIndex the index number of the stream (e.g. use to mute)\n * @property {Stream} stream the remote stream\n * @emits Application#member:call\n * @emits Application#call:status:changed\n*/\n/**\n * Application listening for member call events.\n *\n * @event Application#member:call\n *\n * @property {Member} member - the member that initiated the nxmCall\n * @property {NXMCall} nxmCall -  resolves the nxmCall object\n *\n * @example <caption>listen for member call events on Application level</caption>\n *  application.on(\"member:call\", (member, nxmCall) => {\n *    console.log(\"NXMCall \", nxmCall);\n *  });\n*/\n/**\n * Application listening for nxmCall status changed events.\n *\n * @event Application#call:status:changed\n * @property {NXMCall} nxmCall -  the actual event\n * @example <caption>listen for nxmCall status changed events on Application level</caption>\n *  application.on(\"call:status:changed\",(nxmCall) => {\n *    console.log(\"call: \" + nxmCall.status);\n *  });\n*/\nclass NXMCall {\n    constructor(application, conversation, from) {\n        this.application = application;\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        this.from = from;\n        this.conversation = null;\n        this.rtcObjects = {};\n        /**\n         * Enum for NXMCall status.\n         * @readonly\n         * @enum {string}\n         * @alias NXMCall.CALL_STATUS\n        */\n        this.CALL_STATUS = {\n            /** The NXMCall is in started status */\n            STARTED: 'started',\n            /** The NXMCall is in ringing status */\n            RINGING: 'ringing',\n            /** The NXMCall is in answered status */\n            ANSWERED: 'answered',\n            /** The NXMCall is in completed status */\n            COMPLETED: 'completed',\n            /** The NXMCall is in busy status */\n            BUSY: 'busy',\n            /** The NXMCall is in timeout status */\n            TIMEOUT: 'timeout',\n            /** The NXMCall is in unanswered status */\n            UNANSWERED: 'unanswered',\n            /** The NXMCall is in rejected status */\n            REJECTED: 'rejected',\n            /** The NXMCall is in failed status */\n            FAILED: 'failed'\n        };\n        /**\n         * Enum for NXMCall direction.\n         * @readonly\n         * @enum {string}\n         * @alias NXMCall.CALL_DIRECTION\n        */\n        this.CALL_DIRECTION = {\n            /** The NXMCall started from another end */\n            INBOUND: 'inbound',\n            /** The NXMCall started from this client */\n            OUTBOUND: 'outbound'\n        };\n        Object.freeze(this.CALL_DIRECTION);\n        /**\n         * Enum for the permitted call status transition.\n         * @readonly\n         * @alias NXMCall.STATUS_PERMITTED_FLOW\n         * @enum {Map<string, Set<NXMCall.CALL_STATUS>>}\n        */\n        this.STATUS_PERMITTED_FLOW = new Map([\n            /** Permitted transition array from STARTED  */\n            ['STARTED', new Set([\n                    this.CALL_STATUS.RINGING,\n                    this.CALL_STATUS.ANSWERED,\n                    this.CALL_STATUS.FAILED,\n                    this.CALL_STATUS.TIMEOUT,\n                    this.CALL_STATUS.UNANSWERED,\n                    this.CALL_STATUS.REJECTED,\n                    this.CALL_STATUS.BUSY\n                ])],\n            /** Permitted transition array from RINGING  */\n            ['RINGING', new Set([\n                    this.CALL_STATUS.ANSWERED,\n                    this.CALL_STATUS.FAILED,\n                    this.CALL_STATUS.TIMEOUT,\n                    this.CALL_STATUS.UNANSWERED,\n                    this.CALL_STATUS.REJECTED,\n                    this.CALL_STATUS.BUSY\n                ])],\n            /** Permitted transition set from ANSWERED  */\n            ['ANSWERED', new Set([\n                    this.CALL_STATUS.COMPLETED,\n                    this.CALL_STATUS.FAILED\n                ])]\n        ]);\n        Object.freeze(this.STATUS_PERMITTED_FLOW);\n        this.status = null;\n        this.call_disconnect_timeout = null;\n        this.direction = this.CALL_DIRECTION.INBOUND;\n        this._setupConversationObject(conversation);\n        WildEmitter.mixin(NXMCall);\n    }\n    /**\n     * Enable NXMCall stats to be emitted in\n   * - application.inAppCall.on('rtcstats:report')\n   * - application.inAppCall.on('rtcstats:analytics')\n     * @private\n    */\n    _enableStatsEvents() {\n        this.conversation.media._enableStatsEvents();\n    }\n    /**\n     * Attach member event listeners from the conversation\n     * @private\n    */\n    _attachCallListeners() {\n        // Conversation level listeners\n        this.log.debug(\"_attachCallListeners : \", { nxmCall: this });\n        try {\n            this.conversation.releaseGroup('call_module');\n            this.conversation.on('member:media', 'call_module', (from, event) => {\n                if (this.application.calls && this.application.calls.has(this.conversation.id)) {\n                    this.application.calls.get(this.conversation.id)._handleStatusChange(event);\n                }\n            });\n        }\n        catch (e) {\n            this.log.error(\"_attachCallListeners_error: \", { e });\n        }\n    }\n    /**\n     * Validate the current nxmCall status transition\n     * If a transition is not defined, return false\n     * @param {string} status the status to validate\n     * @returns {boolean} false if the transition is not permitted\n     * @private\n    */\n    _isValidStatusTransition(status) {\n        if (!status) {\n            throw new nexmoClientError_1.NexmoClientError(`Provide the status to validate the transition from '${this.status}'`);\n        }\n        // if the nxmCall object is just initialised allow any state\n        if (!this.status) {\n            return true;\n        }\n        const current_status = this.status.toUpperCase();\n        if (!this.STATUS_PERMITTED_FLOW.has(current_status)) {\n            return false;\n        }\n        if (this.status === status) {\n            return false;\n        }\n        return (this.STATUS_PERMITTED_FLOW.get(current_status).has(status));\n    }\n    /**\n     * Go through the members of the conversation and if .me is the only one (JOINED or INVITED)\n     * nxmCall nxmCall.hangUp().\n     * @returns {Promise} - empty promise or the nxmCall.hangUp promise chain\n    */\n    hangUpIfAllLeft() {\n        this.log.debug(\"hangUpIfAllLeft: \", { nxmCall: this });\n        if (!this.conversation.me || this.conversation.me.state === 'LEFT' || this.conversation.members.size <= 1) {\n            return Promise.resolve();\n        }\n        for (let member of this.conversation.members.values()) {\n            if (member.state !== 'LEFT' && (this.conversation.me.user.id !== member.user.id)) {\n                return Promise.resolve();\n            }\n        }\n        return this.hangUp();\n    }\n    /**\n     * Set the conversation object of the NXMCall\n     * update nxmCall.from, and nxmCall.to attributes based on the conversation members\n     * @private\n    */\n    _setupConversationObject(conversation, rtc_id) {\n        if (!conversation)\n            return;\n        this.conversation = conversation;\n        if (!conversation.me) {\n            this.log.warn('missing own member object');\n        }\n        else {\n            this.to = new Map(conversation.members);\n            if (this.from) {\n                this.to.delete(this.from.id);\n            }\n        }\n        // Attch Conversation Listeners\n        this._attachCallListeners();\n    }\n    /**\n     * Set the from object of the NXMCall\n     * @private\n    */\n    _setFrom(from) {\n        this.from = from;\n    }\n    /**\n     * Set the from object of the NXMCall\n     * @private\n    */\n    _setOffer(offer) {\n        this.offer = offer;\n    }\n    /**\n     * Process raw events to figure out the nxmCall status\n     * @private\n    */\n    _handleStatusChange(event) {\n        var _a;\n        // for knocking case the conversation object is not yet set in the nxmCall. We know the action is initiated from us\n        const _isEventFromMe = (this.conversation) ? ((_a = this.conversation.me) === null || _a === void 0 ? void 0 : _a.id) === event.from : true;\n        const _isOutbound = this.direction === this.CALL_DIRECTION.OUTBOUND;\n        this.log.debug(\"_handleStatusChange: \", { event }, `_isEventFromMe: ${_isEventFromMe} _isOutbound: ${_isOutbound}`);\n        let _handleStatusChangeMap = new Map();\n        _handleStatusChangeMap.set('member:joined', async () => {\n            if (event.body.channel && event.body.channel.id) {\n                try {\n                    this._setStatusAndEmit(this.CALL_STATUS.STARTED);\n                    return;\n                }\n                catch (error) {\n                    this._setStatusAndEmit(this.CALL_STATUS.FAILED);\n                    this.log.error(error);\n                    throw error;\n                }\n            }\n            return Promise.resolve();\n        });\n        _handleStatusChangeMap.set('member:invited', () => {\n            if (event.body.invited_by === null &&\n                event.body.user.media &&\n                event.body.user.media.audio_settings) {\n                this._setStatusAndEmit(this.CALL_STATUS.STARTED);\n            }\n            return Promise.resolve();\n        });\n        _handleStatusChangeMap.set('rtc:hangup', () => {\n            if (this.status === this.CALL_STATUS.ANSWERED) {\n                this._setStatusAndEmit(this.CALL_STATUS.COMPLETED);\n                return Promise.resolve();\n            }\n            else {\n                if (_isEventFromMe && _isOutbound || !_isEventFromMe && !_isOutbound) {\n                    this._setStatusAndEmit(this.CALL_STATUS.UNANSWERED);\n                    return Promise.resolve();\n                }\n                else {\n                    this._setStatusAndEmit(this.CALL_STATUS.REJECTED);\n                    return Promise.resolve();\n                }\n            }\n        });\n        _handleStatusChangeMap.set('member:left', () => {\n            if (!event.body.timestamp.hasOwnProperty('joined') && this.status !== this.CALL_STATUS.ANSWERED) {\n                if (_isEventFromMe && _isOutbound || !_isEventFromMe && !_isOutbound) {\n                    this._setStatusAndEmit(this.CALL_STATUS.UNANSWERED);\n                    return Promise.resolve();\n                }\n                else {\n                    this._setStatusAndEmit(this.CALL_STATUS.REJECTED);\n                    return Promise.resolve();\n                }\n            }\n        });\n        _handleStatusChangeMap.set('member:media', () => {\n            if (this.status !== this.CALL_STATUS.ANSWERED && event.body.audio) {\n                if (_isEventFromMe && event.body.channel) {\n                    this.id = event.body.channel.id;\n                }\n                if ((!_isEventFromMe || !_isOutbound) && this.id) {\n                    this._setStatusAndEmit(this.CALL_STATUS.ANSWERED);\n                }\n            }\n            return Promise.resolve();\n        });\n        _handleStatusChangeMap.set('sip:ringing', () => {\n            if (this.status !== this.CALL_STATUS.RINGING) {\n                this._setStatusAndEmit(this.CALL_STATUS.RINGING);\n            }\n            return Promise.resolve();\n        });\n        _handleStatusChangeMap.set('sip:hangup', () => {\n            switch (event.body.reason.sip_code) {\n                case 486:\n                    this._setStatusAndEmit(this.CALL_STATUS.BUSY);\n                    break;\n                case 487:\n                    this._setStatusAndEmit(this.CALL_STATUS.TIMEOUT);\n                    break;\n                case 403:\n                    this._setStatusAndEmit(this.CALL_STATUS.FAILED);\n                    break;\n            }\n            return Promise.resolve();\n        });\n        _handleStatusChangeMap.set('knocking:delete:success', () => {\n            this._setStatusAndEmit(this.CALL_STATUS.UNANSWERED);\n            return Promise.resolve();\n        });\n        if (_handleStatusChangeMap.has(event.type)) {\n            return _handleStatusChangeMap.get(event.type).call(this);\n        }\n    }\n    /**\n     * Set the nxmCall.status and emit a call:status:changed event\n     *\n     * @param {NXMCall.CALL_STATUS} this.CALL_STATUS the canxmCallll status to set\n     * @emits Application#call:status:changed\n     * @private\n    */\n    _setStatusAndEmit(status) {\n        if (!this._isValidStatusTransition(status)) {\n            return;\n        }\n        this.status = status;\n        this.log.debug(`_setStatusAndEmit: ${status}`, { nxmCall: this });\n        this.application.emit('call:status:changed', this);\n    }\n    /**\n     * Answers an incoming nxmCall\n     * Join the conversation that you are invited\n     * Create autoplay Audio object\n     *\n   * @param {boolean} [autoPlayAudio=true] attach the audio stream automatically to start playing (default true)\n     * @returns {Promise<Audio>}\n    */\n    async answer(autoPlayAudio = true) {\n        this.log.debug(`answer: { autoPlayAudio: ${autoPlayAudio}`);\n        if (this.conversation) {\n            try {\n                await this.conversation.join();\n                const stream = await this.conversation.media.enable({ autoPlayAudio, offer: this.offer });\n                this.offer = undefined;\n                return stream;\n            }\n            catch (error) {\n                this._setStatusAndEmit(this.CALL_STATUS.FAILED);\n                this.log.error(error);\n                throw error;\n            }\n        }\n        else {\n            throw new nexmoClientError_1.NexmoClientError('error:call:answer');\n        }\n    }\n    /**\n     * Trigger the nxmCall flow for the input users.\n     * Create a conversation with prefix name \"CALL_\"\n     * and invite all the users.\n     * If at least one user is successfully invited, enable the audio.\n     *\n     * @param {string[]} usernames the usernames of the users to call\n   * @param {boolean} [autoPlayAudio=true] attach the audio stream automatically to start playing (default true)\n     * @returns {Promise[]} an array of the invite promises for the provided usernames\n     * @private\n    */\n    async createCall(usernames, autoPlayAudio = true) {\n        this.log.debug(`createCall: { usernames: ${usernames}, autoPlayAudio: ${autoPlayAudio} }`);\n        if (!usernames || !Array.isArray(usernames) || usernames.length === 0) {\n            return Promise.reject(new nexmoClientError_1.NexmoClientError('error:application:call:params'));\n        }\n        try {\n            const conversation = await this.application.newConversationAndJoin({ display_name: 'CALL_' + this.application.me.name + '_' + usernames.join('_').replace(' ', '') });\n            conversation.members.set(conversation.me.id, conversation.me);\n            this.from = conversation.me;\n            this.successful_invited_members = new Map();\n            const invites = usernames.map(async (username) => {\n                // check all invites, if at least one is resolved enable audio\n                // we need to catch rejections to allow all the chain to go through (all invites)\n                // we then catch-reject a promise so that the errors are passing through the end of the chain\n                try {\n                    const member = await conversation.inviteWithAudio({ user_name: username });\n                    conversation.members.set(member.id, member);\n                    this.successful_invited_members.set(member.id, member);\n                    return member;\n                }\n                catch (error) {\n                    this.log.error(error);\n                    // resolve the error to allow the promise.all to collect\n                    // and return all the promises\n                    return error;\n                }\n            });\n            // helper function to process in Promise.all() the failed invites too\n            const process_invites = async () => {\n                if (this.successful_invited_members.size > 0) {\n                    await conversation.media.enable({\n                        audio: {\n                            muted: false,\n                            earmuffed: false\n                        },\n                        autoPlayAudio\n                    });\n                    this.application.calls.set(conversation.id, this);\n                    return invites;\n                }\n                else {\n                    throw invites;\n                }\n            };\n            // we need to continue the invites even if one fails,\n            // in process_invites we do the check if at least one was successful\n            await Promise.all(invites);\n            this._setupConversationObject(conversation);\n            return await process_invites();\n        }\n        catch (error) {\n            this.log.error(error);\n            this._setStatusAndEmit(this.CALL_STATUS.FAILED);\n            throw error;\n        }\n    }\n    /**\n     * Trigger the nxmCall flow for the phone call.\n     * Create a knocking event\n     *\n     * @param {string} user the phone number or the username to call\n   * @param {string} type the type of the call you want to have. possible values \"phone\" or \"app\" (default is \"phone\")\n     * @returns {Promise}\n     * @private\n    */\n    async createServerCall(user, type, custom_data) {\n        this.log.debug(`createServerCall: { user: ${user}, type: ${type}, custom_data: `, { custom_data });\n        const to = {\n            type\n        };\n        if (type === 'phone') {\n            to.number = user;\n        }\n        else {\n            to.user = user;\n        }\n        try {\n            // PrewarmLeg\n            const { stream, legId, rtcObjects } = await rtc_helper_1.default.prewarmLeg(this);\n            this.log.debug(\"createServerCall: \", { stream }, { legId }, { rtcObjects });\n            // Add Media to the Call Object\n            this.rtcObjects = rtcObjects;\n            this.stream = stream;\n            this.id = legId;\n            // Add leg_id to the call draft list\n            this.application._call_draft_list.set(legId, this);\n            rtc_helper_1.default.playAudioStream(stream);\n            const params = {\n                type: 'POST',\n                path: 'knocking',\n                data: {\n                    channel: {\n                        type: 'app',\n                        from: { type: 'app' },\n                        to,\n                        id: legId || null\n                    },\n                    ...(custom_data && Object.keys(custom_data).length && { properties: { custom_data } })\n                }\n            };\n            try {\n                const knockingResponse = await this.application.session.sendNetworkRequest(params);\n                this.knocking_id = knockingResponse.id;\n            }\n            catch (error) {\n                throw new nexmoClientError_1.NexmoApiError(error);\n            }\n            // If knocking request doesn't result in member:joined after set time disable audio, cleanup media\n            rtc_helper_1.default.cleanCallMediaIfFailed(this);\n            return stream;\n        }\n        catch (error) {\n            // If knocking request fails disable audio, cleanup media\n            rtc_helper_1.default.cleanMediaProperties(this);\n            throw error;\n        }\n    }\n    /**\n     * Hangs up the nxmCall\n     *\n     * If there is a knocking active, do a knocking:delete\n     * otherwise\n     * Leave from the conversation\n     * Disable the audio\n     *\n   * @param {object} [reason] the reason for hanging up the nxmCall\n   * @param {string} [reason.reason_code] the code of the reason\n   * @param {string} [reason.reason_text] the description of the reason\n     * @returns {Promise}\n    */\n    async hangUp(reason) {\n        this.log.debug(`hangUp: { reason: ${reason} }`);\n        if (this.conversation) {\n            await this.conversation.media.disable();\n        }\n        if (!this.knocking_id && this.conversation) {\n            return this.conversation.leave(reason).catch(error => {\n                if (error.type !== \"conversation:error:invalid-member-state\") {\n                    return Promise.reject(error);\n                }\n            });\n        }\n        else {\n            let path = `knocking/${this.knocking_id}`;\n            if (reason) {\n                let params = new URLSearchParams();\n                Object.keys(reason).forEach((key) => {\n                    params.append(key, reason[key]);\n                });\n                path += `?${params.toString()}`;\n            }\n            try {\n                const response = await this.application.session.sendNetworkRequest({\n                    type: 'DELETE',\n                    path\n                });\n                const nxmCall = this.application._call_draft_list.get(this.client_ref);\n                nxmCall._handleStatusChange(response);\n                this.application._call_draft_list.delete(this.client_ref);\n                return response;\n            }\n            catch (error) {\n                // Don't switch yet to fail status, it could be an expected race between knocking:delete and conversation.leave\n                if (!this.conversation) {\n                    this.log.debug('hangup: Problem cancelling the call. Knocking cancel failed and Conversation. Leave not available', error);\n                    return;\n                }\n                else {\n                    this.log.error(new nexmoClientError_1.NexmoApiError(error));\n                    return this.conversation.leave(reason);\n                }\n            }\n        }\n    }\n    /**\n     * Rejects an incoming nxmCall\n     * Leave from the conversation that you are invited\n     *\n   * @param {object} [reason] the reason for rejecting the nxmCall\n   * @param {string} [reason.reason_code] the code of the reason\n   * @param {string} [reason.reason_text] the description of the reason\n     * @returns {Promise}\n    */\n    reject(reason) {\n        this.log.debug(`reject: { reason: ${reason} }`);\n        if (this.conversation) {\n            return this.conversation.leave(reason);\n        }\n        else {\n            return Promise.reject(new nexmoClientError_1.NexmoClientError('error:call:reject'));\n        }\n    }\n}\nexports.default = NXMCall;\nmodule.exports = NXMCall;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}