{"ast":null,"code":"'use strict';\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Nexmo Client SDK\n *\n * Copyright (c) Nexmo Inc.\n */\nrequire('webrtc-adapter');\nconst sdptransform = require('sdp-transform');\nconst loglevel_1 = require(\"loglevel\");\nconst browserDetect = __importStar(require(\"detect-browser\"));\nconst nexmoClientError_1 = require(\"../nexmoClientError\");\nconst rtcstats_analytics_1 = __importDefault(require(\"./rtcstats_analytics\"));\nconst clearingTimeout = 20000;\n/**\n * RTC helper object for accessing webRTC API.\n * @class RtcHelper\n * @private\n*/\nclass RtcHelper {\n  constructor() {\n    this.log = loglevel_1.getLogger(this.constructor.name);\n  }\n  static getUserAudio(audioConstraints = true) {\n    let constraintsToUse = {\n      video: false,\n      audio: audioConstraints\n    };\n    return navigator.mediaDevices.getUserMedia(constraintsToUse);\n  }\n  createRTCPeerConnection(config) {\n    const pc = new RTCPeerConnection(config);\n    // attaching the .trace to make easier the stats reporting implementation\n    pc.trace = () => {\n      return;\n    };\n    return pc;\n  }\n  _getWindowLocationProtocol() {\n    return window.location.protocol;\n  }\n  static _getBrowserName() {\n    return browserDetect.detect().name;\n  }\n  static isNode() {\n    return this._getBrowserName() === 'node';\n  }\n  /**\n    * Check if the keys in an object are found in another object\n  */\n  checkValidKeys(object, defaultObject) {\n    let valid = true;\n    Object.keys(object).forEach(key => {\n      if (!defaultObject.hasOwnProperty(key)) {\n        valid = false;\n      }\n      ;\n    });\n    return valid;\n  }\n  static cleanCallMediaIfFailed(call) {\n    setTimeout(() => {\n      if (!call.conversation) {\n        this.cleanMediaProperties(call);\n        call.status = call.CALL_STATUS.FAILED;\n        call.application.emit('call:status:changed', call);\n      }\n    }, 5000);\n  }\n  static callDisconnectHandler(call, pc) {\n    const callStatus = [call.CALL_STATUS.ANSWERED, call.CALL_STATUS.STARTED, call.CALL_STATUS.RINGING];\n    if (pc.connectionState !== 'disconnected' || !call || !call.conversation) return;\n    // Timeout and wait for FS 20 seconds on backend until normal clearing\n    return setTimeout(() => {\n      if (pc.connectionState === 'connected' || callStatus.indexOf(call.status) == -1) return;\n      this.cleanMediaProperties(call);\n      call.status = call.CALL_STATUS.COMPLETED;\n      call.application.emit('call:status:changed', call);\n    }, clearingTimeout);\n  }\n  static cleanMediaProperties(call) {\n    if (call.rtcObjects) {\n      for (const leg_id in call.rtcObjects) {\n        call.rtcObjects[leg_id].pc.close();\n        delete call.rtcObjects[leg_id].pc;\n        RtcHelper.closeStream(call.rtcObjects[leg_id].stream);\n      }\n    }\n    call.application.activeStreams = [];\n    call.rtcObjects = {};\n    if (call.conversation && call.conversation.media) call.conversation.media.rtcStats = null;\n  }\n  static playAudioStream(stream) {\n    const audio = new Audio();\n    audio.srcObject = stream;\n    audio.autoplay = true;\n    return audio;\n  }\n  // Media methods\n  static createDummyCandidateSDP(pc) {\n    const candidate = {\n      foundation: 1176891032,\n      component: 1,\n      transport: 'udp',\n      priority: 2122260223,\n      ip: '0.0.0.0',\n      port: 9,\n      type: 'host',\n      generation: 0,\n      'network-id': 1,\n      'network-cost': 50\n    };\n    const sdpNewObj = sdptransform.parse(pc.localDescription.sdp);\n    sdpNewObj.media[0].candidates = [candidate];\n    return sdptransform.write(sdpNewObj);\n  }\n  static createRTCPeerConnectionConfig(application) {\n    return {\n      iceTransportPolicy: 'all',\n      bundlePolicy: 'balanced',\n      rtcpMuxPolicy: 'require',\n      iceCandidatePoolSize: '0',\n      ...(application.session.config && application.session.config.iceServers && {\n        iceServers: application.session.config.iceServers\n      })\n    };\n  }\n  static createPeerConnection(application) {\n    const pc_config = this.createRTCPeerConnectionConfig(application);\n    const pc = new RTCPeerConnection(pc_config);\n    return pc;\n  }\n  static sendOffer(application, pc, conversation, reconnectRtcId) {\n    const sdp = this.createDummyCandidateSDP(pc);\n    const offer = {\n      sdp\n    };\n    let data = {\n      from: conversation.me.id,\n      body: {\n        offer\n      }\n    };\n    let path = `conversations/${conversation.id}/rtc`;\n    if (reconnectRtcId) {\n      path += `/${reconnectRtcId}/offer`;\n    }\n    return application.session.sendNetworkRequest({\n      type: 'POST',\n      path,\n      data\n    });\n  }\n  static sendAnswer(application, pc, conversation, leg_id) {\n    const answer = this.createDummyCandidateSDP(pc);\n    let data = {\n      from: conversation.me.id,\n      body: {\n        answer\n      }\n    };\n    let path = `conversations/${conversation.id}/rtc/${leg_id}/answer`;\n    return application.session.sendNetworkRequest({\n      type: 'POST',\n      path,\n      data\n    });\n  }\n  static createLeg(application, pc) {\n    const sdpOfferNew = this.createDummyCandidateSDP(pc);\n    const offer = {\n      sdp: sdpOfferNew,\n      type: \"offer\"\n    };\n    return application.session.sendNetworkRequest({\n      type: 'POST',\n      path: `legs`,\n      version: `beta`,\n      data: {\n        body: {\n          offer\n        }\n      }\n    });\n  }\n  static closeStream(stream) {\n    stream.getTracks().forEach(track => {\n      track.stop();\n    });\n  }\n  static emitMediaStream(member, pc, stream) {\n    member.emit(\"media:stream:on\", {\n      pc,\n      stream,\n      type: \"audio\",\n      streamIndex: 0\n    });\n  }\n  static _initStatsEvents(context) {\n    var _a, _b, _c, _d;\n    if (RtcHelper.isNode()) return;\n    if ((_d = (_c = (_b = (_a = context) === null || _a === void 0 ? void 0 : _a.application) === null || _b === void 0 ? void 0 : _b.session) === null || _c === void 0 ? void 0 : _c.config) === null || _d === void 0 ? void 0 : _d.rtcstats) {\n      const config = context.application.session.config.rtcstats;\n      const {\n        emit_events,\n        remote_collection,\n        emit_rtc_analytics\n      } = config;\n      if (emit_events || remote_collection || emit_rtc_analytics) {\n        const params = {\n          ...context,\n          config: {\n            ...config\n          }\n        };\n        return new rtcstats_analytics_1.default(params);\n      }\n    }\n  }\n  static attachConversationEventHandlers(context) {\n    const {\n      conversation,\n      pc,\n      log\n    } = context;\n    // We want to be able to handle these events, for this  member, before they get propagated out\n    conversation.once(\"rtc:answer\", event => {\n      if (!pc) {\n        log.warn(\"RTC: received an answer too late\");\n        return;\n      }\n      pc.setRemoteDescription(new RTCSessionDescription({\n        type: \"answer\",\n        sdp: event.body.answer\n      }));\n    });\n  }\n  static doAnswer(context, offer, leg_id) {\n    const {\n      application,\n      conversation,\n      pc,\n      reject,\n      localStream\n    } = context;\n    this.addPeerConnectionListeners(context, () => RtcHelper.sendAnswer(application, pc, conversation, leg_id).then(() => ({\n      rtc_id: leg_id\n    })));\n    pc.setRemoteDescription(new RTCSessionDescription({\n      type: \"offer\",\n      sdp: offer\n    })).then(() => pc.createAnswer()).then(sessionDescription => pc.setLocalDescription(sessionDescription)).catch(err => {\n      if (localStream) this.closeStream(localStream);\n      reject(err);\n    });\n  }\n  static attachPeerConnectionEventHandlers(context) {\n    const {\n      application,\n      conversation,\n      pc,\n      reconnectRtcId\n    } = context;\n    this.addPeerConnectionListeners(context, () => RtcHelper.sendOffer(application, pc, conversation, reconnectRtcId));\n  }\n  static addPeerConnectionListeners(context, description_handler) {\n    const {\n      application,\n      conversation,\n      pc,\n      streamIndex,\n      localStream,\n      log,\n      rtcObjects,\n      resolve,\n      reject\n    } = context;\n    let stream;\n    let stop_ice_gathering = false;\n    let nxmCall;\n    if (conversation.id) {\n      nxmCall = application.calls.get(conversation.id);\n    }\n    pc.ontrack = evt => {\n      stream = evt.streams[0];\n      application.activeStreams.push(stream);\n      RtcHelper.emitMediaStream(conversation.me, pc, stream);\n    };\n    pc.onconnectionstatechange = _ => this.onconnectionstatechangeHandler(pc, log, nxmCall, () => resolve(stream), () => reject());\n    pc.onnegotiationneeded = () => this.onnegotiationneededHandler(pc, nexmoError => reject(nexmoError));\n    pc.oniceconnectionstatechange = connection_event => this.oniceconnectionstatechange(connection_event, pc, log, nexmoError => reject(nexmoError));\n    pc.onicecandidate = async event => {\n      if (event.candidate && !stop_ice_gathering && pc) {\n        stop_ice_gathering = true;\n        try {\n          const {\n            rtc_id\n          } = await description_handler();\n          RtcHelper._initStatsEvents({\n            application,\n            rtc_id,\n            pc,\n            conversation\n          });\n          //attach rtc stats with rtc_id\n          if (pc.trace) pc.trace(\"rtc_id\", rtc_id);\n          rtcObjects[rtc_id] = {\n            rtc_id,\n            pc,\n            stream: localStream,\n            type: \"audio\",\n            streamIndex: streamIndex\n          };\n        } catch (error) {\n          if (localStream) this.closeStream(localStream);\n          reject(new nexmoClientError_1.NexmoClientError(error));\n        }\n      }\n    };\n    localStream.getTracks().forEach(track => pc.addTrack(track));\n  }\n  static prewarmLeg(nxmCall) {\n    const application = nxmCall.application;\n    return new Promise(async (resolve, reject) => {\n      let offer_sent = false;\n      let stream;\n      let legId;\n      let rtcObjects = {};\n      const log = loglevel_1.getLogger(this.constructor.name);\n      try {\n        let localStream = await this.getUserAudio();\n        const pc = this.createPeerConnection(application);\n        // create call\n        pc.ontrack = evt => {\n          stream = evt.streams[0];\n          application.activeStreams.push(stream);\n        };\n        pc.onconnectionstatechange = event => this.onconnectionstatechangeHandler(pc, log, nxmCall, () => resolve({\n          stream,\n          legId,\n          rtcObjects\n        }), () => reject());\n        pc.onnegotiationneeded = () => this.onnegotiationneededHandler(pc, nexmoError => reject(nexmoError));\n        pc.oniceconnectionstatechange = connection_event => this.oniceconnectionstatechange(connection_event, pc, log, nexmoError => reject(nexmoError));\n        pc.onicecandidate = async event => {\n          if (event.candidate && !offer_sent && pc) {\n            offer_sent = true;\n            const {\n              rtc_id,\n              sdp\n            } = await this.createLeg(application, pc);\n            RtcHelper._initStatsEvents({\n              application,\n              rtc_id,\n              pc\n            });\n            legId = rtc_id;\n            rtcObjects[legId] = {\n              rtc_id,\n              pc,\n              stream: localStream,\n              type: \"audio\",\n              streamIndex: 1\n            };\n            return pc.setRemoteDescription(new RTCSessionDescription({\n              type: \"answer\",\n              sdp\n            }));\n          }\n        };\n        localStream.getTracks().forEach(track => pc.addTrack(track));\n      } catch (error) {\n        reject(new nexmoClientError_1.NexmoClientError(error));\n      }\n    });\n  }\n}\nexports.default = RtcHelper;\nRtcHelper.onconnectionstatechangeHandler = (pc, log, nxmCall, resolveCallback, rejectCallback) => {\n  switch (pc.connectionState) {\n    case \"connected\":\n      log.info(\"The connection has become fully connected\");\n      resolveCallback();\n      break;\n    case \"disconnected\":\n      if (!nxmCall) break;\n      if (nxmCall.call_disconnect_timeout) {\n        clearTimeout(nxmCall.call_disconnect_timeout);\n      }\n      nxmCall.call_disconnect_timeout = RtcHelper.callDisconnectHandler(nxmCall, pc);\n      break;\n    case \"failed\":\n      rejectCallback();\n      log.info(\"One or more transports has terminated unexpectedly or in an error\");\n      break;\n    case \"closed\":\n      log.info(\"The connection has been closed\");\n      break;\n  }\n};\nRtcHelper.oniceconnectionstatechange = (connection_event, pc, log, rejectCallback) => {\n  switch (pc.iceConnectionState) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/iceConnectionState\n    case \"disconnected\":\n      log.warn(\"One or more transports is disconnected\", pc.iceConnectionState);\n      break;\n    case \"failed\":\n      rejectCallback(new nexmoClientError_1.NexmoClientError(connection_event));\n      log.warn(\"One or more transports has terminated unexpectedly or in an error\", connection_event);\n      break;\n    default:\n      log.info(\"The ice connection status changed\", pc.iceConnectionState);\n  }\n};\nRtcHelper.onnegotiationneededHandler = async (pc, rejectCallback) => {\n  try {\n    const offer = await pc.createOffer();\n    return pc.setLocalDescription(offer);\n  } catch (error) {\n    rejectCallback(new nexmoClientError_1.NexmoClientError(error));\n  }\n};\nmodule.exports = RtcHelper;","map":{"version":3,"names":["__importStar","mod","__esModule","result","k","Object","hasOwnProperty","call","__importDefault","defineProperty","exports","value","require","sdptransform","loglevel_1","browserDetect","nexmoClientError_1","rtcstats_analytics_1","clearingTimeout","RtcHelper","constructor","log","getLogger","name","getUserAudio","audioConstraints","constraintsToUse","video","audio","navigator","mediaDevices","getUserMedia","createRTCPeerConnection","config","pc","RTCPeerConnection","trace","_getWindowLocationProtocol","window","location","protocol","_getBrowserName","detect","isNode","checkValidKeys","object","defaultObject","valid","keys","forEach","key","cleanCallMediaIfFailed","setTimeout","conversation","cleanMediaProperties","status","CALL_STATUS","FAILED","application","emit","callDisconnectHandler","callStatus","ANSWERED","STARTED","RINGING","connectionState","indexOf","COMPLETED","rtcObjects","leg_id","close","closeStream","stream","activeStreams","media","rtcStats","playAudioStream","Audio","srcObject","autoplay","createDummyCandidateSDP","candidate","foundation","component","transport","priority","ip","port","type","generation","sdpNewObj","parse","localDescription","sdp","candidates","write","createRTCPeerConnectionConfig","iceTransportPolicy","bundlePolicy","rtcpMuxPolicy","iceCandidatePoolSize","session","iceServers","createPeerConnection","pc_config","sendOffer","reconnectRtcId","offer","data","from","me","id","body","path","sendNetworkRequest","sendAnswer","answer","createLeg","sdpOfferNew","version","getTracks","track","stop","emitMediaStream","member","streamIndex","_initStatsEvents","context","_a","_b","_c","_d","rtcstats","emit_events","remote_collection","emit_rtc_analytics","params","default","attachConversationEventHandlers","once","event","warn","setRemoteDescription","RTCSessionDescription","doAnswer","reject","localStream","addPeerConnectionListeners","then","rtc_id","createAnswer","sessionDescription","setLocalDescription","catch","err","attachPeerConnectionEventHandlers","description_handler","resolve","stop_ice_gathering","nxmCall","calls","get","ontrack","evt","streams","push","onconnectionstatechange","_","onconnectionstatechangeHandler","onnegotiationneeded","onnegotiationneededHandler","nexmoError","oniceconnectionstatechange","connection_event","onicecandidate","error","NexmoClientError","addTrack","prewarmLeg","Promise","offer_sent","legId","resolveCallback","rejectCallback","info","call_disconnect_timeout","clearTimeout","iceConnectionState","createOffer","module"],"sources":["/Users/vineetkhodre/react-workspace/thoughtctlchatapp/client/node_modules/nexmo-client/dist/modules/rtc_helper.js"],"sourcesContent":["'use strict';\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *\n * Copyright (c) Nexmo Inc.\n */\nrequire('webrtc-adapter');\nconst sdptransform = require('sdp-transform');\nconst loglevel_1 = require(\"loglevel\");\nconst browserDetect = __importStar(require(\"detect-browser\"));\nconst nexmoClientError_1 = require(\"../nexmoClientError\");\nconst rtcstats_analytics_1 = __importDefault(require(\"./rtcstats_analytics\"));\nconst clearingTimeout = 20000;\n/**\n * RTC helper object for accessing webRTC API.\n * @class RtcHelper\n * @private\n*/\nclass RtcHelper {\n    constructor() {\n        this.log = loglevel_1.getLogger(this.constructor.name);\n    }\n    static getUserAudio(audioConstraints = true) {\n        let constraintsToUse = {\n            video: false,\n            audio: audioConstraints\n        };\n        return navigator.mediaDevices.getUserMedia(constraintsToUse);\n    }\n    createRTCPeerConnection(config) {\n        const pc = new RTCPeerConnection(config);\n        // attaching the .trace to make easier the stats reporting implementation\n        pc.trace = () => {\n            return;\n        };\n        return pc;\n    }\n    _getWindowLocationProtocol() {\n        return window.location.protocol;\n    }\n    static _getBrowserName() {\n        return browserDetect.detect().name;\n    }\n    static isNode() {\n        return this._getBrowserName() === 'node';\n    }\n    /**\n      * Check if the keys in an object are found in another object\n    */\n    checkValidKeys(object, defaultObject) {\n        let valid = true;\n        Object.keys(object).forEach((key) => {\n            if (!defaultObject.hasOwnProperty(key)) {\n                valid = false;\n            }\n            ;\n        });\n        return valid;\n    }\n    ;\n    static cleanCallMediaIfFailed(call) {\n        setTimeout(() => {\n            if (!call.conversation) {\n                this.cleanMediaProperties(call);\n                call.status = call.CALL_STATUS.FAILED;\n                call.application.emit('call:status:changed', call);\n            }\n        }, 5000);\n    }\n    static callDisconnectHandler(call, pc) {\n        const callStatus = [call.CALL_STATUS.ANSWERED, call.CALL_STATUS.STARTED, call.CALL_STATUS.RINGING];\n        if (pc.connectionState !== 'disconnected' || !call || !call.conversation)\n            return;\n        // Timeout and wait for FS 20 seconds on backend until normal clearing\n        return setTimeout(() => {\n            if (pc.connectionState === 'connected' || callStatus.indexOf(call.status) == -1)\n                return;\n            this.cleanMediaProperties(call);\n            call.status = call.CALL_STATUS.COMPLETED;\n            call.application.emit('call:status:changed', call);\n        }, clearingTimeout);\n    }\n    static cleanMediaProperties(call) {\n        if (call.rtcObjects) {\n            for (const leg_id in call.rtcObjects) {\n                call.rtcObjects[leg_id].pc.close();\n                delete call.rtcObjects[leg_id].pc;\n                RtcHelper.closeStream(call.rtcObjects[leg_id].stream);\n            }\n        }\n        call.application.activeStreams = [];\n        call.rtcObjects = {};\n        if (call.conversation && call.conversation.media)\n            call.conversation.media.rtcStats = null;\n    }\n    static playAudioStream(stream) {\n        const audio = new Audio();\n        audio.srcObject = stream;\n        audio.autoplay = true;\n        return audio;\n    }\n    // Media methods\n    static createDummyCandidateSDP(pc) {\n        const candidate = {\n            foundation: 1176891032,\n            component: 1,\n            transport: 'udp',\n            priority: 2122260223,\n            ip: '0.0.0.0',\n            port: 9,\n            type: 'host',\n            generation: 0,\n            'network-id': 1,\n            'network-cost': 50\n        };\n        const sdpNewObj = sdptransform.parse(pc.localDescription.sdp);\n        sdpNewObj.media[0].candidates = [candidate];\n        return sdptransform.write(sdpNewObj);\n    }\n    static createRTCPeerConnectionConfig(application) {\n        return {\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'balanced',\n            rtcpMuxPolicy: 'require',\n            iceCandidatePoolSize: '0',\n            ...(application.session.config &&\n                application.session.config.iceServers && {\n                iceServers: application.session.config.iceServers\n            })\n        };\n    }\n    static createPeerConnection(application) {\n        const pc_config = this.createRTCPeerConnectionConfig(application);\n        const pc = new RTCPeerConnection(pc_config);\n        return pc;\n    }\n    static sendOffer(application, pc, conversation, reconnectRtcId) {\n        const sdp = this.createDummyCandidateSDP(pc);\n        const offer = { sdp };\n        let data = {\n            from: conversation.me.id,\n            body: { offer }\n        };\n        let path = `conversations/${conversation.id}/rtc`;\n        if (reconnectRtcId) {\n            path += `/${reconnectRtcId}/offer`;\n        }\n        return application.session.sendNetworkRequest({\n            type: 'POST',\n            path,\n            data\n        });\n    }\n    ;\n    static sendAnswer(application, pc, conversation, leg_id) {\n        const answer = this.createDummyCandidateSDP(pc);\n        let data = {\n            from: conversation.me.id,\n            body: { answer }\n        };\n        let path = `conversations/${conversation.id}/rtc/${leg_id}/answer`;\n        return application.session.sendNetworkRequest({\n            type: 'POST',\n            path,\n            data\n        });\n    }\n    ;\n    static createLeg(application, pc) {\n        const sdpOfferNew = this.createDummyCandidateSDP(pc);\n        const offer = { sdp: sdpOfferNew, type: \"offer\" };\n        return application.session.sendNetworkRequest({\n            type: 'POST',\n            path: `legs`,\n            version: `beta`,\n            data: {\n                body: {\n                    offer\n                }\n            }\n        });\n    }\n    static closeStream(stream) {\n        stream.getTracks().forEach((track) => {\n            track.stop();\n        });\n    }\n    static emitMediaStream(member, pc, stream) {\n        member.emit(\"media:stream:on\", {\n            pc,\n            stream,\n            type: \"audio\",\n            streamIndex: 0\n        });\n    }\n    static _initStatsEvents(context) {\n        var _a, _b, _c, _d;\n        if (RtcHelper.isNode())\n            return;\n        if ((_d = (_c = (_b = (_a = context) === null || _a === void 0 ? void 0 : _a.application) === null || _b === void 0 ? void 0 : _b.session) === null || _c === void 0 ? void 0 : _c.config) === null || _d === void 0 ? void 0 : _d.rtcstats) {\n            const config = context.application.session.config.rtcstats;\n            const { emit_events, remote_collection, emit_rtc_analytics, } = config;\n            if (emit_events || remote_collection || emit_rtc_analytics) {\n                const params = { ...context, config: { ...config } };\n                return new rtcstats_analytics_1.default(params);\n            }\n        }\n    }\n    static attachConversationEventHandlers(context) {\n        const { conversation, pc, log } = context;\n        // We want to be able to handle these events, for this  member, before they get propagated out\n        conversation.once(\"rtc:answer\", (event) => {\n            if (!pc) {\n                log.warn(\"RTC: received an answer too late\");\n                return;\n            }\n            pc.setRemoteDescription(new RTCSessionDescription({\n                type: \"answer\",\n                sdp: event.body.answer,\n            }));\n        });\n    }\n    static doAnswer(context, offer, leg_id) {\n        const { application, conversation, pc, reject, localStream } = context;\n        this.addPeerConnectionListeners(context, () => RtcHelper.sendAnswer(application, pc, conversation, leg_id).then(() => ({ rtc_id: leg_id })));\n        pc.setRemoteDescription(new RTCSessionDescription({ type: \"offer\", sdp: offer }))\n            .then(() => pc.createAnswer())\n            .then((sessionDescription) => pc.setLocalDescription(sessionDescription))\n            .catch((err) => {\n            if (localStream)\n                this.closeStream(localStream);\n            reject(err);\n        });\n    }\n    static attachPeerConnectionEventHandlers(context) {\n        const { application, conversation, pc, reconnectRtcId } = context;\n        this.addPeerConnectionListeners(context, () => RtcHelper.sendOffer(application, pc, conversation, reconnectRtcId));\n    }\n    static addPeerConnectionListeners(context, description_handler) {\n        const { application, conversation, pc, streamIndex, localStream, log, rtcObjects, resolve, reject } = context;\n        let stream;\n        let stop_ice_gathering = false;\n        let nxmCall;\n        if (conversation.id) {\n            nxmCall = application.calls.get(conversation.id);\n        }\n        pc.ontrack = (evt) => {\n            stream = evt.streams[0];\n            application.activeStreams.push(stream);\n            RtcHelper.emitMediaStream(conversation.me, pc, stream);\n        };\n        pc.onconnectionstatechange = (_) => this.onconnectionstatechangeHandler(pc, log, nxmCall, () => resolve(stream), () => reject());\n        pc.onnegotiationneeded = () => this.onnegotiationneededHandler(pc, (nexmoError) => reject(nexmoError));\n        pc.oniceconnectionstatechange = (connection_event) => this.oniceconnectionstatechange(connection_event, pc, log, (nexmoError) => reject(nexmoError));\n        pc.onicecandidate = async (event) => {\n            if (event.candidate && !stop_ice_gathering && pc) {\n                stop_ice_gathering = true;\n                try {\n                    const { rtc_id } = await description_handler();\n                    RtcHelper._initStatsEvents({\n                        application,\n                        rtc_id,\n                        pc,\n                        conversation\n                    });\n                    //attach rtc stats with rtc_id\n                    if (pc.trace)\n                        pc.trace(\"rtc_id\", rtc_id);\n                    rtcObjects[rtc_id] = {\n                        rtc_id,\n                        pc,\n                        stream: localStream,\n                        type: \"audio\",\n                        streamIndex: streamIndex,\n                    };\n                }\n                catch (error) {\n                    if (localStream)\n                        this.closeStream(localStream);\n                    reject(new nexmoClientError_1.NexmoClientError(error));\n                }\n            }\n        };\n        localStream.getTracks().forEach((track) => pc.addTrack(track));\n    }\n    static prewarmLeg(nxmCall) {\n        const application = nxmCall.application;\n        return new Promise(async (resolve, reject) => {\n            let offer_sent = false;\n            let stream;\n            let legId;\n            let rtcObjects = {};\n            const log = loglevel_1.getLogger(this.constructor.name);\n            try {\n                let localStream = await this.getUserAudio();\n                const pc = this.createPeerConnection(application);\n                // create call\n                pc.ontrack = (evt) => {\n                    stream = evt.streams[0];\n                    application.activeStreams.push(stream);\n                };\n                pc.onconnectionstatechange = (event) => this.onconnectionstatechangeHandler(pc, log, nxmCall, () => resolve({ stream, legId, rtcObjects }), () => reject());\n                pc.onnegotiationneeded = () => this.onnegotiationneededHandler(pc, (nexmoError) => reject(nexmoError));\n                pc.oniceconnectionstatechange = (connection_event) => this.oniceconnectionstatechange(connection_event, pc, log, (nexmoError) => reject(nexmoError));\n                pc.onicecandidate = async (event) => {\n                    if (event.candidate && !offer_sent && pc) {\n                        offer_sent = true;\n                        const { rtc_id, sdp } = await this.createLeg(application, pc);\n                        RtcHelper._initStatsEvents({\n                            application,\n                            rtc_id,\n                            pc,\n                        });\n                        legId = rtc_id;\n                        rtcObjects[legId] = {\n                            rtc_id,\n                            pc,\n                            stream: localStream,\n                            type: \"audio\",\n                            streamIndex: 1,\n                        };\n                        return pc.setRemoteDescription(new RTCSessionDescription({\n                            type: \"answer\",\n                            sdp,\n                        }));\n                    }\n                };\n                localStream.getTracks().forEach((track) => pc.addTrack(track));\n            }\n            catch (error) {\n                reject(new nexmoClientError_1.NexmoClientError(error));\n            }\n        });\n    }\n}\nexports.default = RtcHelper;\nRtcHelper.onconnectionstatechangeHandler = (pc, log, nxmCall, resolveCallback, rejectCallback) => {\n    switch (pc.connectionState) {\n        case \"connected\":\n            log.info(\"The connection has become fully connected\");\n            resolveCallback();\n            break;\n        case \"disconnected\":\n            if (!nxmCall)\n                break;\n            if (nxmCall.call_disconnect_timeout) {\n                clearTimeout(nxmCall.call_disconnect_timeout);\n            }\n            nxmCall.call_disconnect_timeout = RtcHelper.callDisconnectHandler(nxmCall, pc);\n            break;\n        case \"failed\":\n            rejectCallback();\n            log.info(\"One or more transports has terminated unexpectedly or in an error\");\n            break;\n        case \"closed\":\n            log.info(\"The connection has been closed\");\n            break;\n    }\n};\nRtcHelper.oniceconnectionstatechange = (connection_event, pc, log, rejectCallback) => {\n    switch (pc.iceConnectionState) {\n        // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/iceConnectionState\n        case \"disconnected\":\n            log.warn(\"One or more transports is disconnected\", pc.iceConnectionState);\n            break;\n        case \"failed\":\n            rejectCallback(new nexmoClientError_1.NexmoClientError(connection_event));\n            log.warn(\"One or more transports has terminated unexpectedly or in an error\", connection_event);\n            break;\n        default:\n            log.info(\"The ice connection status changed\", pc.iceConnectionState);\n    }\n};\nRtcHelper.onnegotiationneededHandler = async (pc, rejectCallback) => {\n    try {\n        const offer = await pc.createOffer();\n        return pc.setLocalDescription(offer);\n    }\n    catch (error) {\n        rejectCallback(new nexmoClientError_1.NexmoClientError(error));\n    }\n};\nmodule.exports = RtcHelper;\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,YAAY,GAAI,IAAI,IAAI,IAAI,CAACA,YAAY,IAAK,UAAUC,GAAG,EAAE;EAC7D,IAAIA,GAAG,IAAIA,GAAG,CAACC,UAAU,EAAE,OAAOD,GAAG;EACrC,IAAIE,MAAM,GAAG,CAAC,CAAC;EACf,IAAIF,GAAG,IAAI,IAAI,EAAE,KAAK,IAAIG,CAAC,IAAIH,GAAG,EAAE,IAAII,MAAM,CAACC,cAAc,CAACC,IAAI,CAACN,GAAG,EAAEG,CAAC,CAAC,EAAED,MAAM,CAACC,CAAC,CAAC,GAAGH,GAAG,CAACG,CAAC,CAAC;EAC9FD,MAAM,CAAC,SAAS,CAAC,GAAGF,GAAG;EACvB,OAAOE,MAAM;AACjB,CAAC;AACD,IAAIK,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUP,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDI,MAAM,CAACI,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D;AACA;AACA;AACA;AACA;AACAC,OAAO,CAAC,gBAAgB,CAAC;AACzB,MAAMC,YAAY,GAAGD,OAAO,CAAC,eAAe,CAAC;AAC7C,MAAME,UAAU,GAAGF,OAAO,CAAC,UAAU,CAAC;AACtC,MAAMG,aAAa,GAAGf,YAAY,CAACY,OAAO,CAAC,gBAAgB,CAAC,CAAC;AAC7D,MAAMI,kBAAkB,GAAGJ,OAAO,CAAC,qBAAqB,CAAC;AACzD,MAAMK,oBAAoB,GAAGT,eAAe,CAACI,OAAO,CAAC,sBAAsB,CAAC,CAAC;AAC7E,MAAMM,eAAe,GAAG,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA,MAAMC,SAAS,CAAC;EACZC,WAAWA,CAAA,EAAG;IACV,IAAI,CAACC,GAAG,GAAGP,UAAU,CAACQ,SAAS,CAAC,IAAI,CAACF,WAAW,CAACG,IAAI,CAAC;EAC1D;EACA,OAAOC,YAAYA,CAACC,gBAAgB,GAAG,IAAI,EAAE;IACzC,IAAIC,gBAAgB,GAAG;MACnBC,KAAK,EAAE,KAAK;MACZC,KAAK,EAAEH;IACX,CAAC;IACD,OAAOI,SAAS,CAACC,YAAY,CAACC,YAAY,CAACL,gBAAgB,CAAC;EAChE;EACAM,uBAAuBA,CAACC,MAAM,EAAE;IAC5B,MAAMC,EAAE,GAAG,IAAIC,iBAAiB,CAACF,MAAM,CAAC;IACxC;IACAC,EAAE,CAACE,KAAK,GAAG,MAAM;MACb;IACJ,CAAC;IACD,OAAOF,EAAE;EACb;EACAG,0BAA0BA,CAAA,EAAG;IACzB,OAAOC,MAAM,CAACC,QAAQ,CAACC,QAAQ;EACnC;EACA,OAAOC,eAAeA,CAAA,EAAG;IACrB,OAAO1B,aAAa,CAAC2B,MAAM,CAAC,CAAC,CAACnB,IAAI;EACtC;EACA,OAAOoB,MAAMA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACF,eAAe,CAAC,CAAC,KAAK,MAAM;EAC5C;EACA;AACJ;AACA;EACIG,cAAcA,CAACC,MAAM,EAAEC,aAAa,EAAE;IAClC,IAAIC,KAAK,GAAG,IAAI;IAChB1C,MAAM,CAAC2C,IAAI,CAACH,MAAM,CAAC,CAACI,OAAO,CAAEC,GAAG,IAAK;MACjC,IAAI,CAACJ,aAAa,CAACxC,cAAc,CAAC4C,GAAG,CAAC,EAAE;QACpCH,KAAK,GAAG,KAAK;MACjB;MACA;IACJ,CAAC,CAAC;IACF,OAAOA,KAAK;EAChB;EAEA,OAAOI,sBAAsBA,CAAC5C,IAAI,EAAE;IAChC6C,UAAU,CAAC,MAAM;MACb,IAAI,CAAC7C,IAAI,CAAC8C,YAAY,EAAE;QACpB,IAAI,CAACC,oBAAoB,CAAC/C,IAAI,CAAC;QAC/BA,IAAI,CAACgD,MAAM,GAAGhD,IAAI,CAACiD,WAAW,CAACC,MAAM;QACrClD,IAAI,CAACmD,WAAW,CAACC,IAAI,CAAC,qBAAqB,EAAEpD,IAAI,CAAC;MACtD;IACJ,CAAC,EAAE,IAAI,CAAC;EACZ;EACA,OAAOqD,qBAAqBA,CAACrD,IAAI,EAAE2B,EAAE,EAAE;IACnC,MAAM2B,UAAU,GAAG,CAACtD,IAAI,CAACiD,WAAW,CAACM,QAAQ,EAAEvD,IAAI,CAACiD,WAAW,CAACO,OAAO,EAAExD,IAAI,CAACiD,WAAW,CAACQ,OAAO,CAAC;IAClG,IAAI9B,EAAE,CAAC+B,eAAe,KAAK,cAAc,IAAI,CAAC1D,IAAI,IAAI,CAACA,IAAI,CAAC8C,YAAY,EACpE;IACJ;IACA,OAAOD,UAAU,CAAC,MAAM;MACpB,IAAIlB,EAAE,CAAC+B,eAAe,KAAK,WAAW,IAAIJ,UAAU,CAACK,OAAO,CAAC3D,IAAI,CAACgD,MAAM,CAAC,IAAI,CAAC,CAAC,EAC3E;MACJ,IAAI,CAACD,oBAAoB,CAAC/C,IAAI,CAAC;MAC/BA,IAAI,CAACgD,MAAM,GAAGhD,IAAI,CAACiD,WAAW,CAACW,SAAS;MACxC5D,IAAI,CAACmD,WAAW,CAACC,IAAI,CAAC,qBAAqB,EAAEpD,IAAI,CAAC;IACtD,CAAC,EAAEW,eAAe,CAAC;EACvB;EACA,OAAOoC,oBAAoBA,CAAC/C,IAAI,EAAE;IAC9B,IAAIA,IAAI,CAAC6D,UAAU,EAAE;MACjB,KAAK,MAAMC,MAAM,IAAI9D,IAAI,CAAC6D,UAAU,EAAE;QAClC7D,IAAI,CAAC6D,UAAU,CAACC,MAAM,CAAC,CAACnC,EAAE,CAACoC,KAAK,CAAC,CAAC;QAClC,OAAO/D,IAAI,CAAC6D,UAAU,CAACC,MAAM,CAAC,CAACnC,EAAE;QACjCf,SAAS,CAACoD,WAAW,CAAChE,IAAI,CAAC6D,UAAU,CAACC,MAAM,CAAC,CAACG,MAAM,CAAC;MACzD;IACJ;IACAjE,IAAI,CAACmD,WAAW,CAACe,aAAa,GAAG,EAAE;IACnClE,IAAI,CAAC6D,UAAU,GAAG,CAAC,CAAC;IACpB,IAAI7D,IAAI,CAAC8C,YAAY,IAAI9C,IAAI,CAAC8C,YAAY,CAACqB,KAAK,EAC5CnE,IAAI,CAAC8C,YAAY,CAACqB,KAAK,CAACC,QAAQ,GAAG,IAAI;EAC/C;EACA,OAAOC,eAAeA,CAACJ,MAAM,EAAE;IAC3B,MAAM5C,KAAK,GAAG,IAAIiD,KAAK,CAAC,CAAC;IACzBjD,KAAK,CAACkD,SAAS,GAAGN,MAAM;IACxB5C,KAAK,CAACmD,QAAQ,GAAG,IAAI;IACrB,OAAOnD,KAAK;EAChB;EACA;EACA,OAAOoD,uBAAuBA,CAAC9C,EAAE,EAAE;IAC/B,MAAM+C,SAAS,GAAG;MACdC,UAAU,EAAE,UAAU;MACtBC,SAAS,EAAE,CAAC;MACZC,SAAS,EAAE,KAAK;MAChBC,QAAQ,EAAE,UAAU;MACpBC,EAAE,EAAE,SAAS;MACbC,IAAI,EAAE,CAAC;MACPC,IAAI,EAAE,MAAM;MACZC,UAAU,EAAE,CAAC;MACb,YAAY,EAAE,CAAC;MACf,cAAc,EAAE;IACpB,CAAC;IACD,MAAMC,SAAS,GAAG7E,YAAY,CAAC8E,KAAK,CAACzD,EAAE,CAAC0D,gBAAgB,CAACC,GAAG,CAAC;IAC7DH,SAAS,CAAChB,KAAK,CAAC,CAAC,CAAC,CAACoB,UAAU,GAAG,CAACb,SAAS,CAAC;IAC3C,OAAOpE,YAAY,CAACkF,KAAK,CAACL,SAAS,CAAC;EACxC;EACA,OAAOM,6BAA6BA,CAACtC,WAAW,EAAE;IAC9C,OAAO;MACHuC,kBAAkB,EAAE,KAAK;MACzBC,YAAY,EAAE,UAAU;MACxBC,aAAa,EAAE,SAAS;MACxBC,oBAAoB,EAAE,GAAG;MACzB,IAAI1C,WAAW,CAAC2C,OAAO,CAACpE,MAAM,IAC1ByB,WAAW,CAAC2C,OAAO,CAACpE,MAAM,CAACqE,UAAU,IAAI;QACzCA,UAAU,EAAE5C,WAAW,CAAC2C,OAAO,CAACpE,MAAM,CAACqE;MAC3C,CAAC;IACL,CAAC;EACL;EACA,OAAOC,oBAAoBA,CAAC7C,WAAW,EAAE;IACrC,MAAM8C,SAAS,GAAG,IAAI,CAACR,6BAA6B,CAACtC,WAAW,CAAC;IACjE,MAAMxB,EAAE,GAAG,IAAIC,iBAAiB,CAACqE,SAAS,CAAC;IAC3C,OAAOtE,EAAE;EACb;EACA,OAAOuE,SAASA,CAAC/C,WAAW,EAAExB,EAAE,EAAEmB,YAAY,EAAEqD,cAAc,EAAE;IAC5D,MAAMb,GAAG,GAAG,IAAI,CAACb,uBAAuB,CAAC9C,EAAE,CAAC;IAC5C,MAAMyE,KAAK,GAAG;MAAEd;IAAI,CAAC;IACrB,IAAIe,IAAI,GAAG;MACPC,IAAI,EAAExD,YAAY,CAACyD,EAAE,CAACC,EAAE;MACxBC,IAAI,EAAE;QAAEL;MAAM;IAClB,CAAC;IACD,IAAIM,IAAI,GAAI,iBAAgB5D,YAAY,CAAC0D,EAAG,MAAK;IACjD,IAAIL,cAAc,EAAE;MAChBO,IAAI,IAAK,IAAGP,cAAe,QAAO;IACtC;IACA,OAAOhD,WAAW,CAAC2C,OAAO,CAACa,kBAAkB,CAAC;MAC1C1B,IAAI,EAAE,MAAM;MACZyB,IAAI;MACJL;IACJ,CAAC,CAAC;EACN;EAEA,OAAOO,UAAUA,CAACzD,WAAW,EAAExB,EAAE,EAAEmB,YAAY,EAAEgB,MAAM,EAAE;IACrD,MAAM+C,MAAM,GAAG,IAAI,CAACpC,uBAAuB,CAAC9C,EAAE,CAAC;IAC/C,IAAI0E,IAAI,GAAG;MACPC,IAAI,EAAExD,YAAY,CAACyD,EAAE,CAACC,EAAE;MACxBC,IAAI,EAAE;QAAEI;MAAO;IACnB,CAAC;IACD,IAAIH,IAAI,GAAI,iBAAgB5D,YAAY,CAAC0D,EAAG,QAAO1C,MAAO,SAAQ;IAClE,OAAOX,WAAW,CAAC2C,OAAO,CAACa,kBAAkB,CAAC;MAC1C1B,IAAI,EAAE,MAAM;MACZyB,IAAI;MACJL;IACJ,CAAC,CAAC;EACN;EAEA,OAAOS,SAASA,CAAC3D,WAAW,EAAExB,EAAE,EAAE;IAC9B,MAAMoF,WAAW,GAAG,IAAI,CAACtC,uBAAuB,CAAC9C,EAAE,CAAC;IACpD,MAAMyE,KAAK,GAAG;MAAEd,GAAG,EAAEyB,WAAW;MAAE9B,IAAI,EAAE;IAAQ,CAAC;IACjD,OAAO9B,WAAW,CAAC2C,OAAO,CAACa,kBAAkB,CAAC;MAC1C1B,IAAI,EAAE,MAAM;MACZyB,IAAI,EAAG,MAAK;MACZM,OAAO,EAAG,MAAK;MACfX,IAAI,EAAE;QACFI,IAAI,EAAE;UACFL;QACJ;MACJ;IACJ,CAAC,CAAC;EACN;EACA,OAAOpC,WAAWA,CAACC,MAAM,EAAE;IACvBA,MAAM,CAACgD,SAAS,CAAC,CAAC,CAACvE,OAAO,CAAEwE,KAAK,IAAK;MAClCA,KAAK,CAACC,IAAI,CAAC,CAAC;IAChB,CAAC,CAAC;EACN;EACA,OAAOC,eAAeA,CAACC,MAAM,EAAE1F,EAAE,EAAEsC,MAAM,EAAE;IACvCoD,MAAM,CAACjE,IAAI,CAAC,iBAAiB,EAAE;MAC3BzB,EAAE;MACFsC,MAAM;MACNgB,IAAI,EAAE,OAAO;MACbqC,WAAW,EAAE;IACjB,CAAC,CAAC;EACN;EACA,OAAOC,gBAAgBA,CAACC,OAAO,EAAE;IAC7B,IAAIC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE;IAClB,IAAIhH,SAAS,CAACwB,MAAM,CAAC,CAAC,EAClB;IACJ,IAAI,CAACwF,EAAE,GAAG,CAACD,EAAE,GAAG,CAACD,EAAE,GAAG,CAACD,EAAE,GAAGD,OAAO,MAAM,IAAI,IAAIC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACtE,WAAW,MAAM,IAAI,IAAIuE,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC5B,OAAO,MAAM,IAAI,IAAI6B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACjG,MAAM,MAAM,IAAI,IAAIkG,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACC,QAAQ,EAAE;MACzO,MAAMnG,MAAM,GAAG8F,OAAO,CAACrE,WAAW,CAAC2C,OAAO,CAACpE,MAAM,CAACmG,QAAQ;MAC1D,MAAM;QAAEC,WAAW;QAAEC,iBAAiB;QAAEC;MAAoB,CAAC,GAAGtG,MAAM;MACtE,IAAIoG,WAAW,IAAIC,iBAAiB,IAAIC,kBAAkB,EAAE;QACxD,MAAMC,MAAM,GAAG;UAAE,GAAGT,OAAO;UAAE9F,MAAM,EAAE;YAAE,GAAGA;UAAO;QAAE,CAAC;QACpD,OAAO,IAAIhB,oBAAoB,CAACwH,OAAO,CAACD,MAAM,CAAC;MACnD;IACJ;EACJ;EACA,OAAOE,+BAA+BA,CAACX,OAAO,EAAE;IAC5C,MAAM;MAAE1E,YAAY;MAAEnB,EAAE;MAAEb;IAAI,CAAC,GAAG0G,OAAO;IACzC;IACA1E,YAAY,CAACsF,IAAI,CAAC,YAAY,EAAGC,KAAK,IAAK;MACvC,IAAI,CAAC1G,EAAE,EAAE;QACLb,GAAG,CAACwH,IAAI,CAAC,kCAAkC,CAAC;QAC5C;MACJ;MACA3G,EAAE,CAAC4G,oBAAoB,CAAC,IAAIC,qBAAqB,CAAC;QAC9CvD,IAAI,EAAE,QAAQ;QACdK,GAAG,EAAE+C,KAAK,CAAC5B,IAAI,CAACI;MACpB,CAAC,CAAC,CAAC;IACP,CAAC,CAAC;EACN;EACA,OAAO4B,QAAQA,CAACjB,OAAO,EAAEpB,KAAK,EAAEtC,MAAM,EAAE;IACpC,MAAM;MAAEX,WAAW;MAAEL,YAAY;MAAEnB,EAAE;MAAE+G,MAAM;MAAEC;IAAY,CAAC,GAAGnB,OAAO;IACtE,IAAI,CAACoB,0BAA0B,CAACpB,OAAO,EAAE,MAAM5G,SAAS,CAACgG,UAAU,CAACzD,WAAW,EAAExB,EAAE,EAAEmB,YAAY,EAAEgB,MAAM,CAAC,CAAC+E,IAAI,CAAC,OAAO;MAAEC,MAAM,EAAEhF;IAAO,CAAC,CAAC,CAAC,CAAC;IAC5InC,EAAE,CAAC4G,oBAAoB,CAAC,IAAIC,qBAAqB,CAAC;MAAEvD,IAAI,EAAE,OAAO;MAAEK,GAAG,EAAEc;IAAM,CAAC,CAAC,CAAC,CAC5EyC,IAAI,CAAC,MAAMlH,EAAE,CAACoH,YAAY,CAAC,CAAC,CAAC,CAC7BF,IAAI,CAAEG,kBAAkB,IAAKrH,EAAE,CAACsH,mBAAmB,CAACD,kBAAkB,CAAC,CAAC,CACxEE,KAAK,CAAEC,GAAG,IAAK;MAChB,IAAIR,WAAW,EACX,IAAI,CAAC3E,WAAW,CAAC2E,WAAW,CAAC;MACjCD,MAAM,CAACS,GAAG,CAAC;IACf,CAAC,CAAC;EACN;EACA,OAAOC,iCAAiCA,CAAC5B,OAAO,EAAE;IAC9C,MAAM;MAAErE,WAAW;MAAEL,YAAY;MAAEnB,EAAE;MAAEwE;IAAe,CAAC,GAAGqB,OAAO;IACjE,IAAI,CAACoB,0BAA0B,CAACpB,OAAO,EAAE,MAAM5G,SAAS,CAACsF,SAAS,CAAC/C,WAAW,EAAExB,EAAE,EAAEmB,YAAY,EAAEqD,cAAc,CAAC,CAAC;EACtH;EACA,OAAOyC,0BAA0BA,CAACpB,OAAO,EAAE6B,mBAAmB,EAAE;IAC5D,MAAM;MAAElG,WAAW;MAAEL,YAAY;MAAEnB,EAAE;MAAE2F,WAAW;MAAEqB,WAAW;MAAE7H,GAAG;MAAE+C,UAAU;MAAEyF,OAAO;MAAEZ;IAAO,CAAC,GAAGlB,OAAO;IAC7G,IAAIvD,MAAM;IACV,IAAIsF,kBAAkB,GAAG,KAAK;IAC9B,IAAIC,OAAO;IACX,IAAI1G,YAAY,CAAC0D,EAAE,EAAE;MACjBgD,OAAO,GAAGrG,WAAW,CAACsG,KAAK,CAACC,GAAG,CAAC5G,YAAY,CAAC0D,EAAE,CAAC;IACpD;IACA7E,EAAE,CAACgI,OAAO,GAAIC,GAAG,IAAK;MAClB3F,MAAM,GAAG2F,GAAG,CAACC,OAAO,CAAC,CAAC,CAAC;MACvB1G,WAAW,CAACe,aAAa,CAAC4F,IAAI,CAAC7F,MAAM,CAAC;MACtCrD,SAAS,CAACwG,eAAe,CAACtE,YAAY,CAACyD,EAAE,EAAE5E,EAAE,EAAEsC,MAAM,CAAC;IAC1D,CAAC;IACDtC,EAAE,CAACoI,uBAAuB,GAAIC,CAAC,IAAK,IAAI,CAACC,8BAA8B,CAACtI,EAAE,EAAEb,GAAG,EAAE0I,OAAO,EAAE,MAAMF,OAAO,CAACrF,MAAM,CAAC,EAAE,MAAMyE,MAAM,CAAC,CAAC,CAAC;IAChI/G,EAAE,CAACuI,mBAAmB,GAAG,MAAM,IAAI,CAACC,0BAA0B,CAACxI,EAAE,EAAGyI,UAAU,IAAK1B,MAAM,CAAC0B,UAAU,CAAC,CAAC;IACtGzI,EAAE,CAAC0I,0BAA0B,GAAIC,gBAAgB,IAAK,IAAI,CAACD,0BAA0B,CAACC,gBAAgB,EAAE3I,EAAE,EAAEb,GAAG,EAAGsJ,UAAU,IAAK1B,MAAM,CAAC0B,UAAU,CAAC,CAAC;IACpJzI,EAAE,CAAC4I,cAAc,GAAG,MAAOlC,KAAK,IAAK;MACjC,IAAIA,KAAK,CAAC3D,SAAS,IAAI,CAAC6E,kBAAkB,IAAI5H,EAAE,EAAE;QAC9C4H,kBAAkB,GAAG,IAAI;QACzB,IAAI;UACA,MAAM;YAAET;UAAO,CAAC,GAAG,MAAMO,mBAAmB,CAAC,CAAC;UAC9CzI,SAAS,CAAC2G,gBAAgB,CAAC;YACvBpE,WAAW;YACX2F,MAAM;YACNnH,EAAE;YACFmB;UACJ,CAAC,CAAC;UACF;UACA,IAAInB,EAAE,CAACE,KAAK,EACRF,EAAE,CAACE,KAAK,CAAC,QAAQ,EAAEiH,MAAM,CAAC;UAC9BjF,UAAU,CAACiF,MAAM,CAAC,GAAG;YACjBA,MAAM;YACNnH,EAAE;YACFsC,MAAM,EAAE0E,WAAW;YACnB1D,IAAI,EAAE,OAAO;YACbqC,WAAW,EAAEA;UACjB,CAAC;QACL,CAAC,CACD,OAAOkD,KAAK,EAAE;UACV,IAAI7B,WAAW,EACX,IAAI,CAAC3E,WAAW,CAAC2E,WAAW,CAAC;UACjCD,MAAM,CAAC,IAAIjI,kBAAkB,CAACgK,gBAAgB,CAACD,KAAK,CAAC,CAAC;QAC1D;MACJ;IACJ,CAAC;IACD7B,WAAW,CAAC1B,SAAS,CAAC,CAAC,CAACvE,OAAO,CAAEwE,KAAK,IAAKvF,EAAE,CAAC+I,QAAQ,CAACxD,KAAK,CAAC,CAAC;EAClE;EACA,OAAOyD,UAAUA,CAACnB,OAAO,EAAE;IACvB,MAAMrG,WAAW,GAAGqG,OAAO,CAACrG,WAAW;IACvC,OAAO,IAAIyH,OAAO,CAAC,OAAOtB,OAAO,EAAEZ,MAAM,KAAK;MAC1C,IAAImC,UAAU,GAAG,KAAK;MACtB,IAAI5G,MAAM;MACV,IAAI6G,KAAK;MACT,IAAIjH,UAAU,GAAG,CAAC,CAAC;MACnB,MAAM/C,GAAG,GAAGP,UAAU,CAACQ,SAAS,CAAC,IAAI,CAACF,WAAW,CAACG,IAAI,CAAC;MACvD,IAAI;QACA,IAAI2H,WAAW,GAAG,MAAM,IAAI,CAAC1H,YAAY,CAAC,CAAC;QAC3C,MAAMU,EAAE,GAAG,IAAI,CAACqE,oBAAoB,CAAC7C,WAAW,CAAC;QACjD;QACAxB,EAAE,CAACgI,OAAO,GAAIC,GAAG,IAAK;UAClB3F,MAAM,GAAG2F,GAAG,CAACC,OAAO,CAAC,CAAC,CAAC;UACvB1G,WAAW,CAACe,aAAa,CAAC4F,IAAI,CAAC7F,MAAM,CAAC;QAC1C,CAAC;QACDtC,EAAE,CAACoI,uBAAuB,GAAI1B,KAAK,IAAK,IAAI,CAAC4B,8BAA8B,CAACtI,EAAE,EAAEb,GAAG,EAAE0I,OAAO,EAAE,MAAMF,OAAO,CAAC;UAAErF,MAAM;UAAE6G,KAAK;UAAEjH;QAAW,CAAC,CAAC,EAAE,MAAM6E,MAAM,CAAC,CAAC,CAAC;QAC3J/G,EAAE,CAACuI,mBAAmB,GAAG,MAAM,IAAI,CAACC,0BAA0B,CAACxI,EAAE,EAAGyI,UAAU,IAAK1B,MAAM,CAAC0B,UAAU,CAAC,CAAC;QACtGzI,EAAE,CAAC0I,0BAA0B,GAAIC,gBAAgB,IAAK,IAAI,CAACD,0BAA0B,CAACC,gBAAgB,EAAE3I,EAAE,EAAEb,GAAG,EAAGsJ,UAAU,IAAK1B,MAAM,CAAC0B,UAAU,CAAC,CAAC;QACpJzI,EAAE,CAAC4I,cAAc,GAAG,MAAOlC,KAAK,IAAK;UACjC,IAAIA,KAAK,CAAC3D,SAAS,IAAI,CAACmG,UAAU,IAAIlJ,EAAE,EAAE;YACtCkJ,UAAU,GAAG,IAAI;YACjB,MAAM;cAAE/B,MAAM;cAAExD;YAAI,CAAC,GAAG,MAAM,IAAI,CAACwB,SAAS,CAAC3D,WAAW,EAAExB,EAAE,CAAC;YAC7Df,SAAS,CAAC2G,gBAAgB,CAAC;cACvBpE,WAAW;cACX2F,MAAM;cACNnH;YACJ,CAAC,CAAC;YACFmJ,KAAK,GAAGhC,MAAM;YACdjF,UAAU,CAACiH,KAAK,CAAC,GAAG;cAChBhC,MAAM;cACNnH,EAAE;cACFsC,MAAM,EAAE0E,WAAW;cACnB1D,IAAI,EAAE,OAAO;cACbqC,WAAW,EAAE;YACjB,CAAC;YACD,OAAO3F,EAAE,CAAC4G,oBAAoB,CAAC,IAAIC,qBAAqB,CAAC;cACrDvD,IAAI,EAAE,QAAQ;cACdK;YACJ,CAAC,CAAC,CAAC;UACP;QACJ,CAAC;QACDqD,WAAW,CAAC1B,SAAS,CAAC,CAAC,CAACvE,OAAO,CAAEwE,KAAK,IAAKvF,EAAE,CAAC+I,QAAQ,CAACxD,KAAK,CAAC,CAAC;MAClE,CAAC,CACD,OAAOsD,KAAK,EAAE;QACV9B,MAAM,CAAC,IAAIjI,kBAAkB,CAACgK,gBAAgB,CAACD,KAAK,CAAC,CAAC;MAC1D;IACJ,CAAC,CAAC;EACN;AACJ;AACArK,OAAO,CAAC+H,OAAO,GAAGtH,SAAS;AAC3BA,SAAS,CAACqJ,8BAA8B,GAAG,CAACtI,EAAE,EAAEb,GAAG,EAAE0I,OAAO,EAAEuB,eAAe,EAAEC,cAAc,KAAK;EAC9F,QAAQrJ,EAAE,CAAC+B,eAAe;IACtB,KAAK,WAAW;MACZ5C,GAAG,CAACmK,IAAI,CAAC,2CAA2C,CAAC;MACrDF,eAAe,CAAC,CAAC;MACjB;IACJ,KAAK,cAAc;MACf,IAAI,CAACvB,OAAO,EACR;MACJ,IAAIA,OAAO,CAAC0B,uBAAuB,EAAE;QACjCC,YAAY,CAAC3B,OAAO,CAAC0B,uBAAuB,CAAC;MACjD;MACA1B,OAAO,CAAC0B,uBAAuB,GAAGtK,SAAS,CAACyC,qBAAqB,CAACmG,OAAO,EAAE7H,EAAE,CAAC;MAC9E;IACJ,KAAK,QAAQ;MACTqJ,cAAc,CAAC,CAAC;MAChBlK,GAAG,CAACmK,IAAI,CAAC,mEAAmE,CAAC;MAC7E;IACJ,KAAK,QAAQ;MACTnK,GAAG,CAACmK,IAAI,CAAC,gCAAgC,CAAC;MAC1C;EACR;AACJ,CAAC;AACDrK,SAAS,CAACyJ,0BAA0B,GAAG,CAACC,gBAAgB,EAAE3I,EAAE,EAAEb,GAAG,EAAEkK,cAAc,KAAK;EAClF,QAAQrJ,EAAE,CAACyJ,kBAAkB;IACzB;IACA,KAAK,cAAc;MACftK,GAAG,CAACwH,IAAI,CAAC,wCAAwC,EAAE3G,EAAE,CAACyJ,kBAAkB,CAAC;MACzE;IACJ,KAAK,QAAQ;MACTJ,cAAc,CAAC,IAAIvK,kBAAkB,CAACgK,gBAAgB,CAACH,gBAAgB,CAAC,CAAC;MACzExJ,GAAG,CAACwH,IAAI,CAAC,mEAAmE,EAAEgC,gBAAgB,CAAC;MAC/F;IACJ;MACIxJ,GAAG,CAACmK,IAAI,CAAC,mCAAmC,EAAEtJ,EAAE,CAACyJ,kBAAkB,CAAC;EAC5E;AACJ,CAAC;AACDxK,SAAS,CAACuJ,0BAA0B,GAAG,OAAOxI,EAAE,EAAEqJ,cAAc,KAAK;EACjE,IAAI;IACA,MAAM5E,KAAK,GAAG,MAAMzE,EAAE,CAAC0J,WAAW,CAAC,CAAC;IACpC,OAAO1J,EAAE,CAACsH,mBAAmB,CAAC7C,KAAK,CAAC;EACxC,CAAC,CACD,OAAOoE,KAAK,EAAE;IACVQ,cAAc,CAAC,IAAIvK,kBAAkB,CAACgK,gBAAgB,CAACD,KAAK,CAAC,CAAC;EAClE;AACJ,CAAC;AACDc,MAAM,CAACnL,OAAO,GAAGS,SAAS"},"metadata":{},"sourceType":"script","externalDependencies":[]}