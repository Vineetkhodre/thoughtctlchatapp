{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Nexmo Client SDK\n *  Media Object Model\n *\n * Copyright (c) Nexmo Inc.\n */\nconst loglevel_1 = require(\"loglevel\");\nconst nexmoClientError_1 = require(\"../nexmoClientError\");\nconst rtc_helper_1 = __importDefault(require(\"./rtc_helper\"));\nconst utils_1 = __importDefault(require(\"../utils\"));\nconst nxmEvent_1 = __importDefault(require(\"../events/nxmEvent\"));\nconst conversation_1 = __importDefault(require(\"../conversation\"));\nconst application_1 = __importDefault(require(\"../application\"));\n/**\n * Member listening for audio stream on.\n *\n * @event Member#media:stream:on\n *\n * @property {number} payload.streamIndex the index number of this stream\n * @property {number} [payload.rtc_id] the rtc_id / leg_id\n * @property {string} [payload.remote_member_id] the id of the Member the stream belongs to\n * @property {string} [payload.name] the stream's display name\n * @property {MediaStream} payload.stream the stream that is activated\n * @property {boolean} [payload.audio_mute] if the audio is muted\n */\n/**\n * WebRTC Media class\n * @class Media\n * @property {Application} application The parent application object\n * @property {Conversation} parentConversation the conversation object this media instance belongs to\n * @property {number} parentConversation.streamIndex the latest index of the streams, updated in each new peer offer\n * @property {object[]} rtcObjects data related to the rtc connection\n * @property {string} rtcObjects.rtc_id the rtc_id\n * @property {PeerConnection} rtcObjects.pc the current PeerConnection object\n * @property {Stream} rtcObjects.stream the stream of the specific rtc_id\n * @property {string} [rtcObjects.type] audio the type of the stream\n * @property {number} rtcObjects.streamIndex the index number of the stream (e.g. use to mute)\n * @property {RTCStatsConfig} rtcstats_conf the config needed to controll rtcstats analytics behavior\n * @property {RTCStatsAnalytics} rtcstats an instance to collect analytics from a peer connection\n * @emits Application#rtcstats:report\n * @emits Application#rtcstats:analytics\n * @emits Member#media:stream:on\n */\nclass Media {\n  constructor(conversationOrApplication) {\n    var _a, _b, _c;\n    const conversation = conversationOrApplication instanceof conversation_1.default ? conversationOrApplication : null;\n    const application = conversationOrApplication instanceof application_1.default ? conversationOrApplication : null;\n    this.log = loglevel_1.getLogger(this.constructor.name);\n    if (conversation) {\n      this.rtcHelper = new rtc_helper_1.default();\n      this.application = conversation.application;\n      this.application.activeStreams = this.application.activeStreams || [];\n      this.parentConversation = conversation;\n      this.rtcObjects = {};\n      this.streamIndex = 0;\n      this.rtcstats_conf = ((_c = (_b = (_a = this.application) === null || _a === void 0 ? void 0 : _a.session) === null || _b === void 0 ? void 0 : _b.config) === null || _c === void 0 ? void 0 : _c.rtcStats) || {};\n      this.rtcStats = null;\n    } else if (application) {\n      this.rtcHelper = new rtc_helper_1.default();\n      this.application = application;\n    } else {\n      this.log.warn(\"No conversation object in Media\");\n    }\n  }\n  _attachEndingEventHandlers() {\n    if (!this.parentConversation) {\n      return;\n    }\n    this.log.debug(\"attaching leave listeners in media for \" + this.parentConversation.id);\n    this.parentConversation.on(\"rtc:hangup\", async event => {\n      let member;\n      if (this.parentConversation.members.has(event.from)) {\n        member = this.parentConversation.members.get(event.from);\n      } else {\n        try {\n          member = await this.parentConversation.getMember(event.from);\n        } catch (error) {\n          this.log.warn(`There is an error getting the member ${error}`);\n        }\n      }\n      if (member.user.id === this.application.me.id && this.application.activeStreams.length) {\n        this._cleanMediaProperties();\n      }\n      // terminate peer connection stream in case of a transfer\n      if (member.user.id === this.application.me.id && member.transferred_from) {\n        member.transferred_from.media._cleanMediaProperties();\n      }\n      if (member.user.id === this.application.me.id) {\n        this.parentConversation.off(\"rtc:hangup\");\n      }\n    });\n  }\n  /**\n   * Switch on the rtc stats emit events\n   * @private\n   */\n  _enableStatsEvents() {\n    this.rtcstats_conf.emit_rtc_analytics = true;\n    this.rtcstats_conf.remote_collection = true;\n    const rtcObject = this._findRtcObjectByType(\"audio\");\n    if (!this.rtcStats && rtcObject) {\n      this.log.debug(`enabling stats events for ${rtcObject.rtc_id}`);\n      this.rtcStats = rtc_helper_1.default._initStatsEvents({\n        application: this.application,\n        rtc_id: rtcObject.rtc_id,\n        pc: this.pc,\n        conversation: this.parentConversation\n      });\n    }\n  }\n  /**\n   * Switch off the rtcStat events\n   * @private\n   */\n  _disableStatsEvents() {\n    this.rtcstats_conf.emit_events = false;\n    this.rtcstats_conf.emit_rtc_analytics = false;\n    this.rtcstats_conf.remote_collection = false;\n    this.rtcStats.removeIntervals();\n    delete this.rtcStats;\n  }\n  /**\n   * Function used to init the media stream\n   * @private\n   */\n  _audioInitHandler(params = {}, onIceCandidateHandler) {\n    return new Promise(async (resolve, reject) => {\n      const streamIndex = this.streamIndex;\n      this.streamIndex++;\n      const {\n        audioConstraints\n      } = params;\n      try {\n        const localStream = await rtc_helper_1.default.getUserAudio(audioConstraints);\n        const pc = rtc_helper_1.default.createPeerConnection(this.application);\n        this.pc = pc;\n        const {\n          application,\n          log,\n          parentConversation: conversation,\n          rtcObjects\n        } = this;\n        const context = {\n          pc,\n          streamIndex,\n          localStream,\n          application,\n          conversation,\n          log,\n          rtcObjects\n        };\n        onIceCandidateHandler({\n          ...context,\n          resolve,\n          reject\n        });\n        rtc_helper_1.default.attachConversationEventHandlers(context);\n        this._attachEndingEventHandlers();\n      } catch (error) {\n        reject(new nexmoClientError_1.NexmoClientError(error));\n      }\n    });\n  }\n  /**\n   * Handles the enabling of audio when an offer is available\n   * @private\n   */\n  _execAnswer(params = {}) {\n    const {\n      offer: {\n        sdp,\n        leg_id\n      }\n    } = params;\n    return this._audioInitHandler(params, context => rtc_helper_1.default.doAnswer(context, sdp, leg_id));\n  }\n  /**\n   * Handles the enabling of audio only stream with rtc:new\n   * @private\n   */\n  _handleAudio(params = {}) {\n    const {\n      reconnectRtcId\n    } = params;\n    return this._audioInitHandler(params, context => rtc_helper_1.default.attachPeerConnectionEventHandlers({\n      ...context,\n      reconnectRtcId\n    }));\n  }\n  _findRtcObjectByType(type) {\n    return Object.values(this.rtcObjects).find(rtcObject => rtcObject.type === type);\n  }\n  async _cleanConversationProperties() {\n    if (this.pc) {\n      this.pc.close();\n    }\n    // stop active stream\n    delete this.pc;\n    this.rtcStats = null;\n    this.application.activeStreams = [];\n    this.listeningToRtcEvent = false;\n    await Promise.resolve();\n  }\n  /**\n   * Cleans up the user's media before leaving the conversation\n   * @private\n   */\n  _cleanMediaProperties() {\n    if (this.pc) {\n      this.pc.close();\n    }\n    if (this.rtcObjects) {\n      for (const leg_id in this.rtcObjects) {\n        rtc_helper_1.default.closeStream(this.rtcObjects[leg_id].stream);\n      }\n    }\n    delete this.pc;\n    this.rtcStats = null;\n    this.application.activeStreams = [];\n    this.rtcObjects = {};\n    this.listeningToRtcEvent = false;\n  }\n  async _disableLeg(leg_id) {\n    const csRequestPromise = new Promise(async (resolve, reject) => {\n      try {\n        await this.application.session.sendNetworkRequest({\n          type: \"DELETE\",\n          path: `conversations/${this.parentConversation.id}/rtc/${leg_id}?from=${this.parentConversation.me.id}&originating_session=${this.application.session.session_id}`,\n          version: \"beta2\"\n        });\n        resolve(\"rtc:terminate:success\");\n      } catch (error) {\n        reject(new nexmoClientError_1.NexmoApiError(error));\n      }\n    });\n    const closeResourcesPromise = new Promise(resolve => {\n      if (this.rtcObjects[leg_id].pc) {\n        this.rtcObjects[leg_id].pc.close();\n      }\n      if (this.rtcObjects[leg_id].stream) {\n        rtc_helper_1.default.closeStream(this.rtcObjects[leg_id].stream);\n      }\n      resolve();\n    });\n    try {\n      await Promise.all([csRequestPromise, closeResourcesPromise]);\n      this.parentConversation.me.emit(\"media:stream:off\", this.rtcObjects[leg_id].streamIndex);\n      delete this.rtcObjects[leg_id];\n      return \"rtc:terminate:success\";\n    } catch (error) {\n      throw error;\n    }\n  }\n  _enableMediaTracks(tracks, enabled) {\n    tracks.forEach(mediaTrack => {\n      mediaTrack.enabled = enabled;\n    });\n  }\n  /**\n   * Send a mute request with the rtc_id and enable/disable the tracks\n   * If the mute request fails revert the changes in the tracks\n   * @private\n   */\n  async _setMediaTracksAndMute(rtc_id, tracks, mute, mediaType) {\n    this._enableMediaTracks(tracks, !mute);\n    try {\n      return await this.application.session.sendNetworkRequest({\n        type: \"POST\",\n        path: `conversations/${this.parentConversation.id}/events`,\n        data: {\n          type: mediaType,\n          to: this.parentConversation.me.id,\n          from: this.parentConversation.me.id,\n          body: {\n            rtc_id\n          }\n        }\n      });\n    } catch (error) {\n      this._enableMediaTracks(tracks, mute);\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n   * Replaces the stream's audio tracks currently being used as the sender's sources with a new one\n   * @param {object} constraints - audio constraints - { deviceId: { exact: selectedAudioDeviceId } }\n   * @param {string} type - rtc object type - audio\n   * @returns {Promise<MediaStream>} - Returns the new stream.\n   * @example <caption>Update the stream currently being used with a new audio source</caption>\n   * conversation.media.updateAudioConstraints({ deviceId: { exact: selectedAudioDeviceId } }, \"audio\")\n   * .then((response) => {\n   *   console.log(response);\n   * }).catch((error) => {\n   *   console.error(error);\n   * });\n   *\n   *\n   */\n  async updateAudioConstraints(constraints = {}) {\n    let rtcObjectByType = this._findRtcObjectByType('audio');\n    if (rtcObjectByType && rtcObjectByType.pc) {\n      try {\n        const localStream = await rtc_helper_1.default.getUserAudio(constraints);\n        localStream.getTracks().forEach(track => {\n          const sender = rtcObjectByType.pc.getSenders().find(s => s.track.kind === track.kind);\n          if (sender) {\n            track.enabled = sender.track.enabled;\n            sender.replaceTrack(track);\n          }\n        });\n        rtc_helper_1.default.closeStream(rtcObjectByType.stream);\n        rtcObjectByType.stream = localStream;\n        return localStream;\n      } catch (error) {\n        return error;\n      }\n    } else {\n      throw new nexmoClientError_1.NexmoApiError(\"error:media:stream:not-found\");\n    }\n  }\n  /**\n   * Mute your Member\n   *\n   * @param {boolean} [mute=false] true for mute, false for unmute\n   * @param {number} [streamIndex] stream id to set - if it's not set all streams will be muted\n   * @example <caption>Mute your audio stream in the Conversation</caption>\n   * // Mute your Member\n   * conversation.media.mute(true);\n   *\n   * // Unmute your Member\n   * conversation.media.mute(false);\n   */\n  mute(mute = false, streamIndex = null) {\n    const state = mute ? \"on\" : \"off\";\n    const audioType = \"audio:mute:\" + state;\n    let promises = [];\n    let muteObjects = {};\n    if (streamIndex !== null) {\n      muteObjects[0] = Object.values(this.rtcObjects).find(rtcObj => rtcObj.streamIndex === streamIndex);\n      if (!muteObjects[0]) {\n        throw new nexmoClientError_1.NexmoClientError(\"error:media:stream:not-found\");\n      }\n    } else {\n      muteObjects = this.rtcObjects;\n    }\n    Object.values(muteObjects).forEach(rtcObject => {\n      const audioTracks = rtcObject.stream.getAudioTracks();\n      const audioPromise = this._setMediaTracksAndMute(rtcObject.rtc_id, audioTracks, mute, audioType);\n      promises.push(audioPromise);\n    });\n    return Promise.all(promises);\n  }\n  /**\n   * Earmuff our member\n   *\n   * @param {boolean} [params]\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async earmuff(earmuff) {\n    try {\n      if (this.me === null) {\n        throw new nexmoClientError_1.NexmoClientError(\"error:self\");\n      } else {\n        let type = \"audio:earmuff:off\";\n        if (earmuff) {\n          type = \"audio:earmuff:on\";\n        }\n        const {\n          response\n        } = await this.application.session.sendNetworkRequest({\n          type: \"POST\",\n          path: `conversations/${this.parentConversation.id}/events`,\n          data: {\n            type,\n            to: this.parentConversation.me.id\n          }\n        });\n        return response;\n      }\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n   * Enable media participation in the conversation for this application (requires WebRTC)\n   * @param {object} [params] - rtc params\n   * @param {string} [params.label] - label is an application defined tag, eg. ‘fullscreen’\n   * @param {string} [params.reconnectRtcId] - the rtc_id / leg_id of the call to reconnect to\n   * @param {object} [params.audio=true] - audio enablement mode. possible values \"both\", \"send_only\", \"receive_only\", \"none\", true or false\n   * @param {object} [params.autoPlayAudio=false] - attach the audio stream automatically to start playing after enable media (default false)\n   * @param {object} [params.audioConstraints] - audio constraints to use\n   * @param {boolean} [params.audioConstraints.autoGainControl] - a boolean which specifies whether automatic gain control is preferred and/or required\n   * @param {boolean} [params.audioConstraints.echoCancellation] - a boolean specifying whether or not echo cancellation is preferred and/or required\n   * @param {boolean} [params.audioConstraints.noiseSuppression] - a boolean which specifies whether noise suppression is preferred and/or required\n   * @param {string | Array} [params.audioConstraints.deviceId] - object specifying a device ID or an array of device IDs which are acceptable and/or required\n   * @returns {Promise<MediaStream>}\n   * @example <caption>Enable media in the Conversation</caption>\n   *\n   * conversation.media.enable()\n   * .then((stream) => {\n   *    const media = document.createElement(\"audio\");\n   *    const source = document.createElement(\"source\");\n   *    const media_div = document.createElement(\"div\");\n   *    media.appendChild(source);\n   *    media_div.appendChild(media);\n   *    document.insertBefore(media_div);\n   *    // Older browsers may not have srcObject\n   *    if (\"srcObject\" in media) {\n   *      media.srcObject = stream;\n   *    } else {\n   *      // Avoid using this in new browsers, as it is going away.\n   *      media.src = window.URL.createObjectURL(stream);\n   *    }\n   *    media.onloadedmetadata = (e) => {\n   *      media.play();\n   *    };\n   * }).catch((error) => {\n   *    console.error(error);\n   * });\n   *\n   **/\n  async enable(params) {\n    try {\n      if (this.parentConversation.me === null) {\n        throw new nexmoClientError_1.NexmoClientError(\"error:self\");\n      } else {\n        const {\n          offer\n        } = params !== null && params !== void 0 ? params : {};\n        let remoteStream = await (offer !== undefined ? this._execAnswer(params) : this._handleAudio(params));\n        // attach the audio stream automatically to start playing\n        let autoPlayAudio = params && (params.autoPlayAudio || params.autoPlayAudio === undefined);\n        if (!params || autoPlayAudio) {\n          rtc_helper_1.default.playAudioStream(remoteStream);\n        }\n        return remoteStream;\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n  /**\n   * Disable media participation in the conversation for this application\n   * if RtcStats MOS is enabled, a final report will be available in\n   * NexmoClient#rtcstats:report\n   * @returns {Promise}\n   * @example <caption>Disable media in the Conversation</caption>\n   *\n   * conversation.media.disable()\n   * .then((response) => {\n   *   console.log(response);\n   * }).catch((error) => {\n   *   console.error(error);\n   * });\n   *\n   **/\n  disable() {\n    let promises = [];\n    promises.push(this._cleanConversationProperties());\n    for (const leg_id in this.rtcObjects) {\n      promises.push(this._disableLeg(leg_id));\n    }\n    return Promise.all(promises);\n  }\n  /**\n   * Play a voice text in the Conversation\n   * @param {object} params\n   * @param {string} params.text - The text to say in the Conversation.\n   * @param {string} [params.voice_name=\"Amy\"] - Name of the voice to use for speech to text.\n   * @param {number} [params.level=1] - Set the audio level of the audio stream: min=-1 max=1 increment=0.1.\n   * @param {boolean} [params.queue=true] - ?\n   * @param {boolean} [params.loop=1] - The number of times to repeat audio. Set to 0 to loop infinitely.\n   * @param {boolean} [params.ssml=false] - Customize the spoken text with <a href=\"https://developer.nexmo.com/voice/voice-api/guides/customizing-tts\">Speech Synthesis Markup Language (SSML)</a> specification\n   *\n   * @returns {Promise<NXMEvent>}\n   * @example <caption>Play speech to text in the Conversation</caption>\n   * conversation.media.sayText({text:\"hi\"})\n   * .then((response) => {\n   *    console.log(response);\n   * })\n   * .catch((error) => {\n   *     console.error(error);\n   * });\n   *\n   **/\n  async sayText(params) {\n    try {\n      const response = await this.application.session.sendNetworkRequest({\n        type: \"POST\",\n        path: `conversations/${this.parentConversation.id}/events`,\n        data: {\n          type: \"audio:say\",\n          cid: this.parentConversation.id,\n          from: this.parentConversation.me.id,\n          body: {\n            text: params.text,\n            voice_name: params.voice_name || \"Amy\",\n            level: params.level || 1,\n            queue: params.queue || true,\n            loop: params.loop || 1,\n            ssml: params.ssml || false\n          }\n        }\n      });\n      return new nxmEvent_1.default(this.parentConversation, response);\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n   * Send DTMF in the Conversation\n   * @param {string} digit - the DTMF digit(s) to send\n   *\n   * @returns {Promise<NXMEvent>}\n   * @example <caption>Send DTMF in the Conversation</caption>\n   * conversation.media.sendDTMF(\"digit\");\n   * .then((response) => {\n   *    console.log(response);\n   * })\n   * .catch((error) => {\n   *     console.error(error);\n   * });\n   **/\n  async sendDTMF(digit) {\n    try {\n      if (!utils_1.default.validateDTMF(digit)) {\n        throw new nexmoClientError_1.NexmoClientError(\"error:audio:dtmf:invalid-digit\");\n      }\n      const rtc_id = (this._findRtcObjectByType('audio') || {}).rtc_id;\n      if (!rtc_id) {\n        throw new nexmoClientError_1.NexmoClientError(\"error:audio:dtmf:audio-disabled\");\n      }\n      const {\n        id,\n        timestamp\n      } = await this.application.session.sendNetworkRequest({\n        type: \"POST\",\n        path: `conversations/${this.parentConversation.id}/events`,\n        data: {\n          type: \"audio:dtmf\",\n          from: this.parentConversation.me.id,\n          body: {\n            digit,\n            channel: {\n              type: \"app\",\n              id: this._findRtcObjectByType('audio').rtc_id\n            }\n          }\n        }\n      });\n      const placeholder_event = {\n        body: {\n          digit,\n          dtmf_id: \"\"\n        },\n        cid: this.parentConversation.id,\n        from: this.parentConversation.me.id,\n        id,\n        timestamp,\n        type: \"audio:dtmf\"\n      };\n      const dtmfEvent = new nxmEvent_1.default(this.parentConversation, placeholder_event);\n      this.parentConversation.events.set(placeholder_event.id, dtmfEvent);\n      return dtmfEvent;\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n   * Play an audio stream in the Conversation\n   * @param {object} params\n   * @param {number} params.level - Set the audio level of the audio stream: min=-1 max=1 increment=0.1.\n   * @param {array} params.stream_url - Link to the audio file.\n   * @param {number} params.loop - The number of times to repeat audio. Set to 0 to loop infinitely.\n   *\n   * @returns {Promise<NXMEvent>}\n   * @example <caption>Play an audio stream in the Conversation</caption>\n   * conversation.media.playStream({ level: 0.5, stream_url: [\"https://nexmo-community.github.io/ncco-examples/assets/voice_api_audio_streaming.mp3\"], loop: 1 })\n   * .then((response) => {\n   *   console.log(\"response: \", response);\n   * })\n   * .catch((error) => {\n   *   console.error(\"error: \", error);\n   * });\n   *\n   */\n  async playStream(params) {\n    try {\n      const response = await this.application.session.sendNetworkRequest({\n        type: \"POST\",\n        path: `conversations/${this.parentConversation.id}/events`,\n        data: {\n          type: \"audio:play\",\n          body: params\n        }\n      });\n      return new nxmEvent_1.default(this.parentConversation, response);\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n   * Send start ringing event\n   * @returns {Promise<NXMEvent>}\n   * @example <caption>Send start ringing event in the Conversation</caption>\n   *\n   * conversation.media.startRinging()\n   * .then((response) => {\n   *    console.log(response);\n   * }).catch((error) => {\n   *    console.error(error);\n   * });\n   *\n   * // Listen for start ringing event\n   * conversation.on('audio:ringing:start', (data) => {\n   *    console.log(\"ringing started: \", data);\n   * });\n   *\n   */\n  async startRinging() {\n    try {\n      const response = await this.application.session.sendNetworkRequest({\n        type: \"POST\",\n        path: `conversations/${this.parentConversation.id}/events`,\n        data: {\n          type: \"audio:ringing:start\",\n          from: this.parentConversation.me.id,\n          body: {}\n        }\n      });\n      return new nxmEvent_1.default(this.parentConversation, response);\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n  /**\n   * Send stop ringing event\n   * @returns {Promise<NXMEvent>}\n   * @example <caption>Send stop ringing event in the Conversation</caption>\n   *\n   * conversation.media.stopRinging()\n   * .then((response) => {\n   *    console.log(response);\n   * }).catch((error) => {\n   *    console.error(error);\n   * });\n   *\n   * // Listen for stop ringing event\n   * conversation.on('audio:ringing:stop', (data) => {\n   *    console.log(\"ringing stopped: \", data);\n   * });\n   *\n   */\n  async stopRinging() {\n    try {\n      const response = await this.application.session.sendNetworkRequest({\n        type: \"POST\",\n        path: `conversations/${this.parentConversation.id}/events`,\n        data: {\n          type: \"audio:ringing:stop\",\n          from: this.parentConversation.me.id,\n          body: {}\n        }\n      });\n      return new nxmEvent_1.default(this.parentConversation, response);\n    } catch (error) {\n      throw new nexmoClientError_1.NexmoApiError(error);\n    }\n  }\n}\nexports.default = Media;\nmodule.exports = Media;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","loglevel_1","require","nexmoClientError_1","rtc_helper_1","utils_1","nxmEvent_1","conversation_1","application_1","Media","constructor","conversationOrApplication","_a","_b","_c","conversation","default","application","log","getLogger","name","rtcHelper","activeStreams","parentConversation","rtcObjects","streamIndex","rtcstats_conf","session","config","rtcStats","warn","_attachEndingEventHandlers","debug","id","on","event","member","members","has","from","get","getMember","error","user","me","length","_cleanMediaProperties","transferred_from","media","off","_enableStatsEvents","emit_rtc_analytics","remote_collection","rtcObject","_findRtcObjectByType","rtc_id","_initStatsEvents","pc","_disableStatsEvents","emit_events","removeIntervals","_audioInitHandler","params","onIceCandidateHandler","Promise","resolve","reject","audioConstraints","localStream","getUserAudio","createPeerConnection","context","attachConversationEventHandlers","NexmoClientError","_execAnswer","offer","sdp","leg_id","doAnswer","_handleAudio","reconnectRtcId","attachPeerConnectionEventHandlers","type","values","find","_cleanConversationProperties","close","listeningToRtcEvent","closeStream","stream","_disableLeg","csRequestPromise","sendNetworkRequest","path","session_id","version","NexmoApiError","closeResourcesPromise","all","emit","_enableMediaTracks","tracks","enabled","forEach","mediaTrack","_setMediaTracksAndMute","mute","mediaType","data","to","body","updateAudioConstraints","constraints","rtcObjectByType","getTracks","track","sender","getSenders","s","kind","replaceTrack","state","audioType","promises","muteObjects","rtcObj","audioTracks","getAudioTracks","audioPromise","push","earmuff","response","enable","remoteStream","undefined","autoPlayAudio","playAudioStream","disable","sayText","cid","text","voice_name","level","queue","loop","ssml","sendDTMF","digit","validateDTMF","timestamp","channel","placeholder_event","dtmf_id","dtmfEvent","events","set","playStream","startRinging","stopRinging","module"],"sources":["/Users/vineetkhodre/react-workspace/thoughtctlchatapp/client/node_modules/nexmo-client/dist/modules/media.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  Media Object Model\n *\n * Copyright (c) Nexmo Inc.\n */\nconst loglevel_1 = require(\"loglevel\");\nconst nexmoClientError_1 = require(\"../nexmoClientError\");\nconst rtc_helper_1 = __importDefault(require(\"./rtc_helper\"));\nconst utils_1 = __importDefault(require(\"../utils\"));\nconst nxmEvent_1 = __importDefault(require(\"../events/nxmEvent\"));\nconst conversation_1 = __importDefault(require(\"../conversation\"));\nconst application_1 = __importDefault(require(\"../application\"));\n/**\n * Member listening for audio stream on.\n *\n * @event Member#media:stream:on\n *\n * @property {number} payload.streamIndex the index number of this stream\n * @property {number} [payload.rtc_id] the rtc_id / leg_id\n * @property {string} [payload.remote_member_id] the id of the Member the stream belongs to\n * @property {string} [payload.name] the stream's display name\n * @property {MediaStream} payload.stream the stream that is activated\n * @property {boolean} [payload.audio_mute] if the audio is muted\n */\n/**\n * WebRTC Media class\n * @class Media\n * @property {Application} application The parent application object\n * @property {Conversation} parentConversation the conversation object this media instance belongs to\n * @property {number} parentConversation.streamIndex the latest index of the streams, updated in each new peer offer\n * @property {object[]} rtcObjects data related to the rtc connection\n * @property {string} rtcObjects.rtc_id the rtc_id\n * @property {PeerConnection} rtcObjects.pc the current PeerConnection object\n * @property {Stream} rtcObjects.stream the stream of the specific rtc_id\n * @property {string} [rtcObjects.type] audio the type of the stream\n * @property {number} rtcObjects.streamIndex the index number of the stream (e.g. use to mute)\n * @property {RTCStatsConfig} rtcstats_conf the config needed to controll rtcstats analytics behavior\n * @property {RTCStatsAnalytics} rtcstats an instance to collect analytics from a peer connection\n * @emits Application#rtcstats:report\n * @emits Application#rtcstats:analytics\n * @emits Member#media:stream:on\n */\nclass Media {\n    constructor(conversationOrApplication) {\n        var _a, _b, _c;\n        const conversation = conversationOrApplication instanceof conversation_1.default\n            ? conversationOrApplication\n            : null;\n        const application = conversationOrApplication instanceof application_1.default\n            ? conversationOrApplication\n            : null;\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        if (conversation) {\n            this.rtcHelper = new rtc_helper_1.default();\n            this.application = conversation.application;\n            this.application.activeStreams = this.application.activeStreams || [];\n            this.parentConversation = conversation;\n            this.rtcObjects = {};\n            this.streamIndex = 0;\n            this.rtcstats_conf = ((_c = (_b = (_a = this.application) === null || _a === void 0 ? void 0 : _a.session) === null || _b === void 0 ? void 0 : _b.config) === null || _c === void 0 ? void 0 : _c.rtcStats) || {};\n            this.rtcStats = null;\n        }\n        else if (application) {\n            this.rtcHelper = new rtc_helper_1.default();\n            this.application = application;\n        }\n        else {\n            this.log.warn(\"No conversation object in Media\");\n        }\n    }\n    _attachEndingEventHandlers() {\n        if (!this.parentConversation) {\n            return;\n        }\n        this.log.debug(\"attaching leave listeners in media for \" + this.parentConversation.id);\n        this.parentConversation.on(\"rtc:hangup\", async (event) => {\n            let member;\n            if (this.parentConversation.members.has(event.from)) {\n                member = this.parentConversation.members.get(event.from);\n            }\n            else {\n                try {\n                    member = await this.parentConversation.getMember(event.from);\n                }\n                catch (error) {\n                    this.log.warn(`There is an error getting the member ${error}`);\n                }\n            }\n            if (member.user.id === this.application.me.id &&\n                this.application.activeStreams.length) {\n                this._cleanMediaProperties();\n            }\n            // terminate peer connection stream in case of a transfer\n            if (member.user.id === this.application.me.id &&\n                member.transferred_from) {\n                member.transferred_from.media._cleanMediaProperties();\n            }\n            if (member.user.id === this.application.me.id) {\n                this.parentConversation.off(\"rtc:hangup\");\n            }\n        });\n    }\n    /**\n     * Switch on the rtc stats emit events\n     * @private\n     */\n    _enableStatsEvents() {\n        this.rtcstats_conf.emit_rtc_analytics = true;\n        this.rtcstats_conf.remote_collection = true;\n        const rtcObject = this._findRtcObjectByType(\"audio\");\n        if (!this.rtcStats && rtcObject) {\n            this.log.debug(`enabling stats events for ${rtcObject.rtc_id}`);\n            this.rtcStats = rtc_helper_1.default._initStatsEvents({\n                application: this.application,\n                rtc_id: rtcObject.rtc_id,\n                pc: this.pc,\n                conversation: this.parentConversation,\n            });\n        }\n    }\n    /**\n     * Switch off the rtcStat events\n     * @private\n     */\n    _disableStatsEvents() {\n        this.rtcstats_conf.emit_events = false;\n        this.rtcstats_conf.emit_rtc_analytics = false;\n        this.rtcstats_conf.remote_collection = false;\n        this.rtcStats.removeIntervals();\n        delete this.rtcStats;\n    }\n    /**\n     * Function used to init the media stream\n     * @private\n     */\n    _audioInitHandler(params = {}, onIceCandidateHandler) {\n        return new Promise(async (resolve, reject) => {\n            const streamIndex = this.streamIndex;\n            this.streamIndex++;\n            const { audioConstraints } = params;\n            try {\n                const localStream = await rtc_helper_1.default.getUserAudio(audioConstraints);\n                const pc = rtc_helper_1.default.createPeerConnection(this.application);\n                this.pc = pc;\n                const { application, log, parentConversation: conversation, rtcObjects } = this;\n                const context = {\n                    pc,\n                    streamIndex,\n                    localStream,\n                    application,\n                    conversation,\n                    log,\n                    rtcObjects\n                };\n                onIceCandidateHandler({ ...context, resolve, reject });\n                rtc_helper_1.default.attachConversationEventHandlers(context);\n                this._attachEndingEventHandlers();\n            }\n            catch (error) {\n                reject(new nexmoClientError_1.NexmoClientError(error));\n            }\n        });\n    }\n    /**\n     * Handles the enabling of audio when an offer is available\n     * @private\n     */\n    _execAnswer(params = {}) {\n        const { offer: { sdp, leg_id } } = params;\n        return this._audioInitHandler(params, (context) => rtc_helper_1.default.doAnswer(context, sdp, leg_id));\n    }\n    /**\n     * Handles the enabling of audio only stream with rtc:new\n     * @private\n     */\n    _handleAudio(params = {}) {\n        const { reconnectRtcId } = params;\n        return this._audioInitHandler(params, (context) => rtc_helper_1.default.attachPeerConnectionEventHandlers({ ...context, reconnectRtcId }));\n    }\n    _findRtcObjectByType(type) {\n        return Object.values(this.rtcObjects).find((rtcObject) => rtcObject.type === type);\n    }\n    async _cleanConversationProperties() {\n        if (this.pc) {\n            this.pc.close();\n        }\n        // stop active stream\n        delete this.pc;\n        this.rtcStats = null;\n        this.application.activeStreams = [];\n        this.listeningToRtcEvent = false;\n        await Promise.resolve();\n    }\n    /**\n     * Cleans up the user's media before leaving the conversation\n     * @private\n     */\n    _cleanMediaProperties() {\n        if (this.pc) {\n            this.pc.close();\n        }\n        if (this.rtcObjects) {\n            for (const leg_id in this.rtcObjects) {\n                rtc_helper_1.default.closeStream(this.rtcObjects[leg_id].stream);\n            }\n        }\n        delete this.pc;\n        this.rtcStats = null;\n        this.application.activeStreams = [];\n        this.rtcObjects = {};\n        this.listeningToRtcEvent = false;\n    }\n    async _disableLeg(leg_id) {\n        const csRequestPromise = new Promise(async (resolve, reject) => {\n            try {\n                await this.application.session.sendNetworkRequest({\n                    type: \"DELETE\",\n                    path: `conversations/${this.parentConversation.id}/rtc/${leg_id}?from=${this.parentConversation.me.id}&originating_session=${this.application.session.session_id}`,\n                    version: \"beta2\",\n                });\n                resolve(\"rtc:terminate:success\");\n            }\n            catch (error) {\n                reject(new nexmoClientError_1.NexmoApiError(error));\n            }\n        });\n        const closeResourcesPromise = new Promise((resolve) => {\n            if (this.rtcObjects[leg_id].pc) {\n                this.rtcObjects[leg_id].pc.close();\n            }\n            if (this.rtcObjects[leg_id].stream) {\n                rtc_helper_1.default.closeStream(this.rtcObjects[leg_id].stream);\n            }\n            resolve();\n        });\n        try {\n            await Promise.all([csRequestPromise, closeResourcesPromise]);\n            this.parentConversation.me.emit(\"media:stream:off\", this.rtcObjects[leg_id].streamIndex);\n            delete this.rtcObjects[leg_id];\n            return \"rtc:terminate:success\";\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    _enableMediaTracks(tracks, enabled) {\n        tracks.forEach((mediaTrack) => {\n            mediaTrack.enabled = enabled;\n        });\n    }\n    /**\n     * Send a mute request with the rtc_id and enable/disable the tracks\n     * If the mute request fails revert the changes in the tracks\n     * @private\n     */\n    async _setMediaTracksAndMute(rtc_id, tracks, mute, mediaType) {\n        this._enableMediaTracks(tracks, !mute);\n        try {\n            return await this.application.session.sendNetworkRequest({\n                type: \"POST\",\n                path: `conversations/${this.parentConversation.id}/events`,\n                data: {\n                    type: mediaType,\n                    to: this.parentConversation.me.id,\n                    from: this.parentConversation.me.id,\n                    body: {\n                        rtc_id,\n                    },\n                },\n            });\n        }\n        catch (error) {\n            this._enableMediaTracks(tracks, mute);\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Replaces the stream's audio tracks currently being used as the sender's sources with a new one\n     * @param {object} constraints - audio constraints - { deviceId: { exact: selectedAudioDeviceId } }\n     * @param {string} type - rtc object type - audio\n     * @returns {Promise<MediaStream>} - Returns the new stream.\n     * @example <caption>Update the stream currently being used with a new audio source</caption>\n     * conversation.media.updateAudioConstraints({ deviceId: { exact: selectedAudioDeviceId } }, \"audio\")\n     * .then((response) => {\n     *   console.log(response);\n     * }).catch((error) => {\n     *   console.error(error);\n     * });\n     *\n     *\n     */\n    async updateAudioConstraints(constraints = {}) {\n        let rtcObjectByType = this._findRtcObjectByType('audio');\n        if (rtcObjectByType && rtcObjectByType.pc) {\n            try {\n                const localStream = await rtc_helper_1.default.getUserAudio(constraints);\n                localStream.getTracks().forEach((track) => {\n                    const sender = rtcObjectByType.pc\n                        .getSenders()\n                        .find((s) => s.track.kind === track.kind);\n                    if (sender) {\n                        track.enabled = sender.track.enabled;\n                        sender.replaceTrack(track);\n                    }\n                });\n                rtc_helper_1.default.closeStream(rtcObjectByType.stream);\n                rtcObjectByType.stream = localStream;\n                return localStream;\n            }\n            catch (error) {\n                return error;\n            }\n        }\n        else {\n            throw new nexmoClientError_1.NexmoApiError(\"error:media:stream:not-found\");\n        }\n    }\n    /**\n     * Mute your Member\n     *\n     * @param {boolean} [mute=false] true for mute, false for unmute\n     * @param {number} [streamIndex] stream id to set - if it's not set all streams will be muted\n     * @example <caption>Mute your audio stream in the Conversation</caption>\n     * // Mute your Member\n     * conversation.media.mute(true);\n     *\n     * // Unmute your Member\n     * conversation.media.mute(false);\n     */\n    mute(mute = false, streamIndex = null) {\n        const state = mute ? \"on\" : \"off\";\n        const audioType = \"audio:mute:\" + state;\n        let promises = [];\n        let muteObjects = {};\n        if (streamIndex !== null) {\n            muteObjects[0] = Object.values(this.rtcObjects).find((rtcObj) => rtcObj.streamIndex === streamIndex);\n            if (!muteObjects[0]) {\n                throw new nexmoClientError_1.NexmoClientError(\"error:media:stream:not-found\");\n            }\n        }\n        else {\n            muteObjects = this.rtcObjects;\n        }\n        Object.values(muteObjects).forEach((rtcObject) => {\n            const audioTracks = rtcObject.stream.getAudioTracks();\n            const audioPromise = this._setMediaTracksAndMute(rtcObject.rtc_id, audioTracks, mute, audioType);\n            promises.push(audioPromise);\n        });\n        return Promise.all(promises);\n    }\n    /**\n     * Earmuff our member\n     *\n     * @param {boolean} [params]\n     *\n     * @returns {Promise}\n     * @private\n     */\n    async earmuff(earmuff) {\n        try {\n            if (this.me === null) {\n                throw new nexmoClientError_1.NexmoClientError(\"error:self\");\n            }\n            else {\n                let type = \"audio:earmuff:off\";\n                if (earmuff) {\n                    type = \"audio:earmuff:on\";\n                }\n                const { response, } = await this.application.session.sendNetworkRequest({\n                    type: \"POST\",\n                    path: `conversations/${this.parentConversation.id}/events`,\n                    data: {\n                        type,\n                        to: this.parentConversation.me.id,\n                    },\n                });\n                return response;\n            }\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Enable media participation in the conversation for this application (requires WebRTC)\n     * @param {object} [params] - rtc params\n     * @param {string} [params.label] - label is an application defined tag, eg. ‘fullscreen’\n     * @param {string} [params.reconnectRtcId] - the rtc_id / leg_id of the call to reconnect to\n     * @param {object} [params.audio=true] - audio enablement mode. possible values \"both\", \"send_only\", \"receive_only\", \"none\", true or false\n     * @param {object} [params.autoPlayAudio=false] - attach the audio stream automatically to start playing after enable media (default false)\n     * @param {object} [params.audioConstraints] - audio constraints to use\n     * @param {boolean} [params.audioConstraints.autoGainControl] - a boolean which specifies whether automatic gain control is preferred and/or required\n     * @param {boolean} [params.audioConstraints.echoCancellation] - a boolean specifying whether or not echo cancellation is preferred and/or required\n     * @param {boolean} [params.audioConstraints.noiseSuppression] - a boolean which specifies whether noise suppression is preferred and/or required\n     * @param {string | Array} [params.audioConstraints.deviceId] - object specifying a device ID or an array of device IDs which are acceptable and/or required\n     * @returns {Promise<MediaStream>}\n     * @example <caption>Enable media in the Conversation</caption>\n     *\n     * conversation.media.enable()\n     * .then((stream) => {\n     *    const media = document.createElement(\"audio\");\n     *    const source = document.createElement(\"source\");\n     *    const media_div = document.createElement(\"div\");\n     *    media.appendChild(source);\n     *    media_div.appendChild(media);\n     *    document.insertBefore(media_div);\n     *    // Older browsers may not have srcObject\n     *    if (\"srcObject\" in media) {\n     *      media.srcObject = stream;\n     *    } else {\n     *      // Avoid using this in new browsers, as it is going away.\n     *      media.src = window.URL.createObjectURL(stream);\n     *    }\n     *    media.onloadedmetadata = (e) => {\n     *      media.play();\n     *    };\n     * }).catch((error) => {\n     *    console.error(error);\n     * });\n     *\n     **/\n    async enable(params) {\n        try {\n            if (this.parentConversation.me === null) {\n                throw new nexmoClientError_1.NexmoClientError(\"error:self\");\n            }\n            else {\n                const { offer } = (params !== null && params !== void 0 ? params : {});\n                let remoteStream = await (offer !== undefined ? this._execAnswer(params) : this._handleAudio(params));\n                // attach the audio stream automatically to start playing\n                let autoPlayAudio = params &&\n                    (params.autoPlayAudio || params.autoPlayAudio === undefined);\n                if (!params || autoPlayAudio) {\n                    rtc_helper_1.default.playAudioStream(remoteStream);\n                }\n                return remoteStream;\n            }\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    /**\n     * Disable media participation in the conversation for this application\n     * if RtcStats MOS is enabled, a final report will be available in\n     * NexmoClient#rtcstats:report\n     * @returns {Promise}\n     * @example <caption>Disable media in the Conversation</caption>\n     *\n     * conversation.media.disable()\n     * .then((response) => {\n     *   console.log(response);\n     * }).catch((error) => {\n     *   console.error(error);\n     * });\n     *\n     **/\n    disable() {\n        let promises = [];\n        promises.push(this._cleanConversationProperties());\n        for (const leg_id in this.rtcObjects) {\n            promises.push(this._disableLeg(leg_id));\n        }\n        return Promise.all(promises);\n    }\n    /**\n     * Play a voice text in the Conversation\n     * @param {object} params\n     * @param {string} params.text - The text to say in the Conversation.\n     * @param {string} [params.voice_name=\"Amy\"] - Name of the voice to use for speech to text.\n     * @param {number} [params.level=1] - Set the audio level of the audio stream: min=-1 max=1 increment=0.1.\n     * @param {boolean} [params.queue=true] - ?\n     * @param {boolean} [params.loop=1] - The number of times to repeat audio. Set to 0 to loop infinitely.\n     * @param {boolean} [params.ssml=false] - Customize the spoken text with <a href=\"https://developer.nexmo.com/voice/voice-api/guides/customizing-tts\">Speech Synthesis Markup Language (SSML)</a> specification\n     *\n     * @returns {Promise<NXMEvent>}\n     * @example <caption>Play speech to text in the Conversation</caption>\n     * conversation.media.sayText({text:\"hi\"})\n     * .then((response) => {\n     *    console.log(response);\n     * })\n     * .catch((error) => {\n     *     console.error(error);\n     * });\n     *\n     **/\n    async sayText(params) {\n        try {\n            const response = await this.application.session.sendNetworkRequest({\n                type: \"POST\",\n                path: `conversations/${this.parentConversation.id}/events`,\n                data: {\n                    type: \"audio:say\",\n                    cid: this.parentConversation.id,\n                    from: this.parentConversation.me.id,\n                    body: {\n                        text: params.text,\n                        voice_name: params.voice_name || \"Amy\",\n                        level: params.level || 1,\n                        queue: params.queue || true,\n                        loop: params.loop || 1,\n                        ssml: params.ssml || false,\n                    },\n                },\n            });\n            return new nxmEvent_1.default(this.parentConversation, response);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Send DTMF in the Conversation\n     * @param {string} digit - the DTMF digit(s) to send\n     *\n     * @returns {Promise<NXMEvent>}\n     * @example <caption>Send DTMF in the Conversation</caption>\n     * conversation.media.sendDTMF(\"digit\");\n     * .then((response) => {\n     *    console.log(response);\n     * })\n     * .catch((error) => {\n     *     console.error(error);\n     * });\n     **/\n    async sendDTMF(digit) {\n        try {\n            if (!utils_1.default.validateDTMF(digit)) {\n                throw new nexmoClientError_1.NexmoClientError(\"error:audio:dtmf:invalid-digit\");\n            }\n            const rtc_id = (this._findRtcObjectByType('audio') || {}).rtc_id;\n            if (!rtc_id) {\n                throw new nexmoClientError_1.NexmoClientError(\"error:audio:dtmf:audio-disabled\");\n            }\n            const { id, timestamp, } = await this.application.session.sendNetworkRequest({\n                type: \"POST\",\n                path: `conversations/${this.parentConversation.id}/events`,\n                data: {\n                    type: \"audio:dtmf\",\n                    from: this.parentConversation.me.id,\n                    body: {\n                        digit,\n                        channel: {\n                            type: \"app\",\n                            id: this._findRtcObjectByType('audio').rtc_id\n                        }\n                    },\n                },\n            });\n            const placeholder_event = {\n                body: {\n                    digit,\n                    dtmf_id: \"\",\n                },\n                cid: this.parentConversation.id,\n                from: this.parentConversation.me.id,\n                id,\n                timestamp,\n                type: \"audio:dtmf\",\n            };\n            const dtmfEvent = new nxmEvent_1.default(this.parentConversation, placeholder_event);\n            this.parentConversation.events.set(placeholder_event.id, dtmfEvent);\n            return dtmfEvent;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Play an audio stream in the Conversation\n     * @param {object} params\n     * @param {number} params.level - Set the audio level of the audio stream: min=-1 max=1 increment=0.1.\n     * @param {array} params.stream_url - Link to the audio file.\n     * @param {number} params.loop - The number of times to repeat audio. Set to 0 to loop infinitely.\n     *\n     * @returns {Promise<NXMEvent>}\n     * @example <caption>Play an audio stream in the Conversation</caption>\n     * conversation.media.playStream({ level: 0.5, stream_url: [\"https://nexmo-community.github.io/ncco-examples/assets/voice_api_audio_streaming.mp3\"], loop: 1 })\n     * .then((response) => {\n     *   console.log(\"response: \", response);\n     * })\n     * .catch((error) => {\n     *   console.error(\"error: \", error);\n     * });\n     *\n     */\n    async playStream(params) {\n        try {\n            const response = await this.application.session.sendNetworkRequest({\n                type: \"POST\",\n                path: `conversations/${this.parentConversation.id}/events`,\n                data: {\n                    type: \"audio:play\",\n                    body: params,\n                },\n            });\n            return new nxmEvent_1.default(this.parentConversation, response);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Send start ringing event\n     * @returns {Promise<NXMEvent>}\n     * @example <caption>Send start ringing event in the Conversation</caption>\n     *\n     * conversation.media.startRinging()\n     * .then((response) => {\n     *    console.log(response);\n     * }).catch((error) => {\n     *    console.error(error);\n     * });\n     *\n     * // Listen for start ringing event\n     * conversation.on('audio:ringing:start', (data) => {\n     *    console.log(\"ringing started: \", data);\n     * });\n     *\n     */\n    async startRinging() {\n        try {\n            const response = await this.application.session.sendNetworkRequest({\n                type: \"POST\",\n                path: `conversations/${this.parentConversation.id}/events`,\n                data: {\n                    type: \"audio:ringing:start\",\n                    from: this.parentConversation.me.id,\n                    body: {},\n                },\n            });\n            return new nxmEvent_1.default(this.parentConversation, response);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Send stop ringing event\n     * @returns {Promise<NXMEvent>}\n     * @example <caption>Send stop ringing event in the Conversation</caption>\n     *\n     * conversation.media.stopRinging()\n     * .then((response) => {\n     *    console.log(response);\n     * }).catch((error) => {\n     *    console.error(error);\n     * });\n     *\n     * // Listen for stop ringing event\n     * conversation.on('audio:ringing:stop', (data) => {\n     *    console.log(\"ringing stopped: \", data);\n     * });\n     *\n     */\n    async stopRinging() {\n        try {\n            const response = await this.application.session.sendNetworkRequest({\n                type: \"POST\",\n                path: `conversations/${this.parentConversation.id}/events`,\n                data: {\n                    type: \"audio:ringing:stop\",\n                    from: this.parentConversation.me.id,\n                    body: {},\n                },\n            });\n            return new nxmEvent_1.default(this.parentConversation, response);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n}\nexports.default = Media;\nmodule.exports = Media;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}